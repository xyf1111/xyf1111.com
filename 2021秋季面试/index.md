# 2021秋季面试


## gin和beego的区别(中捷)
Beego是典型的MVC框架
- M：Model，即beego ORM，对象关系映射，以及对象的持久化
特性：
- 支持Go的所有类型存储
- 更简单的curd风格(增删改查)
- 完整实现健壮稳定的ORM
- 支持正则路由
- 支持session
Gin不支持MVC
- 需要开发者自己实现MVC
特性：
- HTML渲染和模板
- 静态文件服务
- 不支持正则路由
- 不支持session(需要安装另外的包)
适用场景
Beego在业务方面较Gin支持的更多
- 在业务更加复杂的项目中，适用Beego
- 在需要快速开发的项目中，适用Beego
- 在1.0项目中，适用Beego
Gin在性能方面较Beego更好
- 当某个接口性能遭到巨大挑战的时候，考虑使用Gin重写接口
- 如果项目的规模不大，业务相对简单，适用Gin
## mongo和redis的持久化区别(中捷)

## mongo和mysql的区别(中捷)
## redis实现分布式锁(珊瑚游戏)
### 如果一个锁没有释放，资源被另一个线程获取，等到前一个线程释放之后会发生什么(珊瑚游戏)
两个线程发生并发显然是不允许的。
一般有两种方法解决改问题
1. 确保代码在过期时间之前释放(添加一个确认值的判断)
2. 为获取锁的线程添加守护线程，为将要过期但为释放的锁增加有效时间
## redis多个进程持续对一个数进行递增，怎么让数增加到9999后回到0(珊瑚游戏)
使用lua脚本保证原子性
## 如何优雅的关闭进程(kill -9 暴力) (珊瑚游戏)
发送一个信号过去signal，类似于(Ctrl + C)，让该执行的执行完毕。
## es存储后可以马上查到嘛 (珊瑚游戏)
es数据插入后，需要刷新片区，最长1s。可以在请求时设置refresh=true，立马可见
## es存储是同步还是异步的 (珊瑚游戏)
数据从mysql到es的同步
1. 同步双写
将数据写入mysql时，同时将数据写入es，实现数据双写
优点：
业务逻辑简单
缺点：
硬编码：有需要写入mysql的地方都需要添加写入es的代码；业务强耦合；存在双写失败丢数据的风险；性能较差，本来mysql性能就不是很高，再加写一个es，系统的性能必然下降。
2. 异步双写(MQ方式)
针对第一种同步双写的性能和数据丢失的问题，可以考虑引入MQ，从而实现异步双写的方案。由于MQ的性能比mysql高出一个数量级，所以性能可以得到显著的提高。
优点：
性能高，不存在丢数据问题
缺点：
硬编码：依然存在业务强耦合；依然存在复杂度增加；系统中加入MQ的代码；可能存在延时问题，程序的写入性能提高了，但是由于MQ的消费可能由于网络或其他原因导致用户写入的数据不一定可以马上看得到，造成延时。
3. 定时器写入
对于实时性要求不高的情况下，可以考虑使用定时器来处理，具体如下：
数据库中添加一个字段为timestamp字段，任何curd操作都会导致该字段的时间发生变化；原来程序中的curd操作不做任何变化；增加一个定时器程序，让该程序按一定的时间周期扫描指定的表，把该时间段内发生变化的数据提取出来；逐条写入es内。
优点：
不改变原来代码，没有侵入性，没有硬编码；没有业务强耦合；不改变原来的程序性能；定时器代码编写不需要考虑增删改查。
缺点：
时效性较差，由于定时器工作周期不可能设在秒级，所以实时性没有2好；对数据库有一定轮询压力，一种改进方式是将轮询放到压力不大的重库上。
4. 利用mysql的binlog来进行同步
具体步骤如下：
- 读取mysql的binlog日志，获取指定表的日志信息
- 将读取的信息转化为MQ
- 编写一个MQ的消费程序
- 不断消费MQ，每消费完一条消息，将消息写入es
优点：
没有代码侵入，没有硬编码；原有系统不需要任何变化，没有感知；性能高；业务解耦，不需要关注原来系统的业务逻辑。
缺点：
构建binlog系统复杂；存在MQ延时风险
## mysql的约束
1. 非空约束(not null 被设置非空约束的字段值不能为空)
2. 唯一约束(unique 被设置唯一约束的字段值不能重复，但是可以为空)
3. 主键约束(primark key 同时保证了唯一和非空)
4. 外键约束(foreign key，让多个表之间关联，从而保证数据的正确性)
## 优化MySQL数据库的八种方法
1. 创建索引
对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘记添加索引造成的，或者说没有添加更为有效的索引导致。如果不添加索引，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响更新速度，这被称为过度索引。
2. 复合索引
比如有一条语句是这样的：select * from users where area='beijing' and age=22;
如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area和age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area, age, salary), (area, age), (area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。
3. 索引不会包含有Null值的列
只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL
4. 使用短索引
对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个char(255)的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对这个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。
5. 排序的索引问题
mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引
6. like语句的操作
一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like"%aaa%"不会使用以索引而like"aaa%"可以使用索引
7. 不要在列上进行运算
select * from users where YEAR(adddate)<2007;将在每个行上进行计算，这将导致索引失效而进行全表扫描，因此我们可以改成 select * from users where adddate<'2007-01-01';
8.  不要使用not in和< >操作
not in和< > 操作都不会使用索引将进行全表扫描。not in可以not exists代替，id < > 3则可使用id > 3 or id < 3来代替
