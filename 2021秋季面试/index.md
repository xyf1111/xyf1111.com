# 2021秋季面试


## gin和beego的区别(中捷)
Beego是典型的MVC框架
- M：Model，即beego ORM，对象关系映射，以及对象的持久化

特性：
- 支持Go的所有类型存储
- 更简单的curd风格(增删改查)
- 完整实现健壮稳定的ORM
- 支持正则路由
- 支持session

Gin不支持MVC

- 需要开发者自己实现MVC

特性：
- HTML渲染和模板
- 静态文件服务
- 不支持正则路由
- 不支持session(需要安装另外的包)

适用场景

Beego在业务方面较Gin支持的更多
- 在业务更加复杂的项目中，适用Beego
- 在需要快速开发的项目中，适用Beego
- 在1.0项目中，适用Beego

Gin在性能方面较Beego更好
- 当某个接口性能遭到巨大挑战的时候，考虑使用Gin重写接口
- 如果项目的规模不大，业务相对简单，适用Gin
## mongo和redis的持久化区别(中捷)
Redis的优点
- 支持多种数据结构：如string，list，hash，set，zset
- 支持持久化操作：可以进行aof和rdb数据持久化到磁盘，从而进行数据备份或数据恢复操作，较好的防止数据丢失的手段
- 支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是redis进行HA的重要手段
- 单线程请求，所有命令串行化执行，并发情况下不需要考虑数据一致性问题
- 支持pub/sub消息订阅机制，可以用来进行消息订阅和通知
- 支持简单的事务需求，但业务使用场景很少，并不成熟

Redis的局限性
- Redis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒(取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右)
- Redis在string类型上会消耗较多内存，可以使用hash压缩存储以降低内存耗用

MongoDB
mongoDB是一种文档型数据库，可以存放xml，json，bson类型
这些数据具备自述性，呈现分层的树状数据结构。redis可以用hash存放简单关系型数据
MongoDB存放json格式数据
适合场景：事件记录、内容管理或博客平台，比如评论系统
1. MongoDB持久化原理

    mongodb与mysql不同，mysql的每一次更新操作都会直接写入硬盘，但是mongo不会，做为内存型数据库，数据操作会先写入内存，然后再会持久化到硬盘中去，那么mongo是如何持久化的呢

    mongodb在启动时，专门初始化一个线程不断循环（除非应用crash掉），用于在一定时间周期内来从defer队列中获取要持久化的数据并写入到磁盘的journal(日志)和mongofile(数据)处，当然因为它不是在用户添加记录时就写到磁盘上，所以按mongodb开发者说，它不会造成性能上的损耗，因为看过代码发现，当进行CUD操作时，记录(Record类型)都被放入到defer队列中以供延时批量（groupcommit）提交写入，但相信其中时间周期参数是个要认真考量的参数，系统为90毫秒，如果该值更低的话，可能会造成频繁磁盘操作，过高又会造成系统宕机时数据丢失过。

2. MongoDB的特点
   - 面向文档
   - 高性能
   - 高可用
   - 易扩展
   - 丰富的查询语言
3. 为什么MongoDB的数据文件很大

    MongoDB采用的预分配空间的方式来防止文件碎片
## Redis和MongoDB的区别
1. 性能

    都比较高，性能对我们来说应该都不是瓶颈。总体来讲，TPS方面redis要大于mongodb
2. 操作的便利性

    redis丰富一些，数据操作方面，redis更好一些，较少的网络IO次数

    mongodb支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富
3. 内存空间的大小和数据量的大小

    redis在2.0版本后增加了自己的VM特性，突破物理内存的限制；可以对key value设置过期时间（类似memcache）

    mongoDB适合大数据量的存储，依赖操作系统VM做内存管理，吃内存也比较厉害，服务不要和别的服务在一起
4. 可用性(单点问题)

    对于单点问题，redis，依赖客户端来实现分布式读写；主从复制时，每次从节点重新连接主节点都要依赖整个快照,无增量复制，因性能和效率问题，所以单点问题比较复杂；不支持自动sharding,需要依赖程序设定一致hash 机制。

    一种替代方案是，不用redis本身的复制机制，采用自己做主动复制（多份存储），或者改成增量复制的方式（需要自己实现），一致性问题和性能的权衡

    mongoDB支持master-slave,replicaset（内部采用paxos选举算法，自动故障恢复）,auto sharding机制，对客户端屏蔽了故障转移和切分机制。
5. 可靠性(持久化)

    对于数据持久化和数据恢复
    
    redis支持（快照、AOF）：依赖快照进行持久化，aof增强了可靠性的同时，对性能有所影响

    MongoDB从1.8版本开始采用binlog方式支持持久化的可靠性
6. 数据一致性(事务支持)

    redis事务支持比较弱，只能保证事务中的每个操作连续执行

    MongoDB不支持事务
7. 数据分析

    MongoDB内置了数据分析的功能，其他不支持
8. 应用场景

    redis：数据量较小的性能操作和运算上

    MongoDB：主要解决海量数据的访问效率问题
## mongo和mysql的区别(中捷)
MySQL是关系型数据库
优点：
- 在不同的引擎上有不同的存储方式
- 查询语句是使用传统的sql语句，拥有较为成熟的体系，成熟度很高
- 开源数据库份额在不断增加，MySQL的份额页在持续增长
缺点：
- 在海量数据处理的时候效率会显著变慢

MongoDB是非关系型数据库，属于文档型数据库。文档是MongoDB中数据的基本单元，类似关系数据库的行，多个键值对有序地放置在一起就是文档，语法有点类似JavaScript面向对象的语言，它是一个面向集合的，模式自由的文档数据库。
- 存储方式：虚拟内存+持久化
- 查询语句：是独特的MongoDB查询方式
- 适合场景：事件的记录，内容管理或者博客平台等等
- 架构特点：可以通过副本集，以及分片来实现高可用
- 数据处理：数据是存储在硬盘上，只不过需要经常读取的数据会被加载到内存中，将数据存储在物理内存中，从而达到高速读写。
- 成熟度与广泛度：新兴数据库，成熟度较低，NoSQL数据库中最接近关系型数据库，比较完善的DB之一，适用人群在不断增长。
优点：
- 快速，在适量级的内存的MongoDB的性能是非常迅速的，它将热数据存在物理内存中使得热数据的读写变得十分快。
- 高扩展性，存储的数据格式是json格式
缺点：
- 不支持事务，开发文档不是很完全，完善
## redis实现分布式锁(珊瑚游戏)
setex 可以设置过期时间

如果过期时间后没有释放会被其他线程获取资源，此时会有并发问题
### 如果一个锁没有释放，资源被另一个线程获取，等到前一个线程释放之后会发生什么(珊瑚游戏)
两个线程发生并发显然是不允许的。
一般有两种方法解决该问题
1. 确保代码在过期时间之前释放(添加一个确认值的判断)
2. 为获取锁的线程添加守护线程，为将要过期但为释放的锁增加有效时间
## redis多个进程持续对一个数进行递增，怎么让数增加到9999后回到0(珊瑚游戏)
使用lua脚本保证原子性
## 如何优雅的关闭进程(kill -9 暴力) (珊瑚游戏)
发送一个信号过去signal，类似于(Ctrl + C)，让该执行的执行完毕。
## es存储后可以马上查到嘛 (珊瑚游戏)
es数据插入后，需要刷新片区，最长1s。可以在请求时设置refresh=true，立马可见
## es存储是同步还是异步的 (珊瑚游戏)
数据从mysql到es的同步
1. 同步双写
将数据写入mysql时，同时将数据写入es，实现数据双写
优点：
业务逻辑简单
缺点：
硬编码：有需要写入mysql的地方都需要添加写入es的代码；业务强耦合；存在双写失败丢数据的风险；性能较差，本来mysql性能就不是很高，再加写一个es，系统的性能必然下降。
2. 异步双写(MQ方式)
针对第一种同步双写的性能和数据丢失的问题，可以考虑引入MQ，从而实现异步双写的方案。由于MQ的性能比mysql高出一个数量级，所以性能可以得到显著的提高。
优点：
性能高，不存在丢数据问题
缺点：
硬编码：依然存在业务强耦合；依然存在复杂度增加；系统中加入MQ的代码；可能存在延时问题，程序的写入性能提高了，但是由于MQ的消费可能由于网络或其他原因导致用户写入的数据不一定可以马上看得到，造成延时。
3. 定时器写入
对于实时性要求不高的情况下，可以考虑使用定时器来处理，具体如下：
数据库中添加一个字段为timestamp字段，任何curd操作都会导致该字段的时间发生变化；原来程序中的curd操作不做任何变化；增加一个定时器程序，让该程序按一定的时间周期扫描指定的表，把该时间段内发生变化的数据提取出来；逐条写入es内。
优点：
不改变原来代码，没有侵入性，没有硬编码；没有业务强耦合；不改变原来的程序性能；定时器代码编写不需要考虑增删改查。
缺点：
时效性较差，由于定时器工作周期不可能设在秒级，所以实时性没有2好；对数据库有一定轮询压力，一种改进方式是将轮询放到压力不大的重库上。
4. 利用mysql的binlog来进行同步
具体步骤如下：
- 读取mysql的binlog日志，获取指定表的日志信息
- 将读取的信息转化为MQ
- 编写一个MQ的消费程序
- 不断消费MQ，每消费完一条消息，将消息写入es
优点：
没有代码侵入，没有硬编码；原有系统不需要任何变化，没有感知；性能高；业务解耦，不需要关注原来系统的业务逻辑。
缺点：
构建binlog系统复杂；存在MQ延时风险
## mysql的约束
1. 非空约束(not null 被设置非空约束的字段值不能为空)
2. 唯一约束(unique 被设置唯一约束的字段值不能重复，但是可以为空)
3. 主键约束(primark key 同时保证了唯一和非空)
4. 外键约束(foreign key，让多个表之间关联，从而保证数据的正确性)
## 优化MySQL数据库的八种方法
1. 创建索引
对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘记添加索引造成的，或者说没有添加更为有效的索引导致。如果不添加索引，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响更新速度，这被称为过度索引。
2. 复合索引
比如有一条语句是这样的：select * from users where area='beijing' and age=22;
如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area和age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area, age, salary), (area, age), (area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。
3. 索引不会包含有Null值的列
只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL
4. 使用短索引
对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个char(255)的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对这个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。
5. 排序的索引问题
mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引
6. like语句的操作
一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like"%aaa%"不会使用以索引而like"aaa%"可以使用索引
7. 不要在列上进行运算
select * from users where YEAR(adddate)<2007;将在每个行上进行计算，这将导致索引失效而进行全表扫描，因此我们可以改成 select * from users where adddate<'2007-01-01';
8.  不要使用not in和< >操作
not in和< > 操作都不会使用索引将进行全表扫描。not in可以not exists代替，id < > 3则可使用id > 3 or id < 3来代替
