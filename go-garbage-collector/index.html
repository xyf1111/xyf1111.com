<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Go垃圾收集器 - CC&#39;s Blog</title><meta name="Description" content="Go垃圾收集器"><meta property="og:title" content="Go垃圾收集器" />
<meta property="og:description" content="Go垃圾收集器" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/go-garbage-collector/" />
<meta property="og:image" content="http://example.org/logo.png"/>
<meta property="article:published_time" content="2021-11-09T17:25:06+08:00" />
<meta property="article:modified_time" content="2021-11-09T17:25:06+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/logo.png"/>

<meta name="twitter:title" content="Go垃圾收集器"/>
<meta name="twitter:description" content="Go垃圾收集器"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://example.org/go-garbage-collector/" /><link rel="prev" href="http://example.org/go-docker/" /><link rel="next" href="http://example.org/go-array/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Go垃圾收集器",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/example.org\/go-garbage-collector\/"
        },"genre": "posts","keywords": "mysql","wordcount":  21950 ,
        "url": "http:\/\/example.org\/go-garbage-collector\/","datePublished": "2021-11-09T17:25:06+08:00","dateModified": "2021-11-09T17:25:06+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "CC"
            },"description": "Go垃圾收集器"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="CC&#39;s Blog">CC&#39;Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="CC&#39;s Blog">CC&#39;Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Go垃圾收集器</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>CC</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E5%AD%A6%E4%B9%A0/"><i class="far fa-folder fa-fw"></i>学习</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-11-09">2021-11-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 21950 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 44 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="true">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#设计原理">设计原理</a>
      <ul>
        <li><a href="#标记清除">标记清除</a></li>
        <li><a href="#三色抽象">三色抽象</a></li>
        <li><a href="#屏障技术">屏障技术</a></li>
        <li><a href="#增量和并发">增量和并发</a></li>
      </ul>
    </li>
    <li><a href="#演进过程">演进过程</a>
      <ul>
        <li><a href="#并发垃圾收集">并发垃圾收集</a></li>
        <li><a href="#回收堆目标">回收堆目标</a></li>
        <li><a href="#混合写屏障">混合写屏障</a></li>
      </ul>
    </li>
    <li><a href="#实现原理">实现原理</a>
      <ul>
        <li><a href="#全局变量">全局变量</a></li>
        <li><a href="#触发时机">触发时机</a></li>
        <li><a href="#垃圾收集启动">垃圾收集启动</a></li>
        <li><a href="#并发扫描与标记辅助">并发扫描与标记辅助</a></li>
        <li><a href="#标记终止">标记终止</a></li>
        <li><a href="#内存清理">内存清理</a></li>
      </ul>
    </li>
    <li><a href="#小结">小结</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="设计原理">设计原理</h2>
<p>今天的编程语言通常会使用以手动和自动两种方式管理内存，C、C++以及Rust等编程语言使用手动方式管理内存，工程师需要主动申请或者释放内存；而Python、Ruby、Java和Go等语言使用自动的内存管理系统，一般都是垃圾回收机制，不过Objective-C却选择了自动引用计数，虽然引用计数也是自动的内存管理机制。</p>
<p>相信很多人对垃圾收集器的印象都是暂停程序(Stop the world, STW)，随着用户程序申请越来越多的内存，系统中的垃圾也逐渐增多；当程序中的内存达到一定阈值时，整个应用程序就会全部暂停，垃圾收集器会扫描已经分配的所有对象并回收不再使用的内存空间，当这个过程结束后，用户程序才可以继续执行，Go语言在早期也使用这种策略实现垃圾收集，但是今天的实现已经复杂了很多。</p>
<p><figure><a class="lightgallery" href="/images/memory-management-component.png" title="&amp;ldquo;内存管理的组件&amp;rdquo;" data-thumbnail="/images/memory-management-component.png" data-sub-html="<h2>内存管理的组件</h2><p>&amp;ldquo;内存管理的组件&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/memory-management-component.png"
            data-srcset="/images/memory-management-component.png, /images/memory-management-component.png 1.5x, /images/memory-management-component.png 2x"
            data-sizes="auto"
            alt="/images/memory-management-component.png" />
    </a><figcaption class="image-caption">内存管理的组件</figcaption>
    </figure></p>
<p>在上图中，用户程序(Mutator)会通过内存分配器(Allocator)在堆上申请内存，而垃圾收集器(Collector)负责回收堆上的内存空间，内存分配器和垃圾收集器共同管理着程序中的堆内存空间。</p>
<h3 id="标记清除">标记清除</h3>
<p>标记清除(Mark-Sweep)算法是最常见的垃圾收集算法，标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记(Mark)和清除(Sweep)两个阶段</p>
<ul>
<li>标记阶段(从根对象出发查找并标记堆中所有存活的对象)</li>
<li>清除阶段(遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表)</li>
</ul>
<p>如下图所示，内存空间中包含多个对象，我们从根对象出发依次遍历对象的子对象并将从根节点可达的对象都标记为存活状态，即A、C和D三个对象，剩余B、E和F三个对象因为从根节点不可达，所以会被当成垃圾。</p>
<p><figure><a class="lightgallery" href="/images/mark-sweep-mark-phase.png" title="&amp;ldquo;标记清除的标记阶段&amp;rdquo;" data-thumbnail="/images/mark-sweep-mark-phase.png" data-sub-html="<h2>标记清除的标记阶段</h2><p>&amp;ldquo;标记清除的标记阶段&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/mark-sweep-mark-phase.png"
            data-srcset="/images/mark-sweep-mark-phase.png, /images/mark-sweep-mark-phase.png 1.5x, /images/mark-sweep-mark-phase.png 2x"
            data-sizes="auto"
            alt="/images/mark-sweep-mark-phase.png" />
    </a><figcaption class="image-caption">标记清除的标记阶段</figcaption>
    </figure></p>
<p>标记阶段结束后会进入清除阶段，在该阶段中收集器会依次遍历堆中的所有对象，释放其中没有被标记的B、E和F三个对象并将新的空闲内存空间以链表的结构串联起来，方便内存分配器的使用</p>
<p><figure><a class="lightgallery" href="/images/mark-sweep-mark-phase2.png" title="&amp;ldquo;标记清除的清除阶段&amp;rdquo;" data-thumbnail="/images/mark-sweep-mark-phase2.png" data-sub-html="<h2>标记清除的清除阶段</h2><p>&amp;ldquo;标记清除的清除阶段&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/mark-sweep-mark-phase2.png"
            data-srcset="/images/mark-sweep-mark-phase2.png, /images/mark-sweep-mark-phase2.png 1.5x, /images/mark-sweep-mark-phase2.png 2x"
            data-sizes="auto"
            alt="/images/mark-sweep-mark-phase2.png" />
    </a><figcaption class="image-caption">标记清除的清除阶段</figcaption>
    </figure></p>
<p>这里介绍的是最传统的标记清除算法，垃圾收集器从垃圾收集的根对象出发，递归遍历这些对象指向的子对象并将所有可达的对象标记成存活；标记阶段结束后，垃圾收集器会依次遍历堆中的对象并清除其中的垃圾，整个过程中需要标记对象的存活状态，用户程序在垃圾收集的过程中也不能执行，我们需要用到更复杂的机制来解决STW的问题。</p>
<h3 id="三色抽象">三色抽象</h3>
<p>为了解决原始标记清除算法带来的长时间STW，多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以缩短STW的时间。三色标记算法将程序中的对象分成白色，黑色和灰色三类</p>
<ul>
<li>白色对象：潜在的垃圾，其内存可能会被垃圾收集器回收</li>
<li>黑色对象：活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象</li>
<li>灰色对象：活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象</li>
</ul>
<p><figure><a class="lightgallery" href="/images/tri-color-objects.png" title="&amp;ldquo;三色的对象&amp;rdquo;" data-thumbnail="/images/tri-color-objects.png" data-sub-html="<h2>三色的对象</h2><p>&amp;ldquo;三色的对象&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/tri-color-objects.png"
            data-srcset="/images/tri-color-objects.png, /images/tri-color-objects.png 1.5x, /images/tri-color-objects.png 2x"
            data-sizes="auto"
            alt="/images/tri-color-objects.png" />
    </a><figcaption class="image-caption">三色的对象</figcaption>
    </figure></p>
<p>在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记为灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不再存在对象时，标记阶段就会结束。</p>
<p><figure><a class="lightgallery" href="/images/tri-color-mark-sweep.png" title="&amp;ldquo;三色标记垃圾收集器的执行过程&amp;rdquo;" data-thumbnail="/images/tri-color-mark-sweep.png" data-sub-html="<h2>三色标记垃圾收集器的执行过程</h2><p>&amp;ldquo;三色标记垃圾收集器的执行过程&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/tri-color-mark-sweep.png"
            data-srcset="/images/tri-color-mark-sweep.png, /images/tri-color-mark-sweep.png 1.5x, /images/tri-color-mark-sweep.png 2x"
            data-sizes="auto"
            alt="/images/tri-color-mark-sweep.png" />
    </a><figcaption class="image-caption">三色标记垃圾收集器的执行过程</figcaption>
    </figure></p>
<p>三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成一下几个步骤：</p>
<ol>
<li>从灰色对象的集合中选择一个灰色对象并将其标记成黑色。</li>
<li>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收。</li>
<li>重复上述两个步骤直到对象图中不存在灰色对象</li>
</ol>
<p>当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象D待回收垃圾</p>
<p><figure><a class="lightgallery" href="/images/tri-color-mark-sweep-after-mark-phase.png" title="&amp;ldquo;三色标记后的堆&amp;rdquo;" data-thumbnail="/images/tri-color-mark-sweep-after-mark-phase.png" data-sub-html="<h2>三色标记后的堆</h2><p>&amp;ldquo;三色标记后的堆&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/tri-color-mark-sweep-after-mark-phase.png"
            data-srcset="/images/tri-color-mark-sweep-after-mark-phase.png, /images/tri-color-mark-sweep-after-mark-phase.png 1.5x, /images/tri-color-mark-sweep-after-mark-phase.png 2x"
            data-sizes="auto"
            alt="/images/tri-color-mark-sweep-after-mark-phase.png" />
    </a><figcaption class="image-caption">三色标记后的堆</figcaption>
    </figure></p>
<p>因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要STW，在如下所示的三色标记过程中，用户程序建立了从A对象到D对象的引用，但是因为程序中已经不存在灰色对象了，所以D对象会被垃圾收集器错误的回收</p>
<p><figure><a class="lightgallery" href="/images/tri-color-mark-sweep-and-mutator.png" title="&amp;ldquo;三色标记与用户程序&amp;rdquo;" data-thumbnail="/images/tri-color-mark-sweep-and-mutator.png" data-sub-html="<h2>三色标记与用户程序</h2><p>&amp;ldquo;三色标记与用户程序&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/tri-color-mark-sweep-and-mutator.png"
            data-srcset="/images/tri-color-mark-sweep-and-mutator.png, /images/tri-color-mark-sweep-and-mutator.png 1.5x, /images/tri-color-mark-sweep-and-mutator.png 2x"
            data-sizes="auto"
            alt="/images/tri-color-mark-sweep-and-mutator.png" />
    </a><figcaption class="image-caption">三色标记与用户程序</figcaption>
    </figure></p>
<p>本来不应该被回收的对象却被回收了，这在内存管理中是非常严重的错误，我们将这种错误称为悬挂指针，即指针没有指向特定类型的合法对象，影响了内存的安全性，想要并发或者增量的标记对象还是需要使用屏障技术</p>
<h3 id="屏障技术">屏障技术</h3>
<p>内存屏障技术是一种屏障指令，它可以让CPU或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障执行前的操作一定会先于内存屏障后执行的操作。</p>
<p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性(Tri-color-invariant)中的一种：</p>
<ul>
<li>强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象</li>
<li>弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径</li>
</ul>
<p><figure><a class="lightgallery" href="/images/strong-weak-tricolor-invariant.png" title="&amp;ldquo;三色不变性&amp;rdquo;" data-thumbnail="/images/strong-weak-tricolor-invariant.png" data-sub-html="<h2>三色不变性</h2><p>&amp;ldquo;三色不变性&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/strong-weak-tricolor-invariant.png"
            data-srcset="/images/strong-weak-tricolor-invariant.png, /images/strong-weak-tricolor-invariant.png 1.5x, /images/strong-weak-tricolor-invariant.png 2x"
            data-sizes="auto"
            alt="/images/strong-weak-tricolor-invariant.png" />
    </a><figcaption class="image-caption">三色不变性</figcaption>
    </figure></p>
<p>上图分别展示了遵循三色不变性和弱三色不变性的堆内存，遵循上述两个不变性的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。</p>
<p>垃圾收集器中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障(Read barrier)和写屏障(Write barrier)两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往会采用写屏障保证三色不变性。</p>
<p>我们在这里想要介绍的是Go语言中使用的两种写屏障技术，分别是Dijkstra提出的插入写屏障和Yuasa提出的删除写屏障，这里会分析它们如何保证三色不变性和垃圾收集器的正确性。</p>
<p><strong>插入写屏障</strong></p>
<p>Dijkstra在1978年提出了插入写屏障，通过如下所示的写屏障，用户程序和垃圾收集器可以在交替工作下保证程序执行的正确性</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">writePointer(slot, ptr):
    shade(ptr)
    *slot = ptr
</code></pre></td></tr></table>
</div>
</div><p>上述插入写屏障的伪代码非常好理解，每当执行类似<code>*slot=ptr</code>的表达式时，我们会执行上述写屏障通过<code>shade</code>函数尝试改变指针的颜色。如果ptr指针是白色的，那么该函数会将该对象设置为灰色，其他情况则不变。</p>
<p><figure><a class="lightgallery" href="/images/dijkstra-insert-write-barrier.png" title="&amp;ldquo;Dijkstra插入写屏障&amp;rdquo;" data-thumbnail="/images/dijkstra-insert-write-barrier.png" data-sub-html="<h2>Dijkstra插入写屏障</h2><p>&amp;ldquo;Dijkstra插入写屏障&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/dijkstra-insert-write-barrier.png"
            data-srcset="/images/dijkstra-insert-write-barrier.png, /images/dijkstra-insert-write-barrier.png 1.5x, /images/dijkstra-insert-write-barrier.png 2x"
            data-sizes="auto"
            alt="/images/dijkstra-insert-write-barrier.png" />
    </a><figcaption class="image-caption">Dijkstra插入写屏障</figcaption>
    </figure></p>
<p>假设我们在应用程序中使用Dijkstra提出的插入写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现上图所示的标记过程</p>
<ol>
<li>垃圾收集器将根对象指向A对象标记成黑色并将A对象指向的对象B标记为灰色</li>
<li>用户程序修改A对象的指针，将原本指向B对象的指针指向C对象，这时触发写屏障将C对象标记成灰色</li>
<li>垃圾收集器一次遍历程序中的其他灰色对象，分别将它们标记成黑色</li>
</ol>
<p>Dijkstra的插入写屏障是一种相对保守的屏障技术，它会将<code>有存活可能的对象都标记成灰色</code>以满足三色不变性。在如上所示的垃圾收集过程中，实际上不再存活的B对象最后没有被回收；而如果我们在第二和第三步之间将指向C对象的指针改为指向B，垃圾收集器仍然认为C对象是存活的，这些被错误标记的垃圾对象只有在下一次循环才会被回收。</p>
<p>插入式的Dijkstra写屏障虽然实现非常简单并且能保证强三色不变性，但是它也有明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，Dijkstra必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之间做出权衡。</p>
<p><strong>删除写屏障</strong></p>
<p>Yuasa在1990年的论文<code>Real-time garbage collection on general-purpose machines</code>中提出了删除写屏障，因为一旦该写屏障开始工作，它会保证开启写屏障时堆上所有对象的可达，所以也被称作为快照垃圾收集(Snapshot GC)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">This guarantees that no objects will become unreachable to the garbage collector traversal all objects which are live at the beginning of garbage collection will be reached even if the pointers to them are overwritten.
</code></pre></td></tr></table>
</div>
</div><p>该算法会使用如下所示的写屏障保证增量或者并发执行垃圾收集时程序的正确性</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">writePointer(slot, ptr)
    shade(*slot)
    *slot = ptr
</code></pre></td></tr></table>
</div>
</div><p>上述代码会在老对象的引用被删除时，将白色的老对象涂成灰色的，这样删除写屏障可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。</p>
<p><figure><a class="lightgallery" href="/images/yuasa-delete-write-barrier.png" title="&amp;ldquo;Yuasa删除写屏障&amp;rdquo;" data-thumbnail="/images/yuasa-delete-write-barrier.png" data-sub-html="<h2>Yuasa删除写屏障</h2><p>&amp;ldquo;Yuasa删除写屏障&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/yuasa-delete-write-barrier.png"
            data-srcset="/images/yuasa-delete-write-barrier.png, /images/yuasa-delete-write-barrier.png 1.5x, /images/yuasa-delete-write-barrier.png 2x"
            data-sizes="auto"
            alt="/images/yuasa-delete-write-barrier.png" />
    </a><figcaption class="image-caption">Yuasa删除写屏障</figcaption>
    </figure></p>
<p>假设我们在应用程序中使用Yuasa提出的删除写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现上图所示的标记过程：</p>
<ol>
<li>垃圾收集器将根对象指向A对象标记成黑色并将A对象指向的对象B标记成灰色</li>
<li>用户程序将A对象原本指向B的指针指向C，触发删除写屏障，但是因为B对象已经是灰色的，所以不做改变</li>
<li>用户程序将B对象原本指向C的指针删除，触发删除写屏障，白色的C对象被涂成灰色</li>
<li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色</li>
</ol>
<p>上述过程中的第三步触发了Yuasa删除写屏障的着色，因为用户程序删除了B指向C对象的指针，所以C和D两个对象会分别违反强三色不变性和弱三色不变性</p>
<ul>
<li>强三色不变性：黑色的A对象直接指向白色的C对象</li>
<li>弱三色不变性：垃圾收集器无法从某个灰色对象出发，经过几个连续的白色对象访问白色的C和D两个对象</li>
</ul>
<p>Yuasa删除写屏障通过对C对象的着色，保证了C对象和下游的D对象能够在这一次垃圾收集的循环中存活，避免发生悬挂指针以保证用户程序的正确性</p>
<h3 id="增量和并发">增量和并发</h3>
<p>传统的垃圾收集算法会在垃圾收集的执行期间暂停应用程序，一旦触发垃圾收集，垃圾收集器会抢占CPU的使用权占据大量的计算资源以完成标记和清楚工作，然而 很多追求实时的应用程序无法接受长时间的STW</p>
<p><figure><a class="lightgallery" href="/images/stop-the-world-collector.png" title="&amp;ldquo;垃圾收集与暂停程序&amp;rdquo;" data-thumbnail="/images/stop-the-world-collector.png" data-sub-html="<h2>垃圾收集与暂停程序</h2><p>&amp;ldquo;垃圾收集与暂停程序&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/stop-the-world-collector.png"
            data-srcset="/images/stop-the-world-collector.png, /images/stop-the-world-collector.png 1.5x, /images/stop-the-world-collector.png 2x"
            data-sizes="auto"
            alt="/images/stop-the-world-collector.png" />
    </a><figcaption class="image-caption">垃圾收集与暂停程序</figcaption>
    </figure></p>
<p>远古时代的计算资源还没有今天这么丰富，今天的计算机往往都是多核的处理器，垃圾收集器一旦开始执行就会浪费大量的计算资源，为了减少应用程序暂停的最长时间和垃圾收集的总暂停时间，我们便会使用下面的策略优化现代的垃圾处理器</p>
<ul>
<li>增量垃圾处理：增量的标记和清除垃圾，降低应用程序暂停的最长时间</li>
<li>并发垃圾收集：利用多核的计算资源，在用户程序执行时并发标记和清除垃圾</li>
</ul>
<p>因为增量和并发这两种方式都可以与用户程序交替进行，所以我们需要<code>使用屏障技术</code>保证垃圾收集器的正确性；与此同时，应用程序也不能等到内存溢出时触发垃圾收集，因为当内存不足时，应用程序已经无法分配内存，这与直接暂停程序没有什么区别，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停。</p>
<p><strong>增量收集器</strong></p>
<p>增量式(Incremental)的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的GC时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间</p>
<p><figure><a class="lightgallery" href="/images/incremental-collector.png" title="&amp;ldquo;增量垃圾收集器&amp;rdquo;" data-thumbnail="/images/incremental-collector.png" data-sub-html="<h2>增量垃圾收集器</h2><p>&amp;ldquo;增量垃圾收集器&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/incremental-collector.png"
            data-srcset="/images/incremental-collector.png, /images/incremental-collector.png 1.5x, /images/incremental-collector.png 2x"
            data-sizes="auto"
            alt="/images/incremental-collector.png" />
    </a><figcaption class="image-caption">增量垃圾收集器</figcaption>
    </figure></p>
<p>需要注意的是，增量式的垃圾收集需要与三色标记法一起使用，为了保证垃圾收集的正确性，我们需要在垃圾收集开始前打开写屏障，这样用户程序修改内存都会先经过写屏障的处理，保证了堆内存中对象的强三色不变性或弱三色不变性。虽然增量式垃圾收集器能够减少最大的程序暂停时间，但是增量式收集也会增加一次GC循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也要承担额外的计算开销，所以增量式的垃圾收集也不是只带来好处的，但是总体来说还是利大于弊的。</p>
<p><strong>并发收集器</strong></p>
<p>并发(Concurrent)的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、利用多核优势与用户程序并行执行，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响：</p>
<p><figure><a class="lightgallery" href="/images/concurrent-collector.png" title="&amp;ldquo;并发垃圾收集器&amp;rdquo;" data-thumbnail="/images/concurrent-collector.png" data-sub-html="<h2>并发垃圾收集器</h2><p>&amp;ldquo;并发垃圾收集器&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/concurrent-collector.png"
            data-srcset="/images/concurrent-collector.png, /images/concurrent-collector.png 1.5x, /images/concurrent-collector.png 2x"
            data-sizes="auto"
            alt="/images/concurrent-collector.png" />
    </a><figcaption class="image-caption">并发垃圾收集器</figcaption>
    </figure></p>
<p>虽然并发收集器能够与用户程序一起运行，但是并不是所有阶段都可以与用户程序一起运行，部分阶段还是需要暂停用户程序的，不过这与传统的算法相比，并发的垃圾收集器可以将能够并发执行的工作尽量并发执行；当然，因为读写屏障的引入，并发的垃圾收集器一定也会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序，这是我们在设计垃圾回收策略时必须要注意的。</p>
<h2 id="演进过程">演进过程</h2>
<p>Go语言的垃圾收集器从诞生的第一天起就一直在演进，除了少数的几个版本没有大更新之外，几乎每次发布的小版本都会提升垃圾收集的性能，而与性能一同提升的还有垃圾收集代码的复杂度，本节将从Go语言的v1.0版本开始分析垃圾收集器的演进过程。</p>
<ol>
<li>v1.0：完全串行的标记和清除过程，需要暂停整个程序</li>
<li>v1.1：在多核主机上并行执行垃圾收集的标记和清除阶段</li>
<li>v1.3：运行时基于<code>只有指针类型的值包含指针</code>的假设增加了对栈内存的精准扫描支持，实现了真正精准的垃圾收集
<ul>
<li>将<code>unsafe.Pointer</code> 类型转化成整数类型的值认定为不合法的，可能会造成悬挂指针等严重问题</li>
</ul>
</li>
<li>v1.5：实现了基于<code>三色标记清扫的并发</code>垃圾收集器
<ul>
<li>大幅度降低垃圾收集的延迟从几百ms降低至10ms以下</li>
<li>计算垃圾收集启动的合适时间并通过并发加速垃圾收集的过程</li>
</ul>
</li>
<li>v1.6：实现了<code>去中心化</code>的垃圾收集协调器
<ul>
<li>基于显式的状态机使得任意Goroutine都能触发垃圾收集的状态迁移</li>
<li>使用密集的位图代替空闲链表表示的堆内存，降低清除阶段的CPU占用</li>
</ul>
</li>
<li>v1.7：通过<code>并行栈收缩</code>将垃圾收集的时间缩短至2ms以内</li>
<li>v1.8：使用<code>混合写屏障</code>将垃圾收集的时间缩短至0.5ms以内</li>
<li>v1.9：彻底移除暂停程序的重新扫描栈的过程</li>
<li>v1.10：更新了垃圾收集调频器(Pacer)的实现，分离软硬堆大小的目标</li>
<li>v1.12：使用<code>新的标记终止算法</code>简化垃圾收集器的几个阶段</li>
<li>v1.13：通过新的Scavenger解决瞬间内存占用过高的应用程序向操作系统归还内存的问题</li>
<li>v1.14：使用全新的页分配器<code>优化内存分配的速度</code></li>
</ol>
<p>我们从Go语言垃圾收集器的演进能够看到该组件的实现和算法变得越来越复杂，最开始的垃圾收集器还是不精准的单线程STW收集器，但是最新版本的垃圾收集器却支持并发垃圾收集、去中心化协调等特性，我们在这里将介绍与最新版垃圾收集器相关的组件和特性。</p>
<h3 id="并发垃圾收集">并发垃圾收集</h3>
<p>Go语言在v1.5中引入了并发的垃圾收集器，该垃圾收集器使用了我们上面提到的三色抽象和写屏障技术保证垃圾收集器执行的正确性，如何实现并发的垃圾收集器在这里就不展开介绍了，我们来了解一些并发垃圾收集器的工作流程。</p>
<p>首先，并发垃圾收集器必须在合适的时间点触发垃圾收集循环，假设我们的Go语言运行在一台4核的物理机上，那么在垃圾收集开始后，收集器会占用25%计算资源在后台来扫描并标记内存中的对象。</p>
<p><figure><a class="lightgallery" href="/images/golang-concurrent-collector.png" title="&amp;ldquo;语言的并发收集&amp;rdquo;" data-thumbnail="/images/golang-concurrent-collector.png" data-sub-html="<h2>语言的并发收集</h2><p>&amp;ldquo;语言的并发收集&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/golang-concurrent-collector.png"
            data-srcset="/images/golang-concurrent-collector.png, /images/golang-concurrent-collector.png 1.5x, /images/golang-concurrent-collector.png 2x"
            data-sizes="auto"
            alt="/images/golang-concurrent-collector.png" />
    </a><figcaption class="image-caption">语言的并发收集</figcaption>
    </figure></p>
<p>Go语言的并发垃圾收集器会在扫描对象之前暂停程序做一些标记对象的准备工作，其中包括启动后台标记的垃圾收集器以及开启写屏障，如果在后台执行的垃圾收集器不够快，应用程序申请内存的速度超过预期，运行时会让申请内存的应用程序辅助完成垃圾收集的扫描阶段，在标记和标记终止阶段结束之后就会进入异步的清理阶段，将不用的内存增量回收。</p>
<p>v1.5版本实现的并发垃圾收集策略由专门的Goroutine负责在处理器间同步和协调垃圾收集的状态。当其他的Goroutine发现需要触发垃圾收集时，它们需要将该信息通知给负责修改状态的主Goroutine，然而这个通知的过程会带来一定的延迟，这个延迟的时间窗口是不可控的，用户程序会在这段时间继续分配内存。</p>
<p>v1.6版本引入了去中心化的垃圾收集协调机制，将垃圾收集器变成一个显式的状态机，任意的Goroutine都可以调用方法触发状态的迁移，常见的状态迁移方法包括以下几个：</p>
<ul>
<li><code>runtime.gcStart</code>：从<code>_GCoff</code>阶段转换至<code>_GCmark</code>阶段，进入并发标记阶段并打开写屏障</li>
<li><code>runtime.gcMarkDone</code>：如果所有可达对象都已经完成扫描调用<code>runtime.gcMarkTermination</code></li>
<li><code>runtime.gcMarkTermination</code>：从<code>_GCmark</code>转换<code>_GCmarktermination</code>阶段，进入标记终止阶段并在完成后进入<code>_GCoff</code></li>
</ul>
<p>上述的三个方法是在与<code>runtime: replace GC coordinator with state machine</code>问题相关的提交中引入的，它们移除了过去中心化的状态迁移过程。</p>
<h3 id="回收堆目标">回收堆目标</h3>
<p>STW的垃圾收集器虽然需要暂停应用程序，但是它能够有效地控制堆内存的大小，Go语言运行时默认配置会在堆内存达到上一次垃圾收集的两倍时，触发新一轮的垃圾收集，这个行为可以通过环境变量<code>GOGC</code>调整，在默认情况下它的值为100，即增长100%的堆内存才会触发GC。</p>
<p><figure><a class="lightgallery" href="/images/stop-the-world-garbage-collector-heap.png" title="&amp;ldquo;STW垃圾收集器的垃圾收集时间&amp;rdquo;" data-thumbnail="/images/stop-the-world-garbage-collector-heap.png" data-sub-html="<h2>STW垃圾收集器的垃圾收集时间</h2><p>&amp;ldquo;STW垃圾收集器的垃圾收集时间&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/stop-the-world-garbage-collector-heap.png"
            data-srcset="/images/stop-the-world-garbage-collector-heap.png, /images/stop-the-world-garbage-collector-heap.png 1.5x, /images/stop-the-world-garbage-collector-heap.png 2x"
            data-sizes="auto"
            alt="/images/stop-the-world-garbage-collector-heap.png" />
    </a><figcaption class="image-caption">STW垃圾收集器的垃圾收集时间</figcaption>
    </figure></p>
<p>因为并发垃圾收集器会和程序一起执行，所以它无法准确的控制内存的大小，并发收集器需要在达到目标前触发垃圾收集，这样才能够保证内存的大小可控，并发收集器需要尽可能保证垃圾收集结束时的堆内存与用户配置的<code>GOGC</code>一致。</p>
<p><figure><a class="lightgallery" href="/images/concurrent-garbage-collector-heap.png" title="&amp;ldquo;并发收集器的堆内存&amp;rdquo;" data-thumbnail="/images/concurrent-garbage-collector-heap.png" data-sub-html="<h2>并发收集器的堆内存</h2><p>&amp;ldquo;并发收集器的堆内存&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/concurrent-garbage-collector-heap.png"
            data-srcset="/images/concurrent-garbage-collector-heap.png, /images/concurrent-garbage-collector-heap.png 1.5x, /images/concurrent-garbage-collector-heap.png 2x"
            data-sizes="auto"
            alt="/images/concurrent-garbage-collector-heap.png" />
    </a><figcaption class="image-caption">并发收集器的堆内存</figcaption>
    </figure></p>
<p>Go语言v1.5引入并发垃圾收集器的同时使用垃圾收集调步(Pacing)算法计算触及的垃圾收集的最佳时间，确保触发的时间既不会浪费计算资源，也不会超出预期的堆大小。如上图所示，其中黑色的部分是上一次垃圾收集后标记的堆大小，绿色部分是上次垃圾收集结束后新分配的内存，因为我们使用并发垃圾收集，所以黄色部分就是在垃圾收集期间分配的内存，最后的红色部分是垃圾收集结束时与目标的差值，我们希望尽可能减少红色部分的内存，降低垃圾收集带来的额外开销以及程序的暂停时间。</p>
<p>垃圾收集调步算法是跟随v1.5一同引入的，该算法的目标是优化堆的增长速度和垃圾收集器的CPU利用率，而在v1.10版本中又对该算法进行了优化，将原有的目的堆大小拆分成软硬两个目标，因为调整垃圾收集的执行频率涉及较为复杂的公式，对理解垃圾收集原理帮助较为有限。</p>
<h3 id="混合写屏障">混合写屏障</h3>
<p>在Go语言v1.7版本之前，运行时会使用Dijkstra插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。因为应用程序可能包含成百上千的Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个Goroutine的栈上都开启写屏障，会带来巨大的额外开销，所以Go团队在实现上选择了在标记阶段完成时<code>暂停程序、将所有栈对象标记为灰色并重新扫描</code>，在活跃Goroutine非常多的程序中，重新扫描的过程需要占用10~100ms的时间。</p>
<p>Go语言在v1.8组合Dijkstra插入写屏障和Yuasa删除写屏障构成了如下所示的混合写屏障，该写屏障会<code>将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">writePointer</span><span class="p">(</span><span class="nx">slot</span><span class="p">,</span> <span class="nx">ptr</span><span class="p">):</span>
    <span class="nf">shade</span><span class="p">(</span><span class="o">*</span><span class="nx">slot</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">current</span> <span class="nx">stack</span> <span class="nx">is</span> <span class="nx">grey</span><span class="p">:</span>
        <span class="nf">shade</span><span class="p">(</span><span class="nx">ptr</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">slot</span><span class="p">=</span><span class="nx">ptr</span>
</code></pre></td></tr></table>
</div>
</div><p>为了移除栈的重新扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要<code>将创建的所有新对象都标记成黑色</code>，防止新分配的栈内存和堆内存中的对象被错误的回收，因为栈内存在标记阶段最终都会变为黑色，所以不需要再重新扫描栈空间。</p>
<h2 id="实现原理">实现原理</h2>
<p>在介绍垃圾收集器的演进过程之前，我们需要初步了解最新垃圾收集器的执行周期，这对我们了解其全局的设计会有比较大的帮助。Go语言的垃圾收集可以分成清除终止、标记、标记终止和清除四个不同阶段，它们分别完成了不同的工作。</p>
<p><figure><a class="lightgallery" href="/images/garbage-collector-phaes.png" title="&amp;ldquo;垃圾收集的多个阶段&amp;rdquo;" data-thumbnail="/images/garbage-collector-phaes.png" data-sub-html="<h2>垃圾收集的多个阶段</h2><p>&amp;ldquo;垃圾收集的多个阶段&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/garbage-collector-phaes.png"
            data-srcset="/images/garbage-collector-phaes.png, /images/garbage-collector-phaes.png 1.5x, /images/garbage-collector-phaes.png 2x"
            data-sizes="auto"
            alt="/images/garbage-collector-phaes.png" />
    </a><figcaption class="image-caption">垃圾收集的多个阶段</figcaption>
    </figure></p>
<ol>
<li>清理终止阶段
<ol>
<li>暂停程序，所有的处理器在这时会进入安全点(Safe Point)</li>
<li>如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元</li>
</ol>
</li>
<li>标记阶段
<ol>
<li>将状态切换至<code>_GCmark</code>、开启写屏障、用户程序协助(Mutator Assists)并将根对象入队</li>
<li>恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色</li>
<li>开始扫描根对象，包括所有Goroutine的栈、全局对象以及不在堆中的运行时数据结构，扫描Goroutine栈期间会暂停当前处理器</li>
<li>依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色</li>
<li>使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段</li>
</ol>
</li>
<li>标记终止阶段
<ol>
<li>暂停程序、将状态切换至<code>_GCmarktermination</code>并关闭辅助标记的用户程序</li>
<li>清理处理器上的线程缓存</li>
</ol>
</li>
<li>清理阶段
<ol>
<li>将状态切换至<code>_GCoff</code>开始清理阶段，初始化清理状态并关闭写屏障</li>
<li>恢复用户程序，所有新创建的对象会标记成白色</li>
<li>后台并发清理所有的内存管理单元，当Goroutine申请新的内存管理单元时就会触发清理</li>
</ol>
</li>
</ol>
<p>运行时虽然只会使用<code>_GCoff</code>、<code>_GCmark</code>和<code>_GCmarktermination</code>三个状态表示垃圾收集的全部阶段，但是在实现上却复杂很多。本节将按照垃圾收集的不同阶段详细分析其实现原理</p>
<h3 id="全局变量">全局变量</h3>
<p>在垃圾收集中有一些比较重要的全局变量，在分析其过程之前，会逐一介绍这些重要的变量，这些变量在垃圾收集的各个阶段会反复出现，所以理解他们的功能是非常重要的，先介绍一些简单的变量：</p>
<ul>
<li><code>runtime.gcphase</code> 是垃圾收集器当前处于的阶段，可能处于<code>_GCoff</code>、<code>_GCmark</code>和<code>_GCmarktermination</code>，Goroutine在读取或者修改该阶段时需要保证原子性</li>
<li><code>runtime.gcBlackenEnabled</code> 是一个布尔值，当垃圾收集处于标记阶段时，该变量会被置为1，在这里辅助垃圾收集的用户程序和后台标记的任务可以将对象涂黑</li>
<li><code>runtime.gcController</code> 实现了垃圾收集的调步算法，它能够决定出发并行垃圾收集的时间和待处理的工作</li>
<li><code>runtime.gcpercent</code> 是触发垃圾收集的内存增长百分比，默认情况下为100，即堆内存相比上次垃圾收集增长100%时应该触发GC，并行的垃圾收集器会在到达该目标前完成垃圾收集</li>
<li><code>runtime.writerBarrier</code> 是一个包含写屏障状态的结构体，其中的<code>enable</code>字段表示写屏障的开启与关闭</li>
<li><code>runtime.worldsema</code> 是全局的信号量，获取该信号量的线程有权利暂停当前应用程序</li>
</ul>
<p>除了上述全局的变量之外，我们在这里还需要简单了解一下<code>runtime.work</code>变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">work</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">full</span>    <span class="nx">lfstack</span>
    <span class="nx">empty</span>   <span class="nx">lfstack</span>
    <span class="nx">pad0</span>    <span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePad</span>

    <span class="nx">wbufSpans</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">lock</span>    <span class="nx">mutex</span>
        <span class="nx">free</span>    <span class="nx">mSpanList</span>
        <span class="nx">busy</span>    <span class="nx">mSpanList</span>
    <span class="p">}</span>
    <span class="o">...</span>
    <span class="nx">nproc</span>   <span class="kt">uint32</span>
    <span class="nx">tstart</span>  <span class="kt">int64</span>
    <span class="nx">nwait</span>   <span class="kt">uint32</span>
    <span class="nx">ndone</span>   <span class="kt">uint32</span>
    <span class="o">...</span>
    <span class="nx">mode</span>    <span class="nx">gcMode</span>
    <span class="nx">cycles</span>  <span class="kt">uint32</span>
    <span class="o">...</span>
    <span class="nx">stwprocs</span><span class="p">,</span> <span class="nx">maxprocs</span>  <span class="kt">int32</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该结构体中包含大量垃圾收集的相关字段，例如：表示完成的垃圾收集循环的次数、当前循环时间和CPU的利用率、垃圾收集的模式等等，我们会在后面的小节中见到该结构体中的更多字段</p>
<h3 id="触发时机">触发时机</h3>
<p>运行时会通过如下所示的<code>runtime.gcTrigger.test</code>方法决定是否需要触发垃圾收集，当满足触发垃圾收集的基本条件时：允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环，该方法会根据三种不同方式触发进行不同的检查：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="nf">test</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">enablegc</span> <span class="o">||</span> <span class="nx">panicking</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="k">switch</span> <span class="nx">t</span><span class="p">.</span><span class="nx">kind</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">gcTriggerHeap</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span> <span class="o">&gt;=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_trigger</span>
    <span class="k">case</span> <span class="nx">gcTriggerTime</span><span class="p">:</span>
        <span class="k">if</span> <span class="nx">gcpercent</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="nx">last</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">last_gc_nanotime</span><span class="p">))</span>
        <span class="k">return</span> <span class="nx">lastgc</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">now</span><span class="o">-</span><span class="nx">lastgc</span> <span class="p">&gt;</span> <span class="nx">forcegcperiod</span>
    <span class="k">case</span> <span class="nx">gcTriggerCycle</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">n</span><span class="o">-</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li><code>gcTriggerHeap</code> 堆内存的分配达到控制器计算的触发堆大小</li>
<li><code>gcTriggerTime</code> 如果一定时间内没有触发，就会触发新的循环，该触发条件有<code>runtime.forcegcperiod</code>变量控制，默认为2分钟</li>
<li><code>gcTriggerCycle</code> 如果当前没有开启垃圾收集、则触发新的循环</li>
</ol>
<p>用于开启垃圾收集的方法<code>runtime.goStart</code>会接收一个<code>runtime.gcTrigger</code>类型的谓词，所有出现<code>runtime.gcTrigger</code>结构体的位置都是触发垃圾收集的代码</p>
<ul>
<li><code>runtime.sysmon</code>和<code>runtime.forcegchelper</code> 后台运行定时检查和垃圾收集</li>
<li><code>runtime.GC</code> 用户程序手动触发垃圾收集</li>
<li><code>runtime.mallocgc</code> 申请内存时根据堆大小触发垃圾收集</li>
</ul>
<p><figure><a class="lightgallery" href="/images/garbage-collector-trigger.png" title="&amp;ldquo;垃圾收集的触发&amp;rdquo;" data-thumbnail="/images/garbage-collector-trigger.png" data-sub-html="<h2>垃圾收集的触发</h2><p>&amp;ldquo;垃圾收集的触发&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/garbage-collector-trigger.png"
            data-srcset="/images/garbage-collector-trigger.png, /images/garbage-collector-trigger.png 1.5x, /images/garbage-collector-trigger.png 2x"
            data-sizes="auto"
            alt="/images/garbage-collector-trigger.png" />
    </a><figcaption class="image-caption">垃圾收集的触发</figcaption>
    </figure></p>
<p>除了使用后台运行的系统监控器和强制垃圾收集助手触发垃圾收集之外，另外两个办法会从任意处理器上触发垃圾收集，这种不需要中心组件协调的方式是在v1.6版本中引入的，接下来将展开介绍这三种不同的触发时机</p>
<p><strong>后台触发</strong></p>
<p>运行时会在应用程序启动时在后台开启一个用于强制触发垃圾收集的Goroutine，该Goroutine的职责非常简单(调用<code>runtime.gcStart</code>尝试启动新一轮的垃圾收集)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nf">forcegchelper</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">forcegchelper</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">forcegc</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonForceGGIdle</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">gcStart</span><span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span>
            <span class="nx">kind</span><span class="p">:</span>   <span class="nx">gcTriggerTime</span><span class="p">,</span>
            <span class="nx">now</span><span class="p">:</span>    <span class="nf">nanotime</span><span class="p">()</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>为了减少对计算资源的占用，该Goroutine会在循环中调用<code>runtime.goparkunlock</code>主动陷入休眠等待其他Goroutine的唤醒，<code>runtime.forcegchelper</code>在大多数时间都是陷入休眠的，但是它会被系统监控器<code>runtime.sysmon</code>在满足垃圾收集条件时唤醒：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sysmon</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="k">if</span> <span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span>
            <span class="nx">kind</span><span class="p">:</span>   <span class="nx">gcTriggerTime</span><span class="p">,</span>
            <span class="nx">now</span><span class="p">:</span>    <span class="nx">now</span><span class="p">,</span>
        <span class="p">});</span> <span class="nx">t</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
            <span class="nx">forcegc</span><span class="p">.</span><span class="nx">idle</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="kd">var</span> <span class="nx">list</span> <span class="nx">gList</span>
            <span class="nx">list</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">g</span><span class="p">)</span>
            <span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
            <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">forcegc</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>系统监控在每个循环中都会主动构建一个<code>runtime.gcTrigger</code>并检查垃圾收集的触发条件是否满足，如果满足条件，系统监控会将<code>runtime.forcegc</code>状态中持有的Goroutine加入全局队列等待调度器的调度</p>
<p><strong>手动触发</strong></p>
<p>用户程序会通过<code>runtime.GC</code>函数在程序运行期间主动通知运行时执行，该方法在调用时会阻塞调用方直到当前垃圾收集循环完成，在垃圾收集期间也可能会通过STW暂停整个程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GC</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span>
    <span class="nf">gcWaitOnMark</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="nf">gcStart</span><span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span>
        <span class="nx">kind</span><span class="p">:</span>   <span class="nx">gcTriggerCycle</span><span class="p">,</span>
        <span class="nx">n</span><span class="p">:</span>      <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">})</span>
    <span class="nf">gcWaitOnMark</span><span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span> <span class="o">==</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span><span class="o">++</span>
        <span class="nf">Gosched</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span> <span class="o">==</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepers</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">Gosched</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
    <span class="nx">cycle</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">cycle</span> <span class="o">==</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmark</span> <span class="o">&amp;&amp;</span> <span class="nx">cycle</span> <span class="o">==</span> <span class="nx">n</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">mProf_PostSweep</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>在正式开始垃圾收集前，运行时需要通过<code>runtime.gcWaitOnMark</code>等待上一个循环的标记终止、标记和清除终止阶段完成</li>
<li>调用<code>runtime.gcStart</code>触发新一轮的垃圾收集并通过<code>runtime.gcWaitOnMark</code>等待该轮垃圾收集的标记终止阶段正常结束</li>
<li>持续调用<code>runtime.sweepone</code>清理全部待处理的内存管理单元并等待所有的清理工作完成，等待期间会调用<code>runtime.Gosched</code>让出处理器</li>
<li>完成本轮垃圾收集的清理工作后，通过<code>runtime.mProf_PostSweep</code>将该阶段的堆内存状态快照发布出来，我们可以获取这时的内存状态</li>
</ol>
<p>手动触发垃圾收集的过程并不是特别常见，一般只会在运行时的测试代码中才会出现，不过如果我们认为触发主动垃圾收集是有必要的，也可以直接调用该方法，但是作者不认为这是一种推荐的做法</p>
<p><strong>申请内存</strong></p>
<p>最后一个可能会触发垃圾收集的就是<code>runtime.mallocgc</code>，Go运行时会将堆上的对象按大小分成微对象、小对象和大对象三类，这三类对象的创建都可能会触发细心地垃圾收集循环</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="kd">type</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
    <span class="nx">shouldhelpgc</span> <span class="o">:=</span> <span class="kc">false</span>
    <span class="o">...</span>
    <span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxSmallSize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">noscan</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
            <span class="o">...</span>
            <span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">v</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">tinySpanClass</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="o">...</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">...</span>
            <span class="nx">v</span> <span class="o">:=</span> <span class="nf">nextFreeFast</span><span class="p">(</span><span class="nx">span</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">v</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">nextFree</span><span class="p">(</span><span class="nx">spc</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="o">...</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">shouldhelpgc</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="o">...</span>
    <span class="p">}</span>
    <span class="o">...</span>
    <span class="k">if</span> <span class="nx">shouldhelpgc</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">t</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span>
            <span class="nx">kind</span><span class="p">:</span>   <span class="nx">gcTriggerHeap</span>
        <span class="p">});</span> <span class="nx">t</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">gcStart</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>当前线程的内存管理单元中不存在空闲空间时，创建微对象和小对象需要调用<code>runtime.mcache.nextFree</code>从中心缓存或者页堆中获取新的管理单元，在这时就可能触发垃圾收集</li>
<li>当用户程序申请分配32KB以上的大对象时，一定会构建<code>runtime.gcTrigger</code>结构体尝试触发垃圾收集</li>
</ol>
<p>通过堆内存触发垃圾收集需要比较<code>runtime.mstats</code>中的两个字段：表示垃圾收集中存活对象字节数的<code>heap_live</code>和表示触发标记的堆内存大小的<code>gc_trigger</code>；当内存中存活的对象字节数大于触发垃圾收集的堆大小时，新一轮的垃圾收集就会开始。这里将分别介绍这两个值的计算过程：</p>
<ol>
<li><code>heap_live</code>: 为了减少锁竞争，运行时只会在中心缓存分配或者释放内存管理单元以及在堆上分配大对象时才会更新</li>
<li><code>gc_trigger</code>：在标记终止阶段调用<code>runtime.gcSetTriggerRatio</code>更新触发下一次垃圾收集的堆大小</li>
</ol>
<p><code>runtime.gcController</code>会在每个循环结束后计算触发比例并通过<code>runtime.gcSetTriggerRatio</code>设置<code>gc_trigger</code>，它能够决定触发垃圾收集的时间以及用户程序和后台处理的标记任务的多少，利用反馈控制的算法根据堆的增长情况和垃圾收集CPU利用率确定触发垃圾收集的时机</p>
<p>可以在<code>runtime.gcControllerState.endCycle</code>中找到v1.5提出的垃圾收集调步算法，并在<code>runtime.gcControllerState.revise</code>中找到v1.10引入的软硬堆目标分离算法</p>
<h3 id="垃圾收集启动">垃圾收集启动</h3>
<p>垃圾收集在启动过程一定会调用<code>runtime.gcStart</code>，虽然该函数的实现比较复杂，但是它的主要职责是修改全局的垃圾收集状态到<code>_GCmark</code>并做一些准备工作，下面会分几个阶段介绍该函数的实现</p>
<ol>
<li>两次调用<code>runtime.gcTrigger.test</code>检查是否满足垃圾收集条件</li>
<li>暂停程序、在后台启动用于处理标记任务的工作Goroutine、确定所有内存管理单元都被清理以及其他标记阶段开始前的准备工作</li>
<li>进入标记阶段、准备后台的标记工作、根对象的标记工作以及微对象、恢复用户程序，进入并发扫描和标记阶段</li>
</ol>
<p>验证垃圾收集条件的同时，该方法还会在循环中不断调用<code>runtime.sweepone</code>清理已经被标记的内存单元，完成上一个垃圾收集循环的收尾工作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcStart</span><span class="p">(</span><span class="nx">trigger</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">trigger</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span><span class="o">++</span>
    <span class="p">}</span>

    <span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">trigger</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在验证了垃圾收集的条件并完成了收尾工作后，该方法会通过<code>semacquire</code>获取全局的<code>worldsema</code>信号量、调用<code>runtime.gcBgMarkStartWorkers</code>启动后台标记任务、在系统栈中调用<code>runtime.stopTheWorldWithSema</code>暂停程序并调用<code>runtime.finishsweep_m</code>保证上一个内存单元的正常回收：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcStart</span><span class="p">(</span><span class="nx">trigger</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>
    <span class="nf">gcBgMarkStartWorkers</span><span class="p">()</span>
    <span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">maxprocs</span> <span class="p">=</span> <span class="nx">gomaxprocs</span><span class="p">,</span> <span class="nx">gomaxprocs</span>
    <span class="o">...</span>
    
    <span class="nf">systemstack</span><span class="p">(</span><span class="nx">stopTheWorldWithSema</span><span class="p">)</span>
    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">finishsweep_m</span><span class="p">()</span>
    <span class="p">})</span>

    <span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="o">++</span>
    <span class="nx">gcController</span><span class="p">.</span><span class="nf">startCycle</span><span class="p">()</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>除此之外，上述过程还会修改全局变量<code>runtime.work</code>持有的状态，包括垃圾收集需要的Goroutine数量以及已完成的循环数</p>
<p>在完成全部的准备工作后，该方法就进入了执行的最后阶段。在该阶段中，我们会修改全局的垃圾收集状态到<code>_GCmark</code>并依次执行下面的步骤</p>
<ol>
<li>调用<code>runtime.gcBgMarkPrepare</code>初始化后台扫描需要的状态</li>
<li>调用<code>runtime.gcMarkRootPrepare</code>扫描栈上、全局变量等根对象并将它们加入队列</li>
<li>设置全局变量<code>runtime.gcBlackenEnabled</code>，用户程序和标记任务可以将对象涂黑</li>
<li>调用<code>runtime.startTheWorldWithSema</code>启动程序，后台任务也会开始标记堆中的对象</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcStart</span><span class="p">(</span><span class="nx">trigger</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCmark</span><span class="p">)</span>

    <span class="nf">gcBgMarkPrepare</span><span class="p">()</span>
    <span class="nf">gcMarkRootPrepare</span><span class="p">()</span>

    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">now</span> <span class="p">=</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span><span class="p">)</span>
        <span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="o">+=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span>
        <span class="nx">work</span><span class="p">.</span><span class="nx">tMark</span> <span class="p">=</span> <span class="nx">now</span>
    <span class="p">})</span>
    <span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在分析垃圾收集的启动过程中，我们省略了几个关键的过程，其中包括暂停和恢复应用程序和后台任务的启动，下面将详细分析这几个过程的实现原理</p>
<p><strong>暂停与恢复程序</strong></p>
<p><code>runtime.stopTheWorldWithSema</code>和<code>runtime.startTheWorldWithSema</code>是一对用于暂停和恢复程序的核心函数，它们有着完全相反的功能，但是程序的暂停会比恢复要复杂一些，看下前者的实现原理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stopTheWorldWithSema</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="p">=</span> <span class="nx">gomaxprocs</span>
    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nf">preemptall</span><span class="p">()</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span>
		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">_Pgcstop</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">syscalltick</span><span class="o">++</span>
			<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nf">pidleget</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
		<span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
	<span class="p">}</span>
	<span class="nx">wait</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="p">&gt;</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">wait</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nf">notetsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
				<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nf">preemptall</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>暂停程序主要使用了<code>runtime.preemptall</code>，该函数会调用前面介绍的<code>runtime.preemtone</code>，因为程序中活跃的最大处理数为<code>gomaxprocs</code>，所以<code>runtime.stopTheWorldWithSema</code>在每次发现停止的处理器时都会对该变量减一，知道所有的处理器都停止运行。该函数会依次停止当前处理器、等待处于系统调用的处理器以及获取并抢占空闲的处理器，处理器的状态在该函数返回时都会被更新至<code>_Pgcstop</code>，等待垃圾收集器的重新唤醒</p>
<p>程序恢复过程会使用<code>runtime.startTheWorldWithSema</code>，该函数的实现也相对比较简单</p>
<ol>
<li>调用<code>runtime.netpoll</code>从网络轮询器中获取待处理的任务并加入全局队列</li>
<li>调用<code>runtime.procresize</code>扩容或者缩容全局的处理器</li>
<li>调用<code>runtime.notewakeup</code>或者<code>runtime.newm</code>依次唤醒处理器或者为处理器创建新的线程</li>
<li>如果当前待处理的Goroutine数量过多，创建额外的处理器完成任务</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="nx">emitTraceEvent</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
	<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">procs</span> <span class="o">:=</span> <span class="nx">gomaxprocs</span>
	<span class="nx">p1</span> <span class="o">:=</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="o">...</span>
	<span class="k">for</span> <span class="nx">p1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">p1</span>
		<span class="nx">p1</span> <span class="p">=</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">mp</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
			<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">newm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">wakep</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>程序的暂停和启动过程都比较简单，暂停程序会使用<code>runtime.preemptall</code>抢占所有的处理器，恢复程序会使用<code>runtime.notewakeup</code>或者<code>runtime.newm</code>唤醒程序中的处理器</p>
<p><strong>后台标记模式</strong></p>
<p>在垃圾收集启动期间，运行时会调用<code>runtime.gcBgMarkStartWorkers</code>为全局每个处理器创建用于执行后台标记任务的Goroutine，每一个Goroutine都会运行<code>runtime.gcBgMarkWorker</code>，所有运行<code>runtime.gcBgMarkWorker</code>的Goroutine在启动后都会陷入休眠等待调度器的唤醒：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcBgMarkStartWorkers</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">gcBgMarkWorkerCount</span> <span class="p">&lt;</span> <span class="nx">gomaxprocs</span> <span class="p">{</span>
		<span class="k">go</span> <span class="nf">gcBgMarkWorker</span><span class="p">()</span>

		<span class="nf">notetsleepg</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">)</span>

		<span class="nx">gcBgMarkWorkerCount</span><span class="o">++</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这些Goroutine与处理器也是一一对应的关系，当垃圾收集处于标记阶段并且当前处理器不需要做任何任务时，<code>runtime.findrunnable</code>会在当前处理器上执行该Goroutine辅助并发的对象标记</p>
<p><figure><a class="lightgallery" href="/images/p-and-bg-mark-worker.png" title="&amp;ldquo;处理器与后台标记任务&amp;rdquo;" data-thumbnail="/images/p-and-bg-mark-worker.png" data-sub-html="<h2>处理器与后台标记任务</h2><p>&amp;ldquo;处理器与后台标记任务&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/p-and-bg-mark-worker.png"
            data-srcset="/images/p-and-bg-mark-worker.png, /images/p-and-bg-mark-worker.png 1.5x, /images/p-and-bg-mark-worker.png 2x"
            data-sizes="auto"
            alt="/images/p-and-bg-mark-worker.png" />
    </a><figcaption class="image-caption">处理器与后台标记任务</figcaption>
    </figure></p>
<p>调度器在调度循环<code>runtime.schedule</code>中还可以通过垃圾收集控制器的<code>runtime.gcControllerState.findRunnabledGCWorker</code>获取并执行用于后台标记的任务。</p>
<p>用于并发扫描对象的工作协程Goroutine总共有三种不同的模式<code>runtime.gcMarkWorkerMode</code>，这三种模式的Goroutine在标记对象时使用完全不同的策略，垃圾收集控制器会按照需要执行不同类型的工作协程</p>
<ul>
<li><code>gcMarkWorkerDedicateMode</code> 处理器专门负责标记对象，不会被调度器抢占</li>
<li><code>gcMarkWorkerFractionalMode</code> 当垃圾收集的后台CPU使用率达不到预期时(默认为25%)，启动该类型的工作协程帮助垃圾收集达到理由率的目标，因为它只占用同一个CPU的部分资源，所以可以被调度</li>
<li><code>gcMarkWorkerIdleMode</code> 当处理器没有可以执行的Goroutine时，它会运行垃圾收集的标记任务直到被抢占</li>
</ul>
<p><code>runtime.gcControllerState.startCycle</code> 会根据全局处理器的个数以及垃圾收集的CPU利用率计算出上述的<code>dedicatedMarkWorkersNeeded</code>和<code>fractionalUtilizationGoal</code>以决定不同模式的工作协程的数量</p>
<p>因为后台标记任务的CPU利用率为25%，如果主机是四核或者八核，那么垃圾收集需要一个或者两个专门处理相关任务的Goroutine，不过如果主机是三核或者六核，因为无法被四整除，所以这时需要零个或者一个专门处理垃圾收集的Goroutine，运行时需要占用某个CPU的部分时间，使用<code>gcMarkWorkerFractionalMode</code>模式的协程保证CPU的利用率</p>
<p><figure><a class="lightgallery" href="/images/cpu-number-and-gc-mark-worker-mode.png" title="&amp;ldquo;主机核数与垃圾收集任务模式&amp;rdquo;" data-thumbnail="/images/cpu-number-and-gc-mark-worker-mode.png" data-sub-html="<h2>主机核数与垃圾收集任务模式</h2><p>&amp;ldquo;主机核数与垃圾收集任务模式&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/cpu-number-and-gc-mark-worker-mode.png"
            data-srcset="/images/cpu-number-and-gc-mark-worker-mode.png, /images/cpu-number-and-gc-mark-worker-mode.png 1.5x, /images/cpu-number-and-gc-mark-worker-mode.png 2x"
            data-sizes="auto"
            alt="/images/cpu-number-and-gc-mark-worker-mode.png" />
    </a><figcaption class="image-caption">主机核数与垃圾收集任务模式</figcaption>
    </figure></p>
<p>垃圾收集控制器会在<code>runtime.gcControllerState.findRunnabledGCWorker</code> 方法中设置处理器的<code>gcMarkWorkerMode</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">findRunnableGCWorker</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nf">decIfPositive</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerDedicatedMode</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">delta</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">markStartTime</span>
		<span class="k">if</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span><span class="p">)</span><span class="o">/</span><span class="nb">float64</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerFractionalMode</span>
	<span class="p">}</span>

	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述方法的实现比较清晰，控制器通过<code>dedicatedMarkWorkersNeeded</code>决定专门执行标记任务的Goroutine数量并根据执行标记任务的时间和总时间决定是否启动</p>
<p><code>gcMarkWorkerFractionalMode</code>模式的Goroutine；除了这两种控制器要求的工作协程之外，调度器还会在<code>runtime.findrunnable</code>中利用空闲的处理器执行垃圾收集以加速该过程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
<span class="nx">stop</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerIdleMode</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>三种不同模式的工作协程会互相协同保证垃圾收集的CPU利用率达到期望的阈值，在到达目标堆大小前完成标记任务</p>
<h3 id="并发扫描与标记辅助">并发扫描与标记辅助</h3>
<p><code>runtime.gcBgMarkWorker</code>是后台的标记任务执行的函数，该函数的循环中执行了对内存中对象图的扫描和标记，我们分三个部分介绍该函数的实现原理</p>
<ol>
<li>获取当前处理器以及Goroutine打包成<code>runtime.gcBgMarkWorkerNode</code> 类型的结构并主动陷入休眠等待唤醒</li>
<li>根据处理器上的<code>gcMarkWorkerMode</code>模式决定扫描任务的策略</li>
<li>所有标记任务都完成后，调用<code>runtime.gcMarkDone</code>方法完成标记阶段</li>
</ol>
<p>首先我们来看后台标记工作的准备工作，运行时在这里创建了<code>runtime.gcBgMarkWorkerNode</code>，该结构会预先存储处理器和当前Goroutine，当我们调用<code>runtime.gopark</code>触发休眠时，运行时会在系统栈中安全的建立处理器和后台标记任务的绑定关系</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcBgMarkWorker</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;GC worker init&#34;</span>
	<span class="nx">node</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">gcBgMarkWorkerNode</span><span class="p">)</span>
	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>

	<span class="nx">node</span><span class="p">.</span><span class="nx">gp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>

	<span class="nx">node</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>
	<span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">)</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="nf">gopark</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">parkp</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="nx">node</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">gcBgMarkWorkerNode</span><span class="p">)(</span><span class="nx">nodep</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">mp</span> <span class="o">:=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">();</span> <span class="nx">mp</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
			<span class="p">}</span>

			<span class="nx">gcBgMarkWorkerPool</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">node</span><span class="p">.</span><span class="nx">node</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">},</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">node</span><span class="p">),</span> <span class="nx">waitReasonGCWorkerIdle</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过<code>runtime.gopark</code>陷入休眠的Goroutine不会进入运行队列，它只会等待垃圾收集控制器或者调度器的直接唤醒；在唤醒后，我们会根据处理器<code>gcMarkWorkerMode</code>选择不同的标记执行策略，不同的执行策略都会调用<code>runtime.gcDrain</code>扫描工作缓冲区<code>runtime.gcWork</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">node</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>

		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
			<span class="k">switch</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">gcMarkWorkerDedicatedMode</span><span class="p">:</span>
				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
				<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span>
					<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
					<span class="k">for</span> <span class="p">{</span>
						<span class="nx">gp</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
						<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
							<span class="k">break</span>
						<span class="p">}</span>
						<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
					<span class="p">}</span>
					<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">gcMarkWorkerFractionalMode</span><span class="p">:</span>
				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainFractional</span><span class="p">|</span><span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
			<span class="k">case</span> <span class="nx">gcMarkWorkerIdleMode</span><span class="p">:</span>
				<span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainIdle</span><span class="p">|</span><span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
		<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>需要注意的是，<code>gcMarkWorkerDedicatedMode</code>模式的任务是不能被抢占的，为了减少额外开销，第一次调用<code>runtime.gcDrain</code>时是允许抢占的，但是 一旦处理器被抢占，当前Goroutine会将处理器上的所有可运行的Goroutine转移至全局队列中，保证垃圾收集占用的CPU资源</p>
<p>当所有的后台工作任务都陷入等待并且名优剩余工作时，我们就任务该轮垃圾收集的标记阶段结束了，这时我们会调用<code>runtime.gcMarkDone</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">incnwait</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">incnwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">releasem</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
			<span class="nx">node</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>

			<span class="nf">gcMarkDone</span><span class="p">()</span>
		<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>runtime.gcDrain</code>是用于扫描和标记堆内存中对象的核心方法，除了该方法之外，我们还会介绍工作池、写屏障以及辅助标记的实现原理</p>
<p><strong>工作池</strong></p>
<p>在调用<code>runtime.gcDrain</code>时，运行时会传入处理器上的<code>runtime.gcWorker</code>，这个结构体是垃圾收集器中工作池的抽象，它实现了一个生产者和消费者的模型，我们可以以该结构为起点从整体理解标记工作</p>
<p><figure><a class="lightgallery" href="/images/gc-work-pool.png" title="&amp;ldquo;垃圾收集器工作池&amp;rdquo;" data-thumbnail="/images/gc-work-pool.png" data-sub-html="<h2>垃圾收集器工作池</h2><p>&amp;ldquo;垃圾收集器工作池&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/gc-work-pool.png"
            data-srcset="/images/gc-work-pool.png, /images/gc-work-pool.png 1.5x, /images/gc-work-pool.png 2x"
            data-sizes="auto"
            alt="/images/gc-work-pool.png" />
    </a><figcaption class="image-caption">垃圾收集器工作池</figcaption>
    </figure></p>
<p>写屏障、根对象扫描和栈扫描都会向工作池中添加额外的灰色对象等待处理，而对象的扫描过程会将灰色对象标记成黑色，同时也可能发现新的灰色对象，当工作对垒中不包含灰色对象时，整个扫描过程就会结束</p>
<p>为了减少锁竞争，运行时在每个处理器上会保存独立的带扫描工作，然而这回遇到和调度器一样的问题(不同处理器的资源不平均，导致部分处理器无事可做，调度器引入了工作窃取来解决这个问题，垃圾收集器也使用了差不多的机制平衡不同处理器上的待处理任务)</p>
<p><figure><a class="lightgallery" href="/images/global-work-and-local-work.png" title="&amp;ldquo;全局任务与本地任务&amp;rdquo;" data-thumbnail="/images/global-work-and-local-work.png" data-sub-html="<h2>全局任务与本地任务</h2><p>&amp;ldquo;全局任务与本地任务&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/global-work-and-local-work.png"
            data-srcset="/images/global-work-and-local-work.png, /images/global-work-and-local-work.png 1.5x, /images/global-work-and-local-work.png 2x"
            data-sizes="auto"
            alt="/images/global-work-and-local-work.png" />
    </a><figcaption class="image-caption">全局任务与本地任务</figcaption>
    </figure></p>
<p><code>runtime.gcWork</code>为垃圾收集器提供了生产和消费任务的抽象，该结构体持有了两个重要的工作缓冲区<code>wbug1</code>和<code>wbuf2</code>，这两个缓冲区分别是主缓冲区和备缓冲区</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">gcWork</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">wbuf1</span><span class="p">,</span> <span class="nx">wbuf2</span> <span class="o">*</span><span class="nx">workbuf</span>
	<span class="o">...</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">workbufhdr</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">node</span> <span class="nx">lfnode</span> <span class="c1">// must be first
</span><span class="c1"></span>	<span class="nx">nobj</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">workbuf</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">workbufhdr</span>
	<span class="nx">obj</span> <span class="p">[(</span><span class="nx">_WorkbufSize</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">workbufhdr</span><span class="p">{}))</span> <span class="o">/</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">]</span><span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们向该结构体中增加或者删除对象时，它总会先操作主缓冲区，一旦主缓冲区空间不足或者没有对象，会触发主备缓冲区的切换；而当两个缓冲区空间都不足或者都为空时，会从全局的工作缓冲区中插入或者获取对象，该结构体相关方法的实现都非常简单</p>
<p><strong>扫描对象</strong></p>
<p>运行时会使用<code>runtime.gcDrain</code>扫描工作缓冲区中的灰色对象，它会根据传入<code>gcDrainFlags</code>的不同选择不同的策略</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcDrain</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">flags</span> <span class="nx">gcDrainFlags</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
	<span class="nx">preemptible</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainUntilPreempt</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="nx">flushBgCredit</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainFlushBgCredit</span> <span class="o">!=</span> <span class="mi">0</span>
	<span class="nx">idle</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainIdle</span> <span class="o">!=</span> <span class="mi">0</span>

	<span class="nx">initScanWork</span> <span class="o">:=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span>
	<span class="nx">checkWork</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">check</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span>
	<span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">gcDrainIdle</span><span class="p">|</span><span class="nx">gcDrainFractional</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">checkWork</span> <span class="p">=</span> <span class="nx">initScanWork</span> <span class="o">+</span> <span class="nx">drainCheckThreshold</span>
		<span class="k">if</span> <span class="nx">idle</span> <span class="p">{</span>
			<span class="nx">check</span> <span class="p">=</span> <span class="nx">pollWork</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainFractional</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">check</span> <span class="p">=</span> <span class="nx">pollFractionalWorkerExit</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>gcDrainUntilPreemt</code> 当Goroutine的preempt字段被设置成true时返回</li>
<li><code>gcDrainIdle</code> 调用<code>runtime.pollWork</code>，当处理器上包含 其他待执行Goroutine时返回</li>
<li><code>gcDrainFractional</code> 调用<code>runtime.pollFractionalWorkerExit</code>，当CPU的占用率超过<code>fractionalUtilizationGoal</code>的20%时返回</li>
<li><code>gcDrainFlushBgCredit</code> 调用<code>runtime.gcFlushBgCredit</code>计算后台完成的标记任务量以减少并发标记期间的辅助垃圾收集的用户程序的工作量</li>
</ul>
<p>运行时会使用本地变量中的check检查当前是否应该退出标记任务并让出该处理器。当我们做完准备工作后，就可以开始扫描变量中的根对象，这也是标记阶段中需要先被执行的任务</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcDrain</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">flags</span> <span class="nx">gcDrainFlags</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span> <span class="p">&lt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">!(</span><span class="nx">preemptible</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">job</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">job</span> <span class="o">&gt;=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nf">markroot</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">job</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">check</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="nx">done</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>扫描根对象需要使用<code>runtime.markroot</code>，该函数会扫描缓存、数据段、存放全局变量和静态变量的BSS段以及Goroutine的栈内存；一旦完成了根对象的扫描，当前Goroutine会开始从本地和全局工作缓存池中获取待执行的任务</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcDrain</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">flags</span> <span class="nx">gcDrainFlags</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">for</span> <span class="p">!(</span><span class="nx">preemptible</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">full</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nf">balance</span><span class="p">()</span>
		<span class="p">}</span>

		<span class="nx">b</span> <span class="o">:=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGetFast</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">b</span> <span class="p">=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGet</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nf">wbBufFlush</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
				<span class="nx">b</span> <span class="p">=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGet</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nf">scanobject</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">&gt;=</span> <span class="nx">gcCreditSlack</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">flushBgCredit</span> <span class="p">{</span>
				<span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">-</span> <span class="nx">initScanWork</span><span class="p">)</span>
				<span class="nx">initScanWork</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">}</span>
			<span class="nx">checkWork</span> <span class="o">-=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span>
			<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>

			<span class="k">if</span> <span class="nx">checkWork</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">checkWork</span> <span class="o">+=</span> <span class="nx">drainCheckThreshold</span>
				<span class="k">if</span> <span class="nx">check</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>扫描对象会使用<code>runtime.scanobject</code>，该函数会从传入的位置开始扫描，扫描期间会调用<code>runtime.greyobject</code>为找到的活跃对象上色。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcDrain</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">flags</span> <span class="nx">gcDrainFlags</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
<span class="nx">done</span><span class="p">:</span>
	<span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">flushBgCredit</span> <span class="p">{</span>
			<span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">-</span> <span class="nx">initScanWork</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当本轮的扫描因为外部条件变化而中断时，该函数会通过<code>runtime.gcFlushBgCredit</code>记录这次扫描的内存字节数用于减少辅助标记的工作量。</p>
<p>内存中对象的扫描和标记过程涉及很多位操作和指针操作，相关代码实现比较复杂，我们在这里就不展开介绍相关的内容了，感兴趣的读者可以将<code>runtime.gcDrain</code>作为入口研究三色标记的具体过程。</p>
<p><strong>写屏障</strong></p>
<p>写屏障是保证 Go 语言并发标记安全不可或缺的技术，我们需要使用混合写屏障维护对象图的弱三色不变性，然而写屏障的实现需要编译器和运行时的共同协作。在 SSA 中间代码生成阶段，编译器会使用<code>cmd/compile/internal/ssa.writebarrier</code>在<code>Store</code>、<code>Move</code>和<code>Zero</code>操作中加入写屏障，生成如下所示的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
  <span class="nf">gcWriteBarrier</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="o">*</span><span class="nx">ptr</span> <span class="p">=</span> <span class="nx">val</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当 Go 语言进入垃圾收集阶段时，全局变量<code>runtime.writeBarrier</code>中的<code>enabled</code>字段会被置成开启，所有的写操作都会调用 <code>runtime.gcWriteBarrier</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">TEXT runtime·gcWriteBarrier<span class="o">(</span>SB<span class="o">)</span>,NOSPLIT,<span class="nv">$28</span>
	...
	get_tls<span class="o">(</span>BX<span class="o">)</span>
	MOVL	g<span class="o">(</span>BX<span class="o">)</span>, BX
	MOVL	g_m<span class="o">(</span>BX<span class="o">)</span>, BX
	MOVL	m_p<span class="o">(</span>BX<span class="o">)</span>, BX
	MOVL	<span class="o">(</span>p_wbBuf+wbBuf_next<span class="o">)(</span>BX<span class="o">)</span>, CX
	LEAL	8<span class="o">(</span>CX<span class="o">)</span>, CX
	MOVL	CX, <span class="o">(</span>p_wbBuf+wbBuf_next<span class="o">)(</span>BX<span class="o">)</span>
	CMPL	CX, <span class="o">(</span>p_wbBuf+wbBuf_end<span class="o">)(</span>BX<span class="o">)</span>
	MOVL	AX, -8<span class="o">(</span>CX<span class="o">)</span>	// 记录值
	MOVL	<span class="o">(</span>DI<span class="o">)</span>, BX
	MOVL	BX, -4<span class="o">(</span>CX<span class="o">)</span>	// 记录 *slot
	JEQ	flush
ret:
	MOVL	20<span class="o">(</span>SP<span class="o">)</span>, CX
	MOVL	24<span class="o">(</span>SP<span class="o">)</span>, BX
	MOVL	AX, <span class="o">(</span>DI<span class="o">)</span> // 触发写操作
	RET

flush:
  ...
	CALL	runtime·wbBufFlush<span class="o">(</span>SB<span class="o">)</span>
  ...
	JMP	ret
</code></pre></td></tr></table>
</div>
</div><p>在上述汇编函数中，DI 寄存器是写操作的目的地址，AX 寄存器中存储了被覆盖的值，该函数会覆盖原来的值并通过<code>runtime.wbBufFlush</code>通知垃圾收集器将原值和新值加入当前处理器的工作队列，因为该写屏障的实现比较复杂，所以写屏障对程序的性能还是有比较大的影响，之前只需要一条指令完成的工作，现在需要几十条指令。</p>
<p>我们在上面提到过 Dijkstra 和 Yuasa 写屏障组成的混合写屏障在开启后，所有新创建的对象都需要被直接涂成黑色，这里的标记过程是由<code>runtime.gcmarknewobject</code>完成的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
		<span class="nf">gcmarknewobject</span><span class="p">(</span><span class="nx">span</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">scanSize</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">gcmarknewobject</span><span class="p">(</span><span class="nx">span</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">scanSize</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">objIndex</span> <span class="o">:=</span> <span class="nx">span</span><span class="p">.</span><span class="nf">objIndex</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
	<span class="nx">span</span><span class="p">.</span><span class="nf">markBitsForIndex</span><span class="p">(</span><span class="nx">objIndex</span><span class="p">).</span><span class="nf">setMarked</span><span class="p">()</span>

	<span class="nx">arena</span><span class="p">,</span> <span class="nx">pageIdx</span><span class="p">,</span> <span class="nx">pageMask</span> <span class="o">:=</span> <span class="nf">pageIndexOf</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">arena</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">pageMask</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arena</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">],</span> <span class="nx">pageMask</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">gcw</span>
	<span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
	<span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">scanSize</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>runtime.mallocgc</code>会在垃圾收集开始后调用该函数，获取对象对应的内存单元以及标记位<code>runtime.markBits</code>并调用<code>runtime.markBits.setMarked</code>直接将新的对象涂成黑色。</p>
<p><strong>标记辅助</strong></p>
<p>为了保证用户程序分配内存的速度不会超出后台任务的标记速度，运行时还引入了标记辅助技术，它遵循一条非常简单并且朴实的原则，<code>分配多少内存就需要完成多少标记任务</code>。每一个 Goroutine 都持有<code>gcAssistBytes</code>字段，这个字段存储了当前 Goroutine 辅助标记的对象字节数。在并发标记阶段期间，当 Goroutine 调用<code>runtime.mallocgc</code>分配新对象时，该函数会检查申请内存的 Goroutine 是否处于入不敷出的状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="kd">var</span> <span class="nx">assistG</span> <span class="o">*</span><span class="nx">g</span>
	<span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">assistG</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">assistG</span> <span class="p">=</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
		<span class="p">}</span>
		<span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">gcAssistAlloc</span><span class="p">(</span><span class="nx">assistG</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>申请内存时调用的<code>runtime.gcAssistAlloc</code>和扫描内存时调用的<code>runtime.gcFlushBgCredit</code>分别负责借债和还债，通过这套债务管理系统，我们能够保证 Goroutine 在正常运行的同时不会为垃圾收集造成太多的压力，保证在达到堆大小目标时完成标记阶段。</p>
<p><figure><a class="lightgallery" href="/images/gc-mutator-assist.png" title="&amp;ldquo;辅助标记的动态平衡&amp;rdquo;" data-thumbnail="/images/gc-mutator-assist.png" data-sub-html="<h2>辅助标记的动态平衡</h2><p>&amp;ldquo;辅助标记的动态平衡&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/gc-mutator-assist.png"
            data-srcset="/images/gc-mutator-assist.png, /images/gc-mutator-assist.png 1.5x, /images/gc-mutator-assist.png 2x"
            data-sizes="auto"
            alt="/images/gc-mutator-assist.png" />
    </a><figcaption class="image-caption">辅助标记的动态平衡</figcaption>
    </figure></p>
<p>每个 Goroutine 持有的<code>gcAssistBytes</code>表示当前协程辅助标记的字节数，全局垃圾收集控制器持有的<code>bgScanCredit</code>表示后台协程辅助标记的字节数，当本地 Goroutine 分配了较多对象时，可以使用公用的信用<code>bgScanCredit</code>偿还。我们先来分析<code>runtime.gcAssistAlloc</code>的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcAssistAlloc</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
<span class="nx">retry</span><span class="p">:</span>
	<span class="nx">debtBytes</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span>
	<span class="nx">scanWork</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistWorkPerByte</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">debtBytes</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">scanWork</span> <span class="p">&lt;</span> <span class="nx">gcOverAssistWork</span> <span class="p">{</span>
		<span class="nx">scanWork</span> <span class="p">=</span> <span class="nx">gcOverAssistWork</span>
		<span class="nx">debtBytes</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistBytesPerWork</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">scanWork</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="nx">bgScanCredit</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loadint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">)</span>
	<span class="nx">stolen</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">bgScanCredit</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">bgScanCredit</span> <span class="p">&lt;</span> <span class="nx">scanWork</span> <span class="p">{</span>
			<span class="nx">stolen</span> <span class="p">=</span> <span class="nx">bgScanCredit</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistBytesPerWork</span><span class="o">*</span><span class="nb">float64</span><span class="p">(</span><span class="nx">stolen</span><span class="p">))</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">stolen</span> <span class="p">=</span> <span class="nx">scanWork</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">+=</span> <span class="nx">debtBytes</span>
		<span class="p">}</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="o">-</span><span class="nx">stolen</span><span class="p">)</span>
		<span class="nx">scanWork</span> <span class="o">-=</span> <span class="nx">stolen</span>

		<span class="k">if</span> <span class="nx">scanWork</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数会先根据 Goroutine 的<code>gcAssistBytes</code>和垃圾收集控制器的配置计算需要完成的标记任务数量，如果全局信用<code>bgScanCredit</code>中有可用的点数，那么会减去该点数，因为并发执行没有加锁，所以全局信用可能会被更新成负值，然而在长期来看这不是一个比较重要的问题。</p>
<p>如果全局信用不足以覆盖本地的债务，运行时会在系统栈中调用<code>runtime.gcAssistAlloc1</code>执行标记任务，它会直接调用<code>runtime.gcDrainN</code>完成指定数量的标记任务并返回：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcAssistAlloc</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">gcAssistAlloc1</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">scanWork</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="o">...</span>
	<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span>
			<span class="nf">Gosched</span><span class="p">()</span>
			<span class="k">goto</span> <span class="nx">retry</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">!</span><span class="nf">gcParkAssist</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="nx">retry</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果在完成标记辅助任务后，当前 Goroutine 仍然入不敷出并且 Goroutine 没有被抢占，那么运行时会执行<code>runtime.gcParkAssist</code>；如果全局信用仍然不足，运行时会通过 runtime.gcParkAssist 将当前 Goroutine 陷入休眠、加入全局的辅助标记队列并等待后台标记任务的唤醒。</p>
<p>用于还债的 runtime.gcFlushBgCredit 的实现比较简单，如果辅助队列中不存在等待的 Goroutine，那么当前的信用会直接加到全局信用 bgScanCredit 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">scanWork</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="nx">scanWork</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">scanBytes</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">scanWork</span><span class="p">)</span> <span class="o">*</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistBytesPerWork</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">!</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">scanBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">scanBytes</span><span class="o">+</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">scanBytes</span> <span class="o">+=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">+=</span> <span class="nx">scanBytes</span>
			<span class="nx">scanBytes</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">pushBack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">scanBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">scanWork</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">scanBytes</span><span class="p">)</span> <span class="o">*</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistWorkPerByte</span><span class="p">)</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="nx">scanWork</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果辅助队列不为空，上述函数会根据每个 Goroutine 的债务数量和已完成的工作决定是否唤醒这些陷入休眠的 Goroutine；如果唤醒所有的 Goroutine 后，标记任务量仍然有剩余，这些标记任务都会加入全局信用中。</p>
<p><figure><a class="lightgallery" href="/images/global-credit-and-assist-bytes.png" title="&amp;ldquo;全局信用与本地信用&amp;rdquo;" data-thumbnail="/images/global-credit-and-assist-bytes.png" data-sub-html="<h2>全局信用与本地信用</h2><p>&amp;ldquo;全局信用与本地信用&amp;rdquo;</p>">
        <img
            class="lazyload"
            src="/svg/loading.min.svg"
            data-src="/images/global-credit-and-assist-bytes.png"
            data-srcset="/images/global-credit-and-assist-bytes.png, /images/global-credit-and-assist-bytes.png 1.5x, /images/global-credit-and-assist-bytes.png 2x"
            data-sizes="auto"
            alt="/images/global-credit-and-assist-bytes.png" />
    </a><figcaption class="image-caption">全局信用与本地信用</figcaption>
    </figure></p>
<p>用户程序辅助标记的核心目的是避免用户程序分配内存影响垃圾收集器完成标记工作的期望时间，它通过维护账户体系保证用户程序不会对垃圾收集造成过多的负担，一旦用户程序分配了大量的内存，该用户程序就会通过辅助标记的方式平衡账本，这个过程会在最后达到相对平衡，保证标记任务在到达期望堆大小时完成。</p>
<h3 id="标记终止">标记终止</h3>
<p>当所有处理器的本地任务都完成并且不存在剩余的工作 Goroutine 时，后台并发任务或者辅助标记的用户程序会调用<code>runtime.gcMarkDone</code>通知垃圾收集器。当所有可达对象都被标记后，该函数会将垃圾收集的状态切换至<code>_GCmarktermination</code>；如果本地队列中仍然存在待处理的任务，当前方法会将所有的任务加入全局队列并等待其他 Goroutine 完成处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkDone</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>
<span class="nx">top</span><span class="p">:</span>
	<span class="k">if</span> <span class="p">!(</span><span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmark</span> <span class="o">&amp;&amp;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">gcMarkDoneFlushed</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
		<span class="nf">forEachP</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">dispose</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span> <span class="p">{</span>
				<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcMarkDoneFlushed</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="p">}</span>
		<span class="p">})</span>
		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">gcMarkDoneFlushed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="nx">top</span>
	<span class="p">}</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果运行时中不包含全局任务、处理器中也不存在本地任务，那么当前垃圾收集循环中的灰色对象也都标记成了黑色，我们就可以开始触发垃圾收集的阶段迁移了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkDone</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;gcing&#34;</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">stopTheWorldWithSema</span><span class="p">)</span>

	<span class="o">...</span>

	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nf">gcWakeAllAssists</span><span class="p">()</span>
	<span class="nf">schedEnableUser</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
	<span class="nx">nextTriggerRatio</span> <span class="o">:=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">endCycle</span><span class="p">()</span>
	<span class="nf">gcMarkTermination</span><span class="p">(</span><span class="nx">nextTriggerRatio</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述函数在最后会关闭混合写屏障、唤醒所有协助垃圾收集的用户程序、恢复用户 Goroutine 的调度并调用<code>runtime.gcMarkTermination</code>进入标记终止阶段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkTermination</span><span class="p">(</span><span class="nx">nextTriggerRatio</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCmarktermination</span><span class="p">)</span>

	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>

	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">gcMark</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCoff</span><span class="p">)</span>
		<span class="nf">gcSweep</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">mode</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
	<span class="nf">gcSetTriggerRatio</span><span class="p">(</span><span class="nx">nextTriggerRatio</span><span class="p">)</span>
	<span class="nf">wakeScavenger</span><span class="p">()</span>

	<span class="o">...</span>

	<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">list</span><span class="p">)</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">})</span>
	<span class="nf">prepareFreeWorkbufs</span><span class="p">()</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="nx">freeStackSpans</span><span class="p">)</span>
	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">forEachP</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
		<span class="p">})</span>
	<span class="p">})</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们省略了该函数中很多数据统计的代码，包括正在使用的内存大小、本轮垃圾收集的暂停时间、CPU 的利用率等数据，这些数据能够帮助控制器决定下一轮触发垃圾收集的堆大小，除了数据统计之外，该函数还会调用<code>runtime.gcSweep</code>重置清理阶段的相关状态并在需要时阻塞清理所有的内存管理单元；<code>_GCmarktermination</code>状态在垃圾收集中并不会持续太久，它会迅速转换至<code>_GCoff</code>并恢复应用程序，到这里垃圾收集的全过程基本上就结束了，用户程序在申请内存时才会惰性回收内存。</p>
<h3 id="内存清理">内存清理</h3>
<p>垃圾收集的清理中包含对象回收器（Reclaimer）和内存单元回收器，这两种回收器使用不同的算法清理堆内存：</p>
<ul>
<li>对象回收器在内存管理单元中查找并释放未被标记的对象，但是如果<code>runtime.mspan</code>中的所有对象都没有被标记，整个单元就会被直接回收，该过程会被<code>runtime.mcentral.cacheSpan</code>或者<code>runtime.sweepone</code>异步触发；</li>
<li>内存单元回收器会在内存中查找所有的对象都未被标记的<code>runtime.mspan</code>，该过程会被<code>runtime.mheap.reclaim</code>触发；</li>
</ul>
<p><code>runtime.sweepone</code>是我们在垃圾收集过程中经常会见到的函数，它会在堆内存中查找待清理的内存管理单元：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
	<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">nextSpanForSweep</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">state</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">get</span><span class="p">();</span> <span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanInUse</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">npages</span> <span class="o">:=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">npages</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span>
		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimCredit</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">npages</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="k">return</span> <span class="nx">npages</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>查找内存管理单元时会通过<code>state</code>和<code>sweepgen</code>两个字段判断当前单元是否需要处理。如果内存单元的<code>sweepgen</code>等于<code>mheap.sweepgen - 2</code>那么意味着当前单元需要清理，如果等于<code>mheap.sweepgen - 1，</code>那么当前管理单元就正在清理。</p>
<p>所有的回收工作最终都是靠<code>runtime.mspan.sweep</code>完成的，它会根据并发标记阶段回收内存单元中的垃圾并清除标记以免影响下一轮垃圾收集。</p>
<h2 id="小结">小结</h2>
<p>Go 语言垃圾收集器的实现非常复杂，作者认为这是编程语言中最复杂的模块，调度器的复杂度与垃圾收集器完全不是一个级别，我们在分析垃圾收集器的过程中不得不省略很多的实现细节，其中包括并发标记对象的过程、清扫垃圾的具体实现，这些过程设计大量底层的位操作和指针操作，本节中包含所有的相关代码的链接，感兴趣的读者可以自行探索。</p>
<p>垃圾收集是一门非常古老的技术，它的执行速度和利用率很大程度上决定了程序的运行速度，Go 语言为了实现高性能的并发垃圾收集器，使用三色抽象、并发增量回收、混合写屏障、调步算法以及用户程序协助等机制将垃圾收集的暂停时间优化至毫秒级以下，从早期的版本看到今天，我们能体会到其中的工程设计和演进，作者觉得研究垃圾收集的是实现原理还是非常值得的。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-11-09</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/go-garbage-collector/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="http://example.org/go-garbage-collector/" data-title="Go垃圾收集器" data-via="xxxx" data-hashtags="mysql"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="http://example.org/go-garbage-collector/" data-hashtag="mysql"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="http://example.org/go-garbage-collector/" data-title="Go垃圾收集器" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="http://example.org/go-garbage-collector/" data-title="Go垃圾收集器"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="http://example.org/go-garbage-collector/" data-title="Go垃圾收集器"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Myspace" data-sharer="myspace" data-url="http://example.org/go-garbage-collector/" data-title="Go垃圾收集器" data-description="Go垃圾收集器"><i data-svg-src="/lib/simple-icons/icons/myspace.min.svg"></i></a><a href="javascript:void(0);" title="分享到 Blogger" data-sharer="blogger" data-url="http://example.org/go-garbage-collector/" data-title="Go垃圾收集器" data-description="Go垃圾收集器"><i class="fab fa-blogger fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="http://example.org/go-garbage-collector/" data-title="Go垃圾收集器"><i class="fab fa-evernote fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/mysql/">mysql</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/go-docker/" class="prev" rel="prev" title="Go Docker"><i class="fas fa-angle-left fa-fw"></i>Go Docker</a>
            <a href="/go-array/" class="next" rel="next" title="Go语言数组实现原理">Go语言数组实现原理<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">CC</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript" src="/lib/cookieconsent/cookieconsent.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
