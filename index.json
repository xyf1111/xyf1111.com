[{"categories":["实例"],"content":"Go Instance 01-豆瓣爬虫","date":"2021-02-19","objectID":"/go-instance-01/","tags":["golang"],"title":"Go Instance 01","uri":"/go-instance-01/"},{"categories":["实例"],"content":"使用Go爬取豆瓣电影排行榜 package main import ( \"encoding/json\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"regexp\" \"strings\" ) func main() { data, err := GetHtml(\"https://movie.douban.com/chart\") if err != nil { fmt.Println(\"获取源代码失败:\", err) return } //创建文件 file, err := os.Create(\"movie.json\") if err != nil { fmt.Println(\"创建文件失败:\", err) return } encoder := json.NewEncoder(file) encoder.SetIndent(\" \", \" \") encoder.Encode(GetItem(data)) } func GetHtml(url string) ([]byte, error) { var clent http.Client req, err := http.NewRequest(\"GET\", url, nil) if err != nil { fmt.Println(\"创建请求失败:\", err) return nil, err } //添加请求头，才能访问到需要的网页源码 req.Header.Add(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36 Edg/85.0.564.51\") resp, err := clent.Do(req) if err != nil { fmt.Println(\"请求失败:\", err) return nil, err } data, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(\"读取失败:\", err) return nil, err } defer resp.Body.Close() return data, nil } type Item struct { Link string `json:\"link\"` Name string `json:\"name\"` Info string `json:\"info\"` Rate string `json:\"rate\"` RateNum string `json:\"rate_num\"` } func GetItem(data []byte) []Item { //正则匹配需要的内容 pattern := regexp.MustCompile(`(?s)\u003cdiv.*?class=\"pl2\".*?\u003e.*?\u003ca href=\"(.*?)\".*?\u003e(.*?)/.*?\u003cspan.*?\u003c/span\u003e.*?\u003cp class=\"pl\"\u003e(.*?)\u003c/p\u003e.*?\u003cdiv.*?\u003e.*?\u003cspan class=\"rating_nums\"\u003e(.*?)\u003c/span\u003e.*?\u003cspan class=\"pl\"\u003e\\((.*?)\\)\u003c/span\u003e.*?\u003c/div\u003e`) //查找网页中所有的匹配项 items := pattern.FindAllSubmatch(data, -1) var res []Item for _, item := range items { res = append(res, Item{ Link: string(item[1]), Name: strings.TrimSpace(string(item[2])), Info: string(item[3]), Rate: string(item[4]), RateNum: string(item[5]), }) } return res } ","date":"2021-02-19","objectID":"/go-instance-01/:1:0","tags":["golang"],"title":"Go Instance 01","uri":"/go-instance-01/"},{"categories":["学习"],"content":"Go Study 12-资源管理与出错处理","date":"2021-02-18","objectID":"/go-study-12/","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"defer调用 确保调用在函数结束时发生 多defer相当于栈(先进后出) 参数在defer语句时计算 ","date":"2021-02-18","objectID":"/go-study-12/:1:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"何时使用defer调用 Open/Close Lock/Unlock PrintHeader/PrintFooter ","date":"2021-02-18","objectID":"/go-study-12/:2:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"错误处理二 如何实现统一的错误处理逻辑 ","date":"2021-02-18","objectID":"/go-study-12/:3:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"panic 停止当前函数运行 一直向上返回，执行每一层的defer 如果没有遇见recover，程序退出 ","date":"2021-02-18","objectID":"/go-study-12/:4:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"recover 仅在defer调用中使用 获取panic的值 如果无法处理，可重新panic ","date":"2021-02-18","objectID":"/go-study-12/:5:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"error vs panic 意料之中的：使用error。如：文件打不开 意料之外的：使用panic。如：数组越界 ","date":"2021-02-18","objectID":"/go-study-12/:6:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"错误处理综合实例 defer + panic + recover Type Assertion 函数式编程的应用 ","date":"2021-02-18","objectID":"/go-study-12/:7:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-18","objectID":"/go-study-12/:8:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"错误处理 Go语言使用一个独立的明确的返回值来传递错误信息。这与使用异常的Java和Ruby以及在C语言中常见到的超重的单返回值/错误值相比，Go语言的处理方式能清楚知道那个函数返回了错误，并能像调用那些没有出错函数一样调用 package main import ( \"errors\" \"fmt\" ) //按照惯例，错误通常是最后一个返回值并且是error类型，一个内建的接口 func f1(arg int) (int, error) { if arg == 42 { //error.New 构造一个使用给定错误信息的基本error值 return -1, errors.New(\"can't work with 42\") } //返回错误值为nil，代表没有错误 return arg+3, nil } //通过实现Error方法来自定义error是可以的 //这里使用自定义错误类型来表示上面的参数错误 type argError struct { arg int prob string } func (e *argError) Error() string { return fmt.Sprintf(\"%d-%s\", e.arg, e.prob) } func f2(arg int) (int, error) { if arg == 42 { //这个例子中，使用\u0026argError语法来建立一个新的结构体 //提供arg和prob两个字段的值 return -1, \u0026argError{arg, \"can't work with it\"} } return arg+3, nil } func main() { //下面两个循环测试了各个返回错误的函数 //注意在if行内的错误检查代码，在Go中是一个普遍的用法 for _, i := range []int{7, 42}{ if r, e := f1(i); e != nil { fmt.Println(\"f1 failed: \", e) } else { fmt.Println(\"f1 worked: \", r) } } for _, i := range []int{7, 42} { if r, e := f2(i); e != nil { fmt.Println(\"f2 failed: \", e) } else { fmt.Println(\"f2 worked: \", r) } } //如果想在程序中使用一个自定义错误类型中的数据 //需要通过类型断言来得到这个错误类型的实例 _, e := f2(42) if ae, ok := e.(*argError); ok { fmt.Println(ae.arg) fmt.Println(ae.prob) } } ","date":"2021-02-18","objectID":"/go-study-12/:8:1","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"Go Study 11-函数与闭包","date":"2021-02-18","objectID":"/go-study-11/","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"函数与闭包 ","date":"2021-02-18","objectID":"/go-study-11/:1:0","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"函数式编程 vs 函数指针 函数式一等公民：参数，变量，返回值都可以是函数 高阶函数 函数 -\u003e 闭包 ","date":"2021-02-18","objectID":"/go-study-11/:1:1","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"“正统”函数式编程 不可变性：不能有状态，只有常量和函数 函数只能有一个参数 ","date":"2021-02-18","objectID":"/go-study-11/:1:2","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"go 语言闭包的应用 更为自然，不需要修饰如何访问自由变量 没有Lambda表达式，但是有匿名函数 闭包与函数\u0026ldquo;闭包与函数\u0026rdquo; \"\r闭包与函数\r ","date":"2021-02-18","objectID":"/go-study-11/:1:3","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-18","objectID":"/go-study-11/:2:0","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"基本函数 函数是Go的中心 package main import \"fmt\" //这里是一个函数，接受两个int，并以int返回它们的和 func plus(a, b int) int { //Go需要明确的返回值 return a+b } func main() { //通过name(args)来调用一个函数 result := plus(1, 2) fmt.Println(result) } ","date":"2021-02-18","objectID":"/go-study-11/:2:1","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"多返回值函数 Go内建多返回值支持。这个特性在Go语言中经常被用到，例如用来同时返回一个函数的结果和错误信息 package main import \"fmt\" //(int, int)在这个函数中标志着这个函数返回2个int func vals() (int, int) { return 3, 7 } func main() { //通过多赋值操作来使用两个不同的返回值 a, b := vals() fmt.Println(a) fmt.Println(b) //如果想返回一部分值，可以使用空白定义符_ _, c := vals() fmt.Println(c) } ","date":"2021-02-18","objectID":"/go-study-11/:2:2","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"可变参数函数 可变参数函数。可以用任意数量的参数调用。例如，fmt.Println是一个常见的变参函数 package main import \"fmt\" //这个函数使用任意数目的int作为参数 func sum(nums ...int) { fmt.Print(nums, \" \") total := 0 for _, num := range nums { total += num } fmt.Println(total) } func main() { //变参函数使用常规的调用方法，除了参数比较特殊 sum(1, 2) sum(1, 2, 3) //如果slice已经有多个值，想作为变参使用，可以这样调用func(slice...) nums := []int{1, 2, 3, 4, 5} sum(nums...) } ","date":"2021-02-18","objectID":"/go-study-11/:2:3","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"闭包 Go支持通过闭包来使用匿名函数。匿名函数在你想定义一个不需要命名的内联函数时很实用 package main import \"fmt\" //这个intSeq函数返回另一个在intSeq函数体内定义的匿名函数 //这个函数的返回使用闭包的方式 隐藏 变量 i func intSeq() func() int { i := 0 return func() int { i += 1 return i } } func main() { //调用nextInt函数，将返回值(也是一个函数)赋给nextInt //这个函数的值包含了自己的值i，在每次调用nextInt都会更新i nextInt := intSeq() //多次调用闭包，查看效果 fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) //更换函数，确定每个函数的i是独立的 nextInts := intSeq() fmt.Println(nextInts()) } ","date":"2021-02-18","objectID":"/go-study-11/:2:4","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"递归函数 Go支持递归，这是一个经典的阶乘案例 package main import \"fmt\" //fact函数在到达fact(0)前一直在调用自身 func fact(n int) int { if n == 0 { return 1 } return n * fact(n-1) } func main() { fmt.Println(fact(5)) } ","date":"2021-02-18","objectID":"/go-study-11/:2:5","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"Go Study 10-接口","date":"2021-02-17","objectID":"/go-study-10/","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"接口 接口由使用者定义 ","date":"2021-02-17","objectID":"/go-study-10/:1:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"duck typing “像鸭子走路，像鸭子叫(长得像鸭子)，那么就是鸭子” 描述事物的外部行为而非内部结构 严格来说go属于结构化类型系统，类似duck typing ","date":"2021-02-17","objectID":"/go-study-10/:2:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"接口变量里有什么 接口变量1\u0026ldquo;接口变量1\u0026rdquo; \"\r接口变量1\r 接口变量2\u0026ldquo;接口变量2\u0026rdquo; \"\r接口变量2\r 接口变量自带指针 接口变量同样采用值传递，几乎不需要使用接口的指针 指针接收者实现只能以指针方式使用；值接收者都可以 ","date":"2021-02-17","objectID":"/go-study-10/:3:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"查看接口变量 表示任何变量：interface{} Type Assertion Type Switch ","date":"2021-02-17","objectID":"/go-study-10/:4:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"特殊接口 Stringer Reader/Writer ","date":"2021-02-17","objectID":"/go-study-10/:5:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-17","objectID":"/go-study-10/:6:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"接口 接口：Go语言中组织和命名相关的方法集合的机制。接口是方法特征的命名集合 package main import ( \"fmt\" \"math\" ) //这里是一个几何体的基本接口 type geometry interface { area() float64 perim() float64 } //这个例子中，将让rect和circle实现这个接口 type rect struct { width float64 height float64 } type circle struct { radius float64 } //在Go中实现接口，需要实现这个接口的所有方法 //rect实现接口 func (r rect) area() float64 { return r.width * r.height } func (r rect) perim() float64 { return 2*r.width + 2*r.height } //circle实现接口 func (c circle) area() float64 { return math.Pi * c.radius * c.radius } func (c circle) perim() float64 { return math.Pi * c.radius * 2 } //如果有一个变量是接口类型，可以调用这个被命名接口的方法 //这里有一个通用的measure函数，利用特性，可以用在任何geometry(几何学)上 func measure(g geometry) { fmt.Println(g) fmt.Println(g.area()) fmt.Println(g.perim()) } func main() { r := rect{width: 3, height: 4} c := circle{radius: 5} //结构体类型circle和rect都实现了geometry接口 //所以可以使用他们的实例作为measure的参数 measure(r) measure(c) } ","date":"2021-02-17","objectID":"/go-study-10/:6:1","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"Go Study 09-GOPATH","date":"2021-02-17","objectID":"/go-study-09/","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"GOPATH环境变量 默认在~/go(unix，linux)，%USERPOFILE%\\go(windows) 官方推荐：所有项目和第三方库都放在同一个GOPATH下 也可以将每个项目放在不同的GOPATH ","date":"2021-02-17","objectID":"/go-study-09/:1:0","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"go get 获取第三方库 go get + 包(github可以，golang不行) 使用gopm来获取无法下载的包 go get -v github.com/gpmgo/gopm ","date":"2021-02-17","objectID":"/go-study-09/:2:0","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"GOPATH下目录结构 go build来编译 go install 产生pkg文件和可执行文件 go run 直接编译运行 ","date":"2021-02-17","objectID":"/go-study-09/:3:0","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"GOPATH下目录结构 src git repository 1 git repository 2 pkg git repository 1 git repository 2 bin 执行文件1,2,3… ","date":"2021-02-17","objectID":"/go-study-09/:4:0","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"Go Study 08-封装","date":"2021-02-16","objectID":"/go-study-08/","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"封装 名字一般使用CamelCase 首字母大写：public 首字母小写：private ","date":"2021-02-16","objectID":"/go-study-08/:1:0","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"包 每个目录一个包 main包包含可执行入口 为结构定义的方法必须放在同一个包内 可以是不同文件 ","date":"2021-02-16","objectID":"/go-study-08/:2:0","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"如何扩充系统类型或者别人的类型 定义别名 使用组合 ","date":"2021-02-16","objectID":"/go-study-08/:2:1","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"Go Study 07-面向对象，struct","date":"2021-02-16","objectID":"/go-study-07/","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"面向对象 go语言仅支持封装，不支持继承和多态 go语言没有class，只有struct ","date":"2021-02-16","objectID":"/go-study-07/:1:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"结构的创建 type treeNode struct { value int left, right *treeNode } //自定义工厂函数 func createNode(value int) *treeNode { //返回局部变量地址 return \u0026treeNode{value: value} } func main() { var root treeNode fmt.Println(root) root = treeNode{value: 3} root.left = \u0026treeNode{} root.right = \u0026treeNode{5, nil, nil} root.right.left = new(treeNode) root.left.right = createNode(2) } 不论地址还是结构本身，一律使用.来访问成员 使用自定义工厂函数(createNode) 注意返回了局部变量的地址 ","date":"2021-02-16","objectID":"/go-study-07/:2:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"为结构定义方法 func (node treeNode) print() { fmt.Println(node.value) } 显示定义和命名方法接受者 ","date":"2021-02-16","objectID":"/go-study-07/:3:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"使用指针作为方法接受者 func (node *treeNode) setValue(value int) { node.value = value } 只有使用指针才可以改变结构内容 nil指针也可以调用方法 ","date":"2021-02-16","objectID":"/go-study-07/:4:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"值接受者 vs 指针接受者 要改变内容必须使用指针接收者 结构过大也考虑使用指针接收者(因为值接收者使用时会拷贝一份，结构过大拷贝代价也大) 一致性：如有指针接收者，最好都使用指针接收者 很简单的不可变对象使用值接收者可以减轻GC负担(太多的指针会增加垃圾服务器GC的负担) 值接收者是go语言特有 值/指针接收者均可接收值/指针 ","date":"2021-02-16","objectID":"/go-study-07/:5:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-16","objectID":"/go-study-07/:6:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"结构体 Go的结构体是各个字段 字段类型的集合 package main import \"fmt\" type person struct { name string age int } func main() { //使用这个语法创建一个新的结构体函数 fmt.Println(person{\"Bob\", 20}) //可以在初始化一个结构体元素时指定字段名 fmt.Println(person{name:\"Alice\", age:18}) //省略的字段将被初始化为零值 fmt.Println(person{name:\"Fred\"}) //\u0026前缀生成一个结构体指针 fmt.Println(\u0026person{name:\"Ann\", age:40}) //使用点来访问结构体字段 s := person{name:\"Sean\", age:50} fmt.Println(s.name) fmt.Println(s.age) //也可以对结构体指针引用，指针会被自动解引用 sp := \u0026s fmt.Println(sp.age) //结构体是可变的 sp.age = 51 fmt.Println(s.age) s.age = 52 fmt.Println(s.age) } ","date":"2021-02-16","objectID":"/go-study-07/:6:1","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"方法 Go支持在结构体类型中定义方法 package main import \"fmt\" type rect struct { wight int height int } //area方法有一个接收器类型rect来计算矩形面积 func (r rect) area() int { return r.height * r.wight } //可以为值或指针类型的接收器定义方法，这是个值类型接收器 //计算矩形周长 func (r rect) perim() int { return 2*r.wight + 2*r.height } //指针类型接收器可以改变实际值 func (r *rect) changeH(val int) { r.height = val } //值类型接收器改变拷贝值 func (r rect) changeW(val int) { r.wight = val } func main() { r := rect{10, 5} //调用上面为结构体定义的方法 fmt.Println(r.area()) fmt.Println(r.perim()) r.changeH(20) r.changeW(15) fmt.Println(r) //Go自动处理方法调用时值和指针之间的转换 //可以使用指针来调用方法避免在方法调用时产生一个拷贝或让方法能够改变接收的数据 rp := \u0026r rp.changeH(25) rp.changeW(30) fmt.Println(rp.area()) fmt.Println(rp.perim()) } ","date":"2021-02-16","objectID":"/go-study-07/:6:2","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"值和指针 Go支持指针，允许在程序中通过引用传递值或数据结构 package main import \"fmt\" //通过两个不同的函数来比较值和指针类型的不同 //zeroVal有一个int型参数，所以使用值传递 //zeroVal将从调用它的函数中获得一个ival形参的拷贝 func zeroVal(ival int) { ival = 0 } //zeroPtr和上面不同是*int，意味着它使用的是指针 //函数体内的*iptr接着解引用这个指针，从它内存地址得到这个地址当前值 //对一个解引用指针进行赋值会改变这个指针引用的真实地址的值 func zeroPtr(iptr *int) { *iptr = 0 } func main() { i := 1 fmt.Println(\"initial: \", i) zeroVal(i) fmt.Println(\"zeroVal: \", i) //通过\u0026i语法来获取i的内存地址 zeroPtr(\u0026i) //指针也是可以被打印的 fmt.Println(\"zeroPtr: \", i) fmt.Println(\"point: \", \u0026i) } ","date":"2021-02-16","objectID":"/go-study-07/:6:3","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"Go Study 06-rune字符串","date":"2021-02-16","objectID":"/go-study-06/","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"rune相当于go的char ","date":"2021-02-16","objectID":"/go-study-06/:1:0","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用range遍历pos，rune对 s := \"Yes我是你爸爸!\" for _, b := range []byte(s) { fmt.Printf(\"%X \", b) } fmt.Println() for i, ch := range s { fmt.Printf(\"(%d %X) \", i, ch) } ","date":"2021-02-16","objectID":"/go-study-06/:1:1","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用utf8.RuneCountInString获得字符数量 fmt.Println(\"Rune count:\", utf8.RuneCountInString(s)) ","date":"2021-02-16","objectID":"/go-study-06/:1:2","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用len获得字节长度 fmt.Println(len(s)) ","date":"2021-02-16","objectID":"/go-study-06/:1:3","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用[]byte获得字节 bytes := []byte(s) for len(bytes) \u003e 0 { ch, size := utf8.DecodeRune(bytes) bytes = bytes[size:] fmt.Printf(\"%c \", ch) } ","date":"2021-02-16","objectID":"/go-study-06/:1:4","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"其他字符串操作 ","date":"2021-02-16","objectID":"/go-study-06/:2:0","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Fields，Split，Join ","date":"2021-02-16","objectID":"/go-study-06/:2:1","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Contains，Index ","date":"2021-02-16","objectID":"/go-study-06/:2:2","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"ToLower，ToUpper ","date":"2021-02-16","objectID":"/go-study-06/:2:3","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Trim，TrimRight，TrimLeft","date":"2021-02-16","objectID":"/go-study-06/:2:4","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Go Study 05-leetcode例题","date":"2021-02-16","objectID":"/go-study-05/","tags":["golang"],"title":"Go Study 05","uri":"/go-study-05/"},{"categories":["学习"],"content":"寻找最长不含有重复字符的子串 abcabcbb -\u003e abc bbbbb -\u003e b pwwkew -\u003ewke func lenthofNonRepeatingSubStr(s string) int { lastOccurred := make(map[rune]int) start := 0 maxLength := 0 for i, ch := range []rune (s){ if lastI, ok := lastOccurred[ch]; ok \u0026\u0026 lastI \u003e= start { fmt.Println(lastI) fmt.Println(ok) start = lastI + 1 } if i-start+1 \u003e maxLength { maxLength = i-start+1 } lastOccurred[ch] = i } return maxLength } ","date":"2021-02-16","objectID":"/go-study-05/:1:0","tags":["golang"],"title":"Go Study 05","uri":"/go-study-05/"},{"categories":["学习"],"content":"Go Study 04-数组、切片和容器","date":"2021-02-15","objectID":"/go-study-04/","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组 var arr1 [5]int arr2 := [3]int{1,3,5} arr3 := [...]int{2,4,6,8,10} var grid [4][5]int 数量写在类型前 ","date":"2021-02-15","objectID":"/go-study-04/:1:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组的遍历 长度遍历 for i := 0; i \u003c len(arr3); i++ { fmt.Println(arr3[i]) } range只取index for i := range arr3 { fmt.Println(arr3[i]) } range取index和value maxi := -1 maxnum := -1 for i, v := range arr3{ if v \u003e maxnum { maxi = i maxnum = v } } fmt.Println(maxi, maxnum) range只取value sum := 0 for _, v := range arr3 { sum += v } 可以通过_省略变量 不仅range，任何地方都可以通过_省略变量 如果只要i，可写成 for i := range numbers ","date":"2021-02-15","objectID":"/go-study-04/:2:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"为什么要用range 意义明确，美观 ","date":"2021-02-15","objectID":"/go-study-04/:3:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组是值类型 [10]int 和[20]int 是不同类型 调用func f(arr [10]int) 会拷贝数组 在go语言中一般不直接使用数组 ","date":"2021-02-15","objectID":"/go-study-04/:4:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Slice(切片) arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s := arr[2:6] s的值为[2 3 4 5] arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s := arr[2:6] s[0] = 10 Slice 本身没有数据，是对底层array的一个view arr 的值变为[0 1 10 3 4 5 6 7] ","date":"2021-02-15","objectID":"/go-study-04/:5:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Reslice s := arr[2:6] s = s[:3] s = s[1:] s = arr[:] ","date":"2021-02-15","objectID":"/go-study-04/:6:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Slice 的实现 slice的实现\u0026ldquo;slice的实现\u0026rdquo; \"\rslice的实现\r ","date":"2021-02-15","objectID":"/go-study-04/:7:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Slice 的扩展 arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s1 := arr[2:6] s2 := arr[3:5] s1 的值为[2 3 4 5]，s2 的值为[5 6] slice 可以向后扩展，不可以向前扩展 s[i] 不可以超越 len(s)，向后扩展不可以超越底层数组cap(s) ","date":"2021-02-15","objectID":"/go-study-04/:8:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"向Slice 添加元素 添加元素时如果超越cap，系统就会重新分配更大的底层数组 由于值传递的关系，必须接受append的返回值 s = append(s, val) ","date":"2021-02-15","objectID":"/go-study-04/:9:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建Slice ","date":"2021-02-15","objectID":"/go-study-04/:10:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个前99个奇数 var s []int for i := 0; i \u003c 100; i++ { s = append(s, 2*i+1) } ","date":"2021-02-15","objectID":"/go-study-04/:10:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个确定的切片 s1 := []int{2, 4, 6, 8} ","date":"2021-02-15","objectID":"/go-study-04/:10:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个len为16的切片 s2 := make([]int, 16) ","date":"2021-02-15","objectID":"/go-study-04/:10:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个len为10，cap为32的切片 s3 := make([]int, 10, 32) ","date":"2021-02-15","objectID":"/go-study-04/:10:4","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"复制切片 copy(s2, s1) ","date":"2021-02-15","objectID":"/go-study-04/:11:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片的元素 ","date":"2021-02-15","objectID":"/go-study-04/:12:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片里的一个元素(删除s2的第四个元素) s2 = append(s2[:3], s2[4:]...) ","date":"2021-02-15","objectID":"/go-study-04/:12:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片第一个元素 s2 = s2[1:] ","date":"2021-02-15","objectID":"/go-study-04/:12:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片最后一个元素 s2 = s2[:len(s2)-1] ","date":"2021-02-15","objectID":"/go-study-04/:12:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map m := map[string]string { \"name\": \"cc\", \"course\": \"golang\", \"site\": \"im\", \"quality\": \"notbad\" } map[K]V, map[K1]map[K2]V ","date":"2021-02-15","objectID":"/go-study-04/:13:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map的操作 ","date":"2021-02-15","objectID":"/go-study-04/:14:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map的遍历 使用range遍历key，或者遍历key，value对 for k, v := range m { fmt.Println(k, v) } 不保证遍历顺序，如需顺序，需手动对key排序 使用len来获得元素的个数 ","date":"2021-02-15","objectID":"/go-study-04/:14:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建：make(map[string]int) //m2 == empty m2 := make(map[string]int) //m3 == nil var m3 map[string]int ","date":"2021-02-15","objectID":"/go-study-04/:14:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"获取元素：map[key] name := m[\"name\"] ","date":"2021-02-15","objectID":"/go-study-04/:14:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"key不存在时，获得Value类型的初始值 name1 := m[\"name1\"] ","date":"2021-02-15","objectID":"/go-study-04/:14:4","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"用value, ok := map[key]来判断是否存在key if name1, ok := m[\"name1\"]; ok { fmt.Println(name1) } else { fmt.Println(\"key does not exist\") } ","date":"2021-02-15","objectID":"/go-study-04/:14:5","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"使用delete来删除一个元素 delete(m, \"age\") ","date":"2021-02-15","objectID":"/go-study-04/:14:6","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map的key map使用哈希表，必须可以比较相等 除了slice，map，function的内建类型都可以作为key Struct类型不包含上述字段，也可以作为key ","date":"2021-02-15","objectID":"/go-study-04/:15:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-15","objectID":"/go-study-04/:16:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组 在Go中数组是一个固定长度的数列。在Go中相对于数组而言，slice使用更多 func arraySample() { //创建了一个数组a来存放刚好5个int。元素类型和长度是数组类型的一部分 //数组默认是零值 var a [5]int fmt.Println(a) //使用array[index] = value语法来设置数组指定位置的值 //使用array[index]来得到值 a[4] = 100 fmt.Println(a) fmt.Println(a[4]) //使用内置函数len返回数组的长度 fmt.Println(\"len: \", len(a)) //使用这个语法一行内初始化一个数组 b := [5]int{1, 2, 3, 4, 5} fmt.Println(\"dcl: \", b) //数组的存储类型是单一的，但是可以组合这些数据来构造多维的数据结构 var twoD [2][3]int for i := 0; i \u003c 2; i++ { for j := 0; j \u003c 3; j++ { twoD[i][j] = i + j } } fmt.Println(\"2d: \", twoD) } ","date":"2021-02-15","objectID":"/go-study-04/:16:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"切片 Slice是Go中一个关键的数据类型，是一个比数组更加强大的序列接口 func sliceSample() { //slice的类型仅由它所包含的元素决定(不像数组还需要元素个数) //创建一个长度非零的空slice，需要使用内建的方法 make //创建一个长度为3的string类型slice(初始化为零值) s := make([]string, 3) fmt.Println(\"emp: \", s) //通过slice[index] = value来设置值 //slice[index]来获取值 s[0] = \"a\" s[1] = \"b\" s[2] = \"c\" fmt.Println(s) fmt.Println(s[2]) //通过len来获取slice长度 fmt.Println(\"len: \", len(s)) //作为基本操作的补充，slice支持比数组更多的操作 //其中一个是内建的append，它返回一个包含一个或多个新值的slice //slice底层是由指针数组和len以及cap组成的，append不会改变slice地址 s = append(s, \"d\") s = append(s, \"e\", \"f\") fmt.Println(\"append: \", s) //slice可以被copy //这里新建一个空的和s相同长度的slice c，并将s复制给c c := make([]string, len(s)) copy(c, s) fmt.Println(\"copy c: \",c) //slice支持通过slice[low:high]语法进行切片处理 l := s[2:5] fmt.Println(\"切片之后2-5slice: \", l) //这个slice从s[0]到(包含)s[5] l = s[:5] fmt.Println(\"从s[0]到s[5]: \", l) //这个slice从s[2]到s最后一个值 l = s[2:] fmt.Println(\"从s[2]到slice最后一个值: \", l) //在一行代码中声明并初始化一个slice变量 t := []string{\"g\", \"h\", \"i\"} fmt.Println(\"dcl: \", t) //slice可以组成多维数据结构 twoD := make([][]int, 3) for i := 0; i \u003c 3; i++ { innerlen := 4 twoD[i] = make([]int, innerlen) for j := 0; j \u003c innerlen; j++ { twoD[i][j] = i + j } } fmt.Println(\"2d: \", twoD) } ","date":"2021-02-15","objectID":"/go-study-04/:16:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"关联数组 map是Go内置关联数据类型(在其他语言成为哈希或字典) func mapsSample() { //要创建一个空的map，需要使用内建的map1 := make(map[key-type]value-type) m := make(map[string]int) fmt.Println(m) //使用经典的map1[key] = value语法来设置键值对 m[\"k1\"] = 1 m[\"k2\"] = 2 fmt.Println(\"map: \", m) //使用map1[key]来获取一个键的值 v1 := m[\"k1\"] fmt.Println(v1) //当对一个map调用内建len，返回的是键值对数目 fmt.Println(\"len: \", len(m)) //内建的delete可以从一个map中移除键值对 delete(m, \"k2\") fmt.Println(\"delete\", m) //从一个map中取值时，可选第二个返回值是这个键是否存在于map中 //这个可以用来消除键不存在或键有零值产生的歧义 _, prs := m[\"k2\"] fmt.Println(\"prs: \", prs) //一行申明和初始化一个map n := map[string]int{\"foo\": 1, \"bar\": 2, \"zhang\": 3} fmt.Println(n) } ","date":"2021-02-15","objectID":"/go-study-04/:16:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Go Study 03-循环语句","date":"2021-02-15","objectID":"/go-study-03/","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"for for的条件里不需要括号 for的条件里可以省略初始条件，结束条件，递增表达式 sum := 0 for i := 1; i \u003c= 100; i++ { sum += i } 省略初始条件，相当于while func convertToBin(n int) string { result := \"\" for ; n \u003e 0; n /= 2 { lsp := n % 2 result = strconv.Itoa(lsp) + result } return result } 省略初始条件和递增条件，也相当于while func printFile(filename string) { file, err := os.Open(filename) if err != nil { panic(err) } // 逐行读取file的内容 scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } } 无限循环 func forever() { for { fmt.Println(\"abc\") } } ","date":"2021-02-15","objectID":"/go-study-03/:1:0","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"基本语法要点回顾 for, if后面的条件没有括号 if条件里也可以定义变量 没有while switch不需要break，也可以直接switch多个条件 ","date":"2021-02-15","objectID":"/go-study-03/:2:0","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"案例 func sample() { //1.最常用的方式，带单个循环条件 i := 1 for i \u003c= 3 { fmt.Println(i) i += 1 } //2.经典的初始化/条件/后续形式for循环 for j := 7; j \u003c= 9; j++ { fmt.Println(j) } //3.不带条件的for循环将一直执行，直到循环体内使用了break或者return来跳出循环 for { fmt.Println(\"loop\") break } } ","date":"2021-02-15","objectID":"/go-study-03/:3:0","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"Range遍历 range迭代各种各样的数据结构 func loopSample2() { //这里使用range来统计一个slice的元素个数，数组也采用这种方式 nums := []int{2,4,5,3} sum := 0 for _, num := range nums { sum += num } fmt.Println(\"sum: \", sum) //range在数组和slice中同样提供了每项的索引和值 //不需要索引时可以使用_来忽略她 for i, num := range nums { if num == 3 { fmt.Println(\"index: \", i) } } //range在map中迭代键值对 kvs := map[string]string{ \"name\": \"cc\", \"age\": \"18\", } for k, v := range kvs { fmt.Printf(\"%v -\u003e %v\\n\", k, v) } //range在字符串中迭代Unicode编码 for i, v := range \"go\" { fmt.Println(i, v) } } ","date":"2021-02-15","objectID":"/go-study-03/:3:1","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"Go Study 02-条件语句","date":"2021-02-15","objectID":"/go-study-02/","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"if if的条件里不需要括号 func bounded(v int) int { if v \u003e 100 { return 100 } else if v \u003c 0 { return 0 } else { return v } } if的条件里可以赋值 if contents, err := ioutil.ReadFile(filename); err != nil { fmt.Println(err) } else { fmt.Printf(\"%s\\n\", contents) } if条件里赋值的变量作用域就在这个if语句里 ","date":"2021-02-15","objectID":"/go-study-02/:1:0","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"switch switch会自动break，除非使用fallthrough func eval(a, b int, op string) int { var result int switch op { case \"+\": result = a + b case \"-\": result = a - b case \"*\": result = a * b case \"/\": result = a / b default: panic(\"unsupported operator:\" + op) } return result } switch后可以没有表达式 func grade(score int) string { g := \"\" switch { case score \u003c 60: g = \"D\" case score \u003c 80: g = \"C\" case score \u003c 90: g = \"B\" case score \u003c= 100: g = \"A\" default: panic(fmt.Sprintf(\"Wrong score: %d\", score)) } return g } ","date":"2021-02-15","objectID":"/go-study-02/:2:0","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-15","objectID":"/go-study-02/:3:0","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"if/else分支 if和else分支结构在Go中当然是直接了当的了 func branchSample1() { if 7 % 2 == 0 { //7是偶数 fmt.Println(\"7 is even\") } else { //7是奇数 fmt.Println(\"7 is odd\") } //也可以不要else，只用if if 8 % 4 == 0 { fmt.Println(\"8 is divisible by 4\") } //在条件语句之前可以有一个语句，任何在这里声明的变量都可以在所有的条件分支中使用 if num := 9; num \u003c 0 { fmt.Println(num, \"is negative\") } else if num \u003c 10 { fmt.Println(num, \"has 1 digit\") } else { fmt.Println(num, \"has multiple digit\") } } ","date":"2021-02-15","objectID":"/go-study-02/:3:1","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"switch分支 func branchSample2() { //一个基本的switch i := 2 switch i { case 1: fmt.Println(\"one\") case 2: fmt.Println(\"two\") case 3: fmt.Println(\"three\") } //在一个case语句中可以使用逗号分割多个表达式 //使用了可选的default分支 switch time.Now().Weekday() { case time.Saturday, time.Sunday: fmt.Println(\"It's the weekend\") default: fmt.Println(\"It's a weekday\") } //不带表达式的switch是实现if/else的另一种方式 //这里展示了case表达式是如何使用非常量的 t := time.Now() switch { case t.Hour() \u003c 12: fmt.Println(\"it's before noon\") default: fmt.Println(\"it's after noon\") } } ","date":"2021-02-15","objectID":"/go-study-02/:3:2","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"Go Study 01-变量常量","date":"2021-02-15","objectID":"/go-study-01/","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"变量定义 ","date":"2021-02-15","objectID":"/go-study-01/:1:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"使用var关键字 var a,b,c bool var s1,s2 string = “hello”, “world” 可以放在函数内，或直接放在包内 使用var()集中定义变量 ","date":"2021-02-15","objectID":"/go-study-01/:1:1","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"让编译器自动决定类型 var a,b,i,s1,s2 = true, false, 3, “hello”, “world” ","date":"2021-02-15","objectID":"/go-study-01/:1:2","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"使用:=定义变量 a,b,i,s1,s2 := true, false, 3, “hello”, “world” 只能在函数内使用 ","date":"2021-02-15","objectID":"/go-study-01/:1:3","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"内建变量类型 bool, string (u)int, (u)int8, (u)int16, (u)int32, (u)int(64), uintptr(指针) byte, rune float32, float64, complex64, complex128 (complex是复数) ","date":"2021-02-15","objectID":"/go-study-01/:2:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"强制类型转换 类型转换是强制的 var a,b int = 3, 4 var int = math.Sqrt(aa + bb) (错误) var int = int(math.Sqrt(float64(aa + bb))) (正确) ","date":"2021-02-15","objectID":"/go-study-01/:3:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"常量定义 const filename = “abc.txt” const 数值可以作为各种类型使用 const a, b = 3, 4 var c int = int(math.Sqrt(aa + bb)) ","date":"2021-02-15","objectID":"/go-study-01/:4:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"使用常量定义枚举类型 普通枚举类型 const ( cpp = 1 java = 2 python = 3 golang = 4 ) 自增值枚举类型 const ( cpp = iota java python golang ) ","date":"2021-02-15","objectID":"/go-study-01/:5:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"变量定义要点回顾 变量类型写在变量名之后 编译器可推测变量类型 没有char，只有rune 原生支持复数类型 ","date":"2021-02-15","objectID":"/go-study-01/:6:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-15","objectID":"/go-study-01/:7:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"值 Go拥有各值类型，包括字符串，整型，浮点型，布尔型等 func value() { //字符串通过+连接 fmt.Println(\"go\" + \"lang\") //浮点数和整数 fmt.Println(\"1+1=\", 1+1) fmt.Println(\"7.0/3.0=\", 7.0/3.0) //布尔型和逻辑运算符 fmt.Println(true \u0026\u0026 false) fmt.Println(true || false) fmt.Println(!true) } ","date":"2021-02-15","objectID":"/go-study-01/:7:1","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"变量 在Go中，变量被显式声明，并被编译器所用来检查函数调用时的类型正确性 func varible() { //声明一个变量 var a string = \"initial\" fmt.Println(a) //声明多个变量 var b, c int = 1, 2 fmt.Println(b, c) //Go 将自动推断已经初始化的变量类型 var d = true fmt.Printf(\"%T %v\\n\", d, d) //声明变量且没有给出对应初始值，变量会被初始化为零值 var e int fmt.Println(e) //:=语句是申明并初始化变量的简写 f := \"short\" fmt.Println(f) } ","date":"2021-02-15","objectID":"/go-study-01/:7:2","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"常量 Go支持字符、字符串、布尔和数值常量 func constant() { //const用于声明一个常量 const s = \"constant\" fmt.Println(\"s=\", s) //const语句可以出现在任何var语句可以出现的地方 const n = 500000000 fmt.Println(n) //常数表达式可以执行任意精度的运算 const d = 3e20 / n fmt.Println(\"d = 3e20/n : \", d) //数值型常量是没有确定的类型，直到他们被给定一个类型，比如说一次显示的类型转化 fmt.Println(\"int64(d) = \", int64(d)) //当上下文需要的时候，一个数可以被给定一个类型，比如变量赋值或函数调用 //举个栗子，这里的math.Sin()需要一个float64参数 fmt.Println(\"math.Sin(n) = \", math.Sin(n)) } ","date":"2021-02-15","objectID":"/go-study-01/:7:3","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"Linux Network 02","date":"2021-02-14","objectID":"/linux-network-02/","tags":["Linux网络编程"],"title":"Linux Network 02","uri":"/linux-network-02/"},{"categories":["学习"],"content":"Socket(套接字)编程 ","date":"2021-02-14","objectID":"/linux-network-02/:1:0","tags":["Linux网络编程"],"title":"Linux Network 02","uri":"/linux-network-02/"},{"categories":["学习"],"content":"套接字概念 在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系 socket通信原理socket通信原理 \"\rsocket通信原理\r 在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区 ","date":"2021-02-14","objectID":"/linux-network-02/:1:1","tags":["Linux网络编程"],"title":"Linux Network 02","uri":"/linux-network-02/"},{"categories":["学习"],"content":"Linux Network 01","date":"2021-02-13","objectID":"/linux-network-01/","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"协议的概念 ","date":"2021-02-13","objectID":"/linux-network-01/:1:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"什么是协议？ 从应用的角度出发，协议可以理解为“规则”，是数据传输和数据解释的规则 ","date":"2021-02-13","objectID":"/linux-network-01/:1:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"典型协议 传输层 常见的协议有TCP/UDP协议 应用层 常见的协议有HTTP/FTP协议 网络层 常见的协议有IP/ICMP/IGMP协议 网络接口层 常见的协议有ARP/RARP协议 TCP传输控制协议是一种面向连接的、可靠地、基于字节流的传输层通信协议 UDP用户数据报协议是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务 HTTP超文本传输协议是互联网上应用最广泛的一种网络协议 FTP文件传输协议 IP协议是因特网互联协议 ICMP协议是Internet控制报文协议，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息 IGMP协议是Internet组管理协议，是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间 ARP协议是正向地址解析协议，通过已知IP寻找对应主机的MAC地址 RARP协议是反向地址转换协议，通过MAC地址确定IP地址 ","date":"2021-02-13","objectID":"/linux-network-01/:1:2","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"网络应用程序设计模式 ","date":"2021-02-13","objectID":"/linux-network-01/:2:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"C/S模式 传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信 ","date":"2021-02-13","objectID":"/linux-network-01/:2:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"B/S模式 浏览器(Brower)/服务器(server)模式。只需要在一端部署服务器，而另一端使用每台PC都默认配置的浏览器即可完成数据的传输 ","date":"2021-02-13","objectID":"/linux-network-01/:2:2","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"C/S优缺点 优点 1、协议选用灵活 2、数据可以提前缓存 缺点 1、对用户安全构成威胁 2、开发工作量较大 ","date":"2021-02-13","objectID":"/linux-network-01/:2:3","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"B/S优缺点 优点 1、不会安装第三方软件，安全性高 2、只需要开发服务端，工作量减小 3、可以跨平台 缺点 1、需要支持HTTP协议 2、不能进行数据缓存 ","date":"2021-02-13","objectID":"/linux-network-01/:2:4","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"分层模型 OSI参考模型 TCP/IP模型 应用层-- 表示层 |-\u003e 应用层 会话层-- 传输层 传输层 网络层 网络层 数据链路层-|-\u003e 网络接口层 物理层------ ","date":"2021-02-13","objectID":"/linux-network-01/:3:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"OSI七层模型 1、物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。他的主要作用是传输比特流 2、数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输 3、网络层：在位于不同地理位置的网络中的两个主机系统之间提供链接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层 4、传输层：定义了一些传输数据的协议和端口号(www端口80等)，如：TCP(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，UDP(用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的)。主要是将下层接受的数据进行分段和传输，达到目的地址后再进行重组，常常把这一层数据叫做段。 5、会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求(设备之间需要互相认识可以是IP也可以是MAC或者是主机名)。 6、表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用读取。如：PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码(ASCII)来表示相同字符，如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 7、应用层：是最靠近用户的OSI层，这一层为用户的应用程序(例如电子邮件、文件传输和终端仿真)提供网络服务 ","date":"2021-02-13","objectID":"/linux-network-01/:3:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"TCP/IP四层模型 TCP/IP网络协议栈分为应用层、传输层、网络层、链路层四层 其中应用层典型的是FTP协议，传输层典型的是TCP或UDP协议，网络层典型的是IP协议，链路层典型的是以太网帧协议 TCP/IP模型TCP/IP模型 \"\rTCP/IP模型\r ","date":"2021-02-13","objectID":"/linux-network-01/:3:2","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"通信过程 通信过程通信过程 \"\r通信过程\r ","date":"2021-02-13","objectID":"/linux-network-01/:4:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"协议格式 ","date":"2021-02-13","objectID":"/linux-network-01/:5:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"数据包封装 数据包封装TCP/IP数据包封装 \"\r数据包封装\r ","date":"2021-02-13","objectID":"/linux-network-01/:5:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"java02","date":"2021-02-10","objectID":"/java02/","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"标识符注意点 所有的标识符都应该以字母(A-Z或者a-z)，美元符($)或者下划线(_)开始 首字符之后可以是字母(A-Z或者a-z)，美元符($)，下划线(_)或数字的任何字符组合 不能使用关键字作为变量名或者方法名 标识符是大小写敏感的 合法标识符举例：age、$salary、_value、__1_value 非法标识符举例：123abc、-salary、#abc 可以使用中文命名，但是一般不建议这样去使用，也不建议使用拼音，很Low 数据类型 ","date":"2021-02-10","objectID":"/java02/:0:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"强类型语言 要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用 ","date":"2021-02-10","objectID":"/java02/:1:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"弱类型语言 ","date":"2021-02-10","objectID":"/java02/:2:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"java的数据类型分为两大类 基本类型(primitive type) 数值类型 整数类型 byte占一个字节范围：-128~127 short占两个字节范围：-32768~32767 int占四个字节范围：… long占八个字节范围：… 浮点类型 float占四个字节 double占八个字节 字符类型 char占两个字节 boolean类型：占一位其值只有true和false两个 引用类型(reference type) 类 接口 数组 什么是字节 位(bit)：是计算机内部数据储存的最小单位，11001100是一个八位二进制数 字节(byte)：是计算机数据处理的基本单位，习惯上用大写B来表示 1B(byte，字节) = 8bit(位) 字符：是指计算机中使用的字母、数字、字和符号 1bit表示1位 1Byte表示一个字节 1B=8b 1024B = 1KB 1024KB = 1M 1024M = 1G 类型转换 由于java是强类型语言，所以要进行有些运算的时候，需要用到类型转换 低-\u003e高 byte,short,char-\u003eint-\u003elong-\u003efloat-\u003edouble 运算中，不同的数据类型先转换成同一类型，然后进行运算 强制类型转换 (类型)变量名 高到低 自动类型转换 低到高 注意点： 1、不能对布尔值进行转换 2、不能把对象类型转换成不相关的类型 3、在把高容量转换成低容量的时候，强制转换 4、转换的时候可能存在内存溢出或者精度问题 变量 变量是什么？ 变量就是可以变化的量 java是一种强类型语言，每个变量都必须声明其类型。 java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域 注意事项： 每个变量都有类型，类型可以是基本类型，也可以是引用类型 变量名必须是合法的标识符 变量声明是一条完整的语句，因此每一个声明都必须以分号结束 变量的命名规范 所有变量、方法、类名：见名知意 类成员变量：首字母小写和驼峰原则：monthSalary 局部变量：首字母小写和驼峰原则 常量：大写字母和下划线：MAX_VALUE 类名：首字母大写和驼峰原则：Man，GoodMan 方法名：首字母小写和驼峰原则：run()，runRun() 常量 常量(Constant)：初始化(initialize)后不能再改变值！不会变动的值 所谓常量可以理解为一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变 final 常量名 = 值; 常量名一般使用大写字符 ","date":"2021-02-10","objectID":"/java02/:3:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"java01","date":"2021-02-09","objectID":"/java01/","tags":["java"],"title":"Java01","uri":"/java01/"},{"categories":["学习"],"content":"java是一门跨平台语言(jvm虚拟机) java特性和优势 简单性 面向对象 可移植性(write once, run anywhere) 高性能 分布式 动态性 多线程 安全性 健壮性 java三大版本 javaSE：标准版(桌面程序，控制台开发…) javaME：嵌入式开发(手机，小家电…) javaEE：E企业级开发(web端，服务器开发…) JDK、JRE、JVM JDK：Java Development Kit(java开发者工具) JRE：Java Runtime Environment(java运行时环境) JVM：Java Virtual Machine(java虚拟机) JDK\u003eJRE\u003eJVM","date":"2021-02-09","objectID":"/java01/:0:0","tags":["java"],"title":"Java01","uri":"/java01/"},{"categories":["学习"],"content":"dos常用命令","date":"2021-02-08","objectID":"/dos-code/","tags":["dos"],"title":"Dos Code","uri":"/dos-code/"},{"categories":["学习"],"content":"盘符切换 切换到C盘： c: 切换到E盘： e: 查看当前目录下的所有文件 dir 切换目录 cd change directory cd .. 清理屏幕 cls 退出终端 exit 查看电脑ip ipconfig 打开应用 calc mspaint notepad ping命令 ping 192.168.1.* 文件操作 创建一个文件夹：md 目录名 移除一个文件夹：rd 目录名 创建一个文件： cd\u003e 文件名 移除一个文件： del 文件名","date":"2021-02-08","objectID":"/dos-code/:0:0","tags":["dos"],"title":"Dos Code","uri":"/dos-code/"},{"categories":["学习"],"content":"markdown学习01","date":"2021-02-07","objectID":"/markdown-study01/","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"1 标题 ","date":"2021-02-07","objectID":"/markdown-study01/:0:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"h2 标题 ","date":"2021-02-07","objectID":"/markdown-study01/:1:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"h3 标题 h4 标题 h5 标题 h6 标题、 要添加自定义标题ID，请在与标题相同的行中将自定义ID放在花括号中 ###一个很棒的标题 {#custom-id} 2 注释 注释和HTML兼容的 3 水平线 HTML中的\u003chr\u003e标签是用来在段落元素之间创建一个“专题间隔”的 Markdown可以使用以下方式： -–：三个连续的破折号 ___：三个连续的下划线 ***：三个连续的星号 4 段落 HTML中将用\u003cp\u003e\u003c/p\u003e标签包裹 Markdown直接按照纯文本的方式书写段落 5 内联HTML元素 这是HTML 6 强调 ","date":"2021-02-07","objectID":"/markdown-study01/:1:1","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"加粗 用于强调带有较粗字体的文本片段 以下文本会被渲染为粗体 **渲染为粗体** __渲染为粗体__ 输出的HTML看起来像这样 \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2021-02-07","objectID":"/markdown-study01/:2:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"斜体 用于强调带有斜体的文本片段 以下文本片段被渲染成斜体 *渲染为斜体* _渲染为斜体_ 输出的HTML看起来像这样 \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2021-02-07","objectID":"/markdown-study01/:3:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"删除线 以下文本片段会被渲染成删除线 ~~这段文本带有删除线~~ 输出的HTML看起来像这样 \u003cdel\u003e这段文本带有删除线\u003c/del\u003e 这段文本带有删除线 ","date":"2021-02-07","objectID":"/markdown-study01/:4:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"组合 加粗，斜体和删除线可以组合使用 ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除和斜体*~~ ~~***加粗，斜体和删除线***~~ 输出的HTML看起来像这样 \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003cem\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗，斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e 加粗和斜体 删除线和加粗 删除和斜体 加粗，斜体和删除线 7 引用 用于在文档中引用其他来源的内容块 在要引用的任何文本之前添加\u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage 输出的HTML看起来像这样 \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套 \u003e **Fusion Drive** combines a hard drive with a flash storage \u003e\u003e 111 Fusion Drive combines a hard drive with a flash storage 111 8 列表 ","date":"2021-02-07","objectID":"/markdown-study01/:5:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"无序列表 一系列项的列表，其中项的顺序没有明显关系 你可以使用以下任何符号来表示无序列表中的项 * 一项内容 * 子内容 - 一项内容 + 一项内容 一项内容 子内容 一项内容 一项内容 ","date":"2021-02-07","objectID":"/markdown-study01/:6:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"有序列表 一系列项的列表，其中项的顺序确实很重要 1. a 2. b 3. c 输出的HTML看起来像这样 \u003col\u003e \u003cli\u003ea\u003c/li\u003e \u003cli\u003eb\u003c/li\u003e \u003cli\u003ec\u003c/li\u003e \u003c/ol\u003e a b c ","date":"2021-02-07","objectID":"/markdown-study01/:7:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"任务列表 任务列表使你可以创建带有复选框的列表，要创建列表，请在任务列表项之前添加破折号(-)和带有空格的方括号([ ])，要选择复选框，请在方括号之间添加x([x]) - [x] a - [ ] b - [ ] c Write the press release Update the website Contact the media 9 代码 ","date":"2021-02-07","objectID":"/markdown-study01/:8:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"行内代码 用\\包装行内代码段 在这个例子中, \\\u003csection\u003e\\\u003c/section\u003e 会被包裹成 **代码**. \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e 呈现的输出效果如下： 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. ","date":"2021-02-07","objectID":"/markdown-study01/:9:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"缩进代码 // Some comments line 1 of code line 2 of code line 3 of code 输出的HTML看起来像这样： \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e 呈现的输出效果如下： // Some comments line 1 of code line 2 of code line 3 of code ","date":"2021-02-07","objectID":"/markdown-study01/:10:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"围栏代码块 使用“围栏”```来生成一段带有语言属性的代码块 Sample text here... Sample text here... 10 表格 通过在每个单元格之间添加竖线作为分隔线，并在标题下添加一行破折号(也由竖线分隔)来创建表格，注意竖线不需要垂直对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中 | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 输出的HTML看起来像这样 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 链接 ","date":"2021-02-07","objectID":"/markdown-study01/:11:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 输出的HTML看起来像这样 \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e 呈现的输出效果如下(将鼠标悬停在链接上，没有提示) https://assemble.io contact@revolunet.com Assemble ","date":"2021-02-07","objectID":"/markdown-study01/:12:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 输出的HTML看起来像这样 \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e 呈现的输出效果如下(将鼠标悬停在链接上，会有一行提示) Upstage 12 脚注 脚注使你可以添加注释和参考，而不会使文档正文混乱，当你使用脚注时，会在添加脚注引用的位置出现带有链接的上标标号，读者可以单击链接以跳至页面底部的脚注内容 要创建脚注引用，请在方括号中添加插入符号和标识符 (1)，标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号。 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 (1：这是一段脚注)。你不一定要在文档末尾添加脚注. 可以将它们放在除列表，引用和表格等元素之外的任何位置。 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 13 图片 图片的语法与链接相似，但包含一个在前面的感叹号 ![Minion](https://octodex.github.com/images/minion.png) ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2021-02-07","objectID":"/markdown-study01/:13:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["生活"],"content":"第一篇blog","date":"2021-02-05","objectID":"/first_post/","tags":["我的"],"title":"First_post","uri":"/first_post/"},{"categories":["生活"],"content":"first post LoveIt主题中文文档 emoji表情 去露营啦! ⛺ 很快就回来. 真开心! 😂 blog前置参数注解 ","date":"2021-02-05","objectID":"/first_post/:0:0","tags":["我的"],"title":"First_post","uri":"/first_post/"},{"categories":null,"content":"aa ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]