[{"categories":["实例"],"content":"Go Instance 21-读文件、写文件","date":"2021-03-23","objectID":"/go-instance-21/","tags":["golang"],"title":"Go Instance 21","uri":"/go-instance-21/"},{"categories":["实例"],"content":"读文件 package main import ( \"bufio\" \"fmt\" \"io\" \"io/ioutil\" \"os\" ) func check(e error) { if e != nil { panic(e) } } func main() { //大部分文件读取都是将内容读取到内存中 dat, err := ioutil.ReadFile(\"f:/test/test.txt\") check(err) fmt.Println(string(dat)) //读取文件可以从os.Open打开文件获取一个os.File开始 f, e := os.Open(\"f:/test/test1.txt\") defer f.Close() check(e) //从文件开始位置读取字节。这里最多读取5个字节。 b1 := make([]byte, 5) n1, err1 := f.Read(b1) check(err1) fmt.Println(n1, string(b1)) fmt.Printf(\"%d bytes: %s\\n\", n1, string(b1)) //也可以Seek到一个文件已知的位置并从这个位置开始读取 o2, err := f.Seek(6, 0) check(err) b2 := make([]byte, 2) n2, err := f.Read(b2) check(err) fmt.Printf(\"%d bytes @ %d: %s\\n\", n2, o2, string(b2)) //io包提供了可以帮助文件读取的函数 //可以使用ReadAtLeast得到一个更健壮的实现 o3, err := f.Seek(6, 0) check(err) b3 := make([]byte, 2) n3, err := io.ReadAtLeast(f, b3, 2) check(err) fmt.Printf(\"%d bytes @ %d: %s\\n\", n3, o3, string(b3)) //没有内置的回转支持，但是可以使用Seek(0,0)实现 _, err = f.Seek(0, 0) check(err) //bufio包实现了带缓冲的读取 //这不仅对有很多的小读取操作的性能有所提升，还提供了很多附加的读取函数 r4 := bufio.NewReader(f) b4, err := r4.Peek(5) check(err) fmt.Printf(\"5 bytes: %s\\n\", string(b4)) } ","date":"2021-03-23","objectID":"/go-instance-21/:1:0","tags":["golang"],"title":"Go Instance 21","uri":"/go-instance-21/"},{"categories":["实例"],"content":"写文件 package main import ( \"bufio\" \"fmt\" \"io/ioutil\" \"os\" ) //和read处于同一个包，不能有相同的方法名 //func check(err error) { // if err != nil { // panic(err) // } //} func main() { //如何写入一个字符串到一个文件里 d1 := \"hello\\ngo\\n\" err := ioutil.WriteFile(\"f:/test/test2.txt\", []byte(d1), 0644) check(err) //更细粒度的写入，先打开一个文件 f1, err := os.Create(\"f:/test/test3.txt\") check(err) defer f1.Close() //写入要写的字节切片 d2 := []byte{115, 111, 109, 101, 10} n, err := f1.Write(d2) check(err) fmt.Println(n) //WriteString也是可用的 n3, err := f1.WriteString(\"writes\\n\") check(err) fmt.Println(n3) //调用sync将缓冲区的信息写入磁盘 f1.Sync() //bufio提供带缓冲的写入器 w := bufio.NewWriter(f1) n4, err := w.WriteString(\"buffered\\n\") check(err) fmt.Println(n4) //使用Flush确保所有缓存操作以写入磁盘 w.Flush() } ","date":"2021-03-23","objectID":"/go-instance-21/:2:0","tags":["golang"],"title":"Go Instance 21","uri":"/go-instance-21/"},{"categories":["实例"],"content":"Go Instance 20-SHA1散列、Base64编码","date":"2021-03-23","objectID":"/go-instance-20/","tags":["golang"],"title":"Go Instance 20","uri":"/go-instance-20/"},{"categories":["实例"],"content":"SHA1散列 SHA1散列经常用生成二进制文件或者文本块的短标识。例如：Git版本控制系统大量使用SHA1来标识受版本控制的文件和目录。 package main import ( \"crypto/sha1\" \"fmt\" ) func main() { s := \"sha1 this string\" //产生一个散列值的方式是sha1.New(),sha1.Write(bytes),sha1.sum(bytes) h := sha1.New() //写入要处理的字节。如果是字符串，需使用[]byte()强制转换成字节数组 h.Write([]byte(s)) //这个用来得到最终的散列值的字符切片 //Sum的参数为现有的字符切片追加额外的字节切片：一般不需要 sum := h.Sum(nil) //sha1值经常以16进制输出 fmt.Println(h) fmt.Println(sum) fmt.Printf(\"%x\\n\", sum) } ","date":"2021-03-23","objectID":"/go-instance-20/:1:0","tags":["golang"],"title":"Go Instance 20","uri":"/go-instance-20/"},{"categories":["实例"],"content":"Base64编码 Go提供内建的base64编码 package main import ( \"encoding/base64\" \"fmt\" ) func main() { //将要编解码的字符串 data := \"abc123!?$*\u0026()'-=@~\" //Go同时支持标准的和URL兼容的base64格式 //编码需要使用[]byte类型参数，故要将字符串转成字节型 s := base64.StdEncoding.EncodeToString([]byte(data)) fmt.Println(s) //解码可能会发生错误，如果不确定，需要进行错误检查 bys, _ := base64.StdEncoding.DecodeString(s) fmt.Println(string(bys)) fmt.Println() //使用URL兼容的base64格式进行编码解码 s1 := base64.URLEncoding.EncodeToString([]byte(data)) fmt.Println(s1) bys2, _ := base64.URLEncoding.DecodeString(s1) fmt.Println(string(bys2)) } ","date":"2021-03-23","objectID":"/go-instance-20/:2:0","tags":["golang"],"title":"Go Instance 20","uri":"/go-instance-20/"},{"categories":["实例"],"content":"Go Instance 19-数字解析，URL解析","date":"2021-03-23","objectID":"/go-instance-19/","tags":["golang"],"title":"Go Instance 19","uri":"/go-instance-19/"},{"categories":["实例"],"content":"数字解析 从字符串中解析数字 package main import ( \"fmt\" \"strconv\" ) func main() { //使用Parse.Float解析浮点数，64表示解析的数的位数 f, _ := strconv.ParseFloat(\"1.234\", 64) fmt.Println(f) //在使用ParseInt解析整数时，base参数0表示自动推断字符串所表示的数字进制 //64表示返回的整型数是以64存储的 i, _ := strconv.ParseInt(\"123\", 0, 64) fmt.Println(i) //ParseInt会自动识别出十六进制数 d, _ := strconv.ParseInt(\"0x1c8\", 0, 64) fmt.Println(d) //ParseUint也是可用的 u, _ := strconv.ParseUint(\"789\", 0, 64) fmt.Println(u) //Atoi是一个基础的十进制整型数转换函数 a, _ := strconv.Atoi(\"135\") fmt.Println(a) //在输入错误时，会报错 _, e := strconv.Atoi(\"wat\") fmt.Println(e) } ","date":"2021-03-23","objectID":"/go-instance-19/:1:0","tags":["golang"],"title":"Go Instance 19","uri":"/go-instance-19/"},{"categories":["实例"],"content":"URL解析 URL提供了一个同一资源定位方式 package main import ( \"fmt\" \"net/url\" \"strings\" ) func main() { //这个URL实例，包含一个Scheme，认证信息，主机名，端口，路径，查询参数和片段 s := \"postgres://user:pass@host.com:5432/path?k=v#f\" //解析URL，确保解析没错 u, e := url.Parse(s) if e != nil { panic(e) } //直接访问Scheme fmt.Println(u.Scheme) //User包含了所有的认证信息，调用Username和Password来获取独立值 fmt.Println(u.User) fmt.Println(u.User.Username()) p, _ := u.User.Password() fmt.Println(p) //Host同时包含主机名和端口信息，如果端口号存在的话，使用strings.Split从Host中手动提取 fmt.Println(u.Host) h := strings.Split(u.Host, \":\") fmt.Println(h[0]) fmt.Println(h[1]) //提取路径和查询片段信息 fmt.Println(u.Path) fmt.Println(u.Fragment) //要得到字符串中的k=v这种格式的查询参数，可以使用RawQuery //也可以将查询参数解析为一个map。已解析的查询参数 map 以查询字符串为键， //对应值字符串切片为值，所以如何只想得到一个键对应的第一个值，将索引位置设置为 [0] 就行了。 fmt.Println(u.RawQuery) m, _ := url.ParseQuery(u.RawQuery) fmt.Println(m) fmt.Println(m[\"k\"][0]) } ","date":"2021-03-23","objectID":"/go-instance-19/:2:0","tags":["golang"],"title":"Go Instance 19","uri":"/go-instance-19/"},{"categories":["实例"],"content":"Go Instance 18-随机数","date":"2021-03-23","objectID":"/go-instance-18/","tags":["golang"],"title":"Go Instance 18","uri":"/go-instance-18/"},{"categories":["实例"],"content":"随机数 Go的math/rand包提供了伪随机数生成器 package main import ( \"fmt\" \"math/rand\" \"time\" ) func main() { //rand.Intn返回一个随机整数n，0\u003c=n\u003c=100 fmt.Print(rand.Intn(100),\",\") fmt.Print(rand.Intn(100)) fmt.Println() //rand.Float64返回一个64位浮点数f，0.0\u003c=f\u003c=1.0 fmt.Println(rand.Float64()) //这个技巧可以用来生成其他范围的随机浮点数f，5.0\u003c=f\u003c=10 fmt.Print((rand.Float64()*5)+5, \",\") fmt.Print((rand.Float64()*5)+5) fmt.Println() //默认情况下，给定的种子是确定的，每次都会产生相同的随机数数字序列 //要产生变化的序列，需要给定一个变化的种子，需要注意的是 //如果是出于加密目的，需要使用随机数的话，请使用crypto/rand包，此方法不够安全 s1 := rand.NewSource(time.Now().UnixNano()) r1 := rand.New(s1) fmt.Println(r1) //调用上面rand.Source的函数和调用rand包中的函数是相同的 fmt.Print(r1.Intn(100), \",\") fmt.Print(r1.Intn(100)) fmt.Println() //如果使用相同种子生成的随机数生成器，将会产生相同的随机数列 s2 := rand.NewSource(42) r2 := rand.New(s2) fmt.Print(r2.Intn(100), \",\") fmt.Print(r2.Intn(100)) fmt.Println() s3 := rand.NewSource(42) r3 := rand.New(s3) fmt.Print(r3.Intn(100), \",\") fmt.Print(r3.Intn(100)) fmt.Println() } ","date":"2021-03-23","objectID":"/go-instance-18/:1:0","tags":["golang"],"title":"Go Instance 18","uri":"/go-instance-18/"},{"categories":["实例"],"content":"Go Instance 17-时间","date":"2021-03-23","objectID":"/go-instance-17/","tags":["golang"],"title":"Go Instance 17","uri":"/go-instance-17/"},{"categories":["实例"],"content":"时间 Go对时间和时间段提供了大量的支持 package main import ( \"fmt\" \"time\" ) func main() { p := fmt.Println //获得当前时间 now := time.Now() p(now) //提供年月日等信息，可以构建一个time。时间总是关联位置信息，例如时区 then := time.Date(2009, 11, 17, 20, 34, 58, 651387237, time.UTC) p(then) //提取出时间的各个组成部分 p(then.Year()) p(then.Month()) p(then.Day()) p(then.Hour()) p(then.Minute()) p(then.Second()) p(then.Nanosecond()) p(then.Location()) //输出时间的星期 p(then.Weekday()) //使用方法比较时间，精确到秒 p(then.Before(now)) p(then.After(now)) p(then.Equal(now)) //Sub返回一个duration来表示两个时间点的间隔时间 diff := now.Sub(then) p(diff) //计算不同单位下的时间长度值 p(diff.Hours()) p(diff.Minutes()) p(diff.Seconds()) p(diff.Nanoseconds()) //可以使用Add将时间后移一个时间间隔，或在时间间隔前加-，将时间前移一个时间间隔 p(then.Add(diff)) p(then.Add(-diff)) } ","date":"2021-03-23","objectID":"/go-instance-17/:1:0","tags":["golang"],"title":"Go Instance 17","uri":"/go-instance-17/"},{"categories":["实例"],"content":"时间戳 一般程序都有获取Unix时间的秒数，毫秒数或微秒数的需要 package main import ( \"fmt\" \"time\" ) func main() { //分别使用带Unix或者UnixNano的time.Now来获取从自协调世界时起到现在的秒数或纳秒数 now := time.Now() secs := now.Unix() nanos := now.UnixNano() fmt.Println(now) //UnixMillis是不存在的，所以要得到毫秒数，得自己转化 millis := nanos/1000000 fmt.Println(secs) fmt.Println(millis) fmt.Println(nanos) //也可以将秒数或毫秒数转化为时间 fmt.Println(time.Unix(secs, 0)) fmt.Println(time.Unix(0, nanos)) } ","date":"2021-03-23","objectID":"/go-instance-17/:2:0","tags":["golang"],"title":"Go Instance 17","uri":"/go-instance-17/"},{"categories":["实例"],"content":"时间格式化和解析 Go支持通过基于描述模板的时间格式化和解析 package main import ( \"fmt\" \"time\" ) func main() { p := fmt.Println now := time.Now() //按照RFC3339格式化 p(now.Format(time.RFC3339)) //时间解析使用Format相同的形式值 t1, _ := time.Parse(time.RFC3339, \"2021-03-23T11:01:37+08:00\") p(t1) //Format和Parse使用基于例子的形式来决定日期格式 //一般只需要使用time包内的格式，但是可以实现自定义模式 // 模式必须使用时间 Mon Jan 2 15:04:05 MST 2006来指定给定时间/字符串的格式化/解析方式。 // 时间一定要按照如下所示：2006为年，15 为小时，Monday 代表星期几，等等。 p(now.Format(\"03:04pm\")) p(now.Format(\"Mon Jan _2 15:04:05 2006\")) p(now.Format(\"2006-01-02T15:04:05.999999-07:00\")) format := \"3 04pm\" t2, _ := time.Parse(format, \"8 41pm\") p(t2) //对于纯数字表示的时间，可以使用标准的格式化字符串来提取时间值的组成 fmt.Printf(\"%d-%02d-%02dT%02d:%02d:%02d-00:00\\n\", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()) //Parse函数在输入时间格式不正确会返回错误 ansic := \"Mon Jan _2 15:04:05 2006\" _, e := time.Parse(ansic, \"8:41PM\") fmt.Println(e) } ","date":"2021-03-23","objectID":"/go-instance-17/:3:0","tags":["golang"],"title":"Go Instance 17","uri":"/go-instance-17/"},{"categories":["实例"],"content":"Go Instance 16-Json","date":"2021-03-22","objectID":"/go-instance-16/","tags":["golang"],"title":"Go Instance 16","uri":"/go-instance-16/"},{"categories":["实例"],"content":"JSON Go提供内置的JSON编解码支持，包括内置或自定义类型与JSON数据之间的转化 package main import ( \"encoding/json\" \"fmt\" \"os\" ) type Response1 struct { Page int Fruits []string } type Response2 struct { Page int `json:\"page\"` Fruits []string `json:\"fruits\"` } func main() { //基本数据类型到JSON字符串的编码过程 bolB, _ := json.Marshal(true) fmt.Println(string(bolB)) intB, _ := json.Marshal(1) fmt.Println(string(intB)) fltB, _ := json.Marshal(3.14) fmt.Println(string(fltB)) strB, _ := json.Marshal(\"gopher\") fmt.Println(string(strB)) //切片和map编码成JSON数组和对象 slcD := []string{\"apple\", \"peach\", \"pear\"} slcB, _ := json.Marshal(slcD) fmt.Println(string(slcB)) mapD := map[string]int{\"apple\": 5, \"lettuce\": 7} mapB, _ := json.Marshal(mapD) fmt.Println(string(mapB)) //JSON包可以自动编码自定义类型 //编码仅输出可导出的字段，并且默认使用他们的名字作为JSON数据的键 res1D := \u0026Response1{ Page:1, Fruits:[]string{\"apple\", \"peach\", \"pear\"}, } res1B, _ := json.Marshal(res1D) fmt.Println(string(res1B)) //可以在结构体字段声明标签来自定义编码的JSON数据键名称 res2D := \u0026Response2{ Page:1, Fruits:[]string{\"apple\", \"peach\", \"pear\"}, } res2B, _ := json.Marshal(res2D) fmt.Println(string(res2B)) //JSON数据解码 byt := []byte(`{\"num\":6.13, \"strs\":[\"a\", \"b\"]}`) //提供一个JSON包可以存放解码数据的变量 var dat map[string]interface{} //实际的解码与错误检查 if err := json.Unmarshal(byt, \u0026dat); err != nil { panic(err) } fmt.Println(dat) //为了使用解码map中的值，可以将他们进行适当的类型转化 //将num的值转化为float64 num := dat[\"num\"].(float64) fmt.Println(num) //访问嵌套的值需要一系列的转化 strs := dat[\"strs\"].([]interface{}) str := strs[0].(string) fmt.Println(str) //解码JSON值到自定义类型 //这个功能的好处：可以为程序带来额外的类型安全加强，并且消除访问数据时的类型断言 str1 := `{\"page\": 1, \"fruits\": [\"apple\", \"pear\"]}` res := Response2{} json.Unmarshal([]byte(str1), \u0026res) fmt.Println(res) fmt.Println(res.Fruits[0]) //可以和os.Stdout一样，直接将JSON编码输出至os.Writer流中，或者作为HTTP响应体 enc := json.NewEncoder(os.Stdout) d := map[string]int{\"apple\": 5, \"lettuce\": 7} enc.Encode(d) } ","date":"2021-03-22","objectID":"/go-instance-16/:1:0","tags":["golang"],"title":"Go Instance 16","uri":"/go-instance-16/"},{"categories":["实例"],"content":"Go Instance 15-字符串格式化、正则表达式","date":"2021-03-22","objectID":"/go-instance-15/","tags":["golang"],"title":"Go Instance 15","uri":"/go-instance-15/"},{"categories":["实例"],"content":"字符串格式化 Go在传统的printf中对字符串格式化提供了优异的支持。 package main import ( \"fmt\" \"os\" ) type point struct { x, y int } func main() { //Go为常规Go值的格式设计了许多种打印方式。 p := point{1, 2} fmt.Printf(\"%v\\n\", p) //如果值是一个结构体，%+v的格式化输出内容包括结构体的字段名 fmt.Printf(\"%+v\\n\", p) //%#v形式则输出这个值的Go语法表示。例如值的运行源代码片段 fmt.Printf(\"%#v\\n\", p) //需要打印值的类型，使用%T fmt.Printf(\"%T\\n\", p) //格式化布尔值，%t fmt.Printf(\"%t\\n\", true) //格式化整型的多种方式 //使用%d进行标准的十进制格式化 fmt.Printf(\"%d\\n\", 123) //使用%b进行二进制格式化 fmt.Printf(\"%b\\n\", 14) //这个整数对应的字符 fmt.Printf(\"%c\\n\", 33) //%x提供十六进制编码 fmt.Printf(\"%x\\n\", 456) //对于浮点数同样有很多格式化选项 //使用%f进行最基本的十进制格式化 fmt.Printf(\"%f\\n\", 78.9) //%e和%E将浮点型格式化为科学计数法表示形式 fmt.Printf(\"%e\\n\", 123400000.0) fmt.Printf(\"%E\\n\", 123400000.0) //使用%s进行基本的字符串输出 fmt.Printf(\"%s\\n\", \"\\\"string\\\"\") //带有双引号的输出，使用%q fmt.Printf(\"%q\\n\", \"\\\"string\\\"\") //%x输出使用base-16编码的字符串，每个字节用两个字符表示 fmt.Printf(\"%x\\n\", \"hey this\") //输出一个指针的值%p fmt.Printf(\"%p\\n\", \u0026p) //当输出数字时，想要控制输出结果的宽度和精度 //可以在%后面使用数字来控制输出宽度 //默认结果使用右对齐并且通过空格来填充空白部分 fmt.Printf(\"|%6d|%6d|\\n\", 12, 345) //也可以指定浮点数的输出宽度，同时也可以通过宽度，精度的语法来指定输出的精度 fmt.Printf(\"|%6.2f|%6.2f|\\n\", 1.2, 3.45) //要左对齐%后面使用- fmt.Printf(\"|%-6.2f|%-6.2f|\\n\", 1.2, 3.45) //字符串输出时的宽度 fmt.Printf(\"|%6s|%6s|\\n\", \"foo\", \"b\") //要左对齐%后面使用- fmt.Printf(\"|%-6s|%-6s|\\n\", \"foo\", \"b\") //Printf通过os.Stdout输出格式化的字符串 //Sprintf格式化并返回一个字符串并不带任何输出 s := fmt.Sprintf(\"a %s\", \"string\") fmt.Println(s) //使用Fprint格式化并输出到io.Writers而不是os.Stdout fmt.Fprint(os.Stderr, \"an %s\\n\", \"error\") } ","date":"2021-03-22","objectID":"/go-instance-15/:1:0","tags":["golang"],"title":"Go Instance 15","uri":"/go-instance-15/"},{"categories":["实例"],"content":"正则表达式 Go提供内置的正则表达式。 package main import ( \"bytes\" \"fmt\" \"regexp\" ) func main() { //测试一个字段是否符合一个表达式 matched, _ := regexp.MatchString(\"p([a-z]+)ch\", \"peach\") fmt.Println(matched) //上面直接使用字符串，但是对于一些其他正则任务 //需要Compile一个优化的Regexp结构体 r, _ := regexp.Compile(\"p([a-z]+)ch\") //这个结构体有很多方法，这是类似前面的匹配测试 fmt.Println(r.MatchString(\"peach\")) //这是查找匹配字符串 fmt.Println(r.FindString(\"peach punch\")) //查找第一次匹配的字符串，返回的是匹配开始和结束的索引，而不是内容 fmt.Println(r.FindStringIndex(\"peach punch\")) //submatch返回完全匹配和局部匹配的字符串。例如这里会返回p([a-z]+)ch和([a-z]+)的信息 fmt.Println(r.FindStringSubmatch(\"peach punch\")) //返回完全匹配和局部匹配的索引位置 fmt.Println(r.FindStringSubmatchIndex(\"peach punch\")) //带All的这个函数返回所有的匹配项，而不仅仅是首次匹配项 fmt.Println(r.FindAllString(\"peach punch pinch\", -1)) //返回所有的完全匹配和局部匹配的索引位置 fmt.Println(r.FindAllStringSubmatchIndex(\"peach punch pinch\", -1)) //使用提供的正整数限制匹配个数 fmt.Println(r.FindAllString(\"peach punch pinch\", 2)) //也可以提供[]byte参数并将String从函数名中去掉 fmt.Println(r.Match([]byte(\"peach\"))) //创建正则表达式常量时，可以使用Compile的变体MustCompile //因为Compile返回两个值，不能用于常量 r = regexp.MustCompile(\"p([a-z]+)ch\") fmt.Println(r) //regexp包也可以用来替换部分字符串的其他值 fmt.Println(r.ReplaceAllString(\"a peach\", \"\u003cfruits\u003e\")) //Func变量允许传递匹配内容到一个给定的函数中 in := []byte(\"a peach\") out := r.ReplaceAllFunc(in, bytes.ToUpper) fmt.Println(string(out)) } ","date":"2021-03-22","objectID":"/go-instance-15/:2:0","tags":["golang"],"title":"Go Instance 15","uri":"/go-instance-15/"},{"categories":["实例"],"content":"Go Instance 14-组合函数、字符串函数","date":"2021-03-22","objectID":"/go-instance-14/","tags":["golang"],"title":"Go Instance 14","uri":"/go-instance-14/"},{"categories":["实例"],"content":"组合函数 我们经常需要程序在数据集上执行操作，比如选择满足条件的所有想，或者将所有项通过一个自定义函数映射到一个新的集合上 在某些语言中，会习惯使用泛型。Go不支持泛型，在Go中当你的程序或数据类型有需要时，通常是以组合的方式来提供操作函数 这是一些strings切片的组合函数实例。可以使用这些例子来构建自己的函数。注意有些时候直接使用内联组合操作代码会更加清晰，而不是创建并调用一个函数 package main import ( \"fmt\" \"strings\" ) //返回目标字段s出现的第一个位置，没有返回-1 func Index(s string, arr []string) int { for i, v := range arr { if s == v { return i } } return -1 } //如果目标s在切片中存在返回true func Include(s string, arr []string) bool { return Index(s, arr) \u003e= 0 } //如果切片中的字符串有一个满足条件f返回true func Any(arr []string, f func(string) bool) bool { for _, v := range arr { if f(v) { return true } } return false } //如果切片中的字符串所有都满足条件f返回true func All(arr []string, f func(string) bool) bool { for _, v := range arr { if !f(v) { return false } } return true } //返回一个包含所有切面中满足条件f的新切片 func Filer(arr []string, f func(string) bool) []string { result := make([]string, 0) for _, v := range arr{ if f(v) { result = append(result, v) } } return result } //返回一个对原始切片中所有字符串执行函数f的切片 func Map(arr []string, f func(string) string) []string { result := make([]string, 0) for _, v := range arr { result = append(result, f(v)) } return result } func main() { fruits := []string{\"peach\", \"apple\", \"pear\", \"plum\"} fmt.Println(Index(\"pear\", fruits)) fmt.Println(Include(\"grape\", fruits)) fmt.Println(Any(fruits, func(v string) bool { return strings.HasPrefix(v, \"p\") })) fmt.Println(All(fruits, func(v string) bool { return strings.HasPrefix(v, \"p\") })) fmt.Println(Filer(fruits, func(v string) bool { return strings.Contains(v, \"e\") })) //上面都是使用匿名函数，也可以使用类型正确的命名函数 fmt.Println(Map(fruits, strings.ToUpper)) } ","date":"2021-03-22","objectID":"/go-instance-14/:1:0","tags":["golang"],"title":"Go Instance 14","uri":"/go-instance-14/"},{"categories":["实例"],"content":"字符串函数 标准库的strings包提供了很多有用的字符相关的函数。这里是一些用来让你对这个包有个初步理解的例子 package main import ( \"fmt\" s \"strings\" ) //给fmt.Println起别名，之后会经常用到 var p = fmt.Println func main() { //这是一些strings中的函数例子。注意他们都是函数中的例子，不是字符串对自身的方法 //这意味着我们需要考虑在调用时传递字符作为第一个参数进行传递 p(\"Contains: \", s.Contains(\"test\", \"es\")) p(\"Count: \", s.Count(\"test\", \"t\")) p(\"HasPrefix: \", s.HasPrefix(\"test\", \"te\")) p(\"HasSuffix: \", s.HasSuffix(\"test\", \"st\")) p(\"Index: \", s.Index(\"test\", \"e\")) p(\"Join: \", s.Join([]string{\"a\", \"b\"}, \"-\")) p(\"Repeat: \", s.Repeat(\"a\", 5)) p(\"Replace: \", s.Replace(\"foo\", \"o\", \"O\", -1)) p(\"Replace: \", s.Replace(\"foo\", \"o\", \"O\", 1)) p(\"Split: \", s.Split(\"a-b-c-d-e\", \"-\")) p(\"ToLower: \", s.ToLower(\"TEST\")) p(\"ToUpper: \", s.ToUpper(\"test\")) } ","date":"2021-03-22","objectID":"/go-instance-14/:2:0","tags":["golang"],"title":"Go Instance 14","uri":"/go-instance-14/"},{"categories":["实例"],"content":"Go Instance 13-panic、defer","date":"2021-03-22","objectID":"/go-instance-13/","tags":["golang"],"title":"Go Instance 13","uri":"/go-instance-13/"},{"categories":["实例"],"content":"Panic panic意味着有些出乎意料的错误发生。通常用它表示程序正常运行中不该出现的，或者没有处理好的事务 package main import \"os\" func main() { //这里直接panic出一个错误 panic(\"a problem\") //panic的一个基本用法就是在一个函数返回了错误值但是并不知道（或不想）处理时停止运行 //这里是创建一个新文件时返回异常错误的panic用法 _, e := os.Create(\"F://test.txt\") if e != nil { panic(e) } } ","date":"2021-03-22","objectID":"/go-instance-13/:1:0","tags":["golang"],"title":"Go Instance 13","uri":"/go-instance-13/"},{"categories":["实例"],"content":"Defer defer用来确保一个函数调用在程序执行结束前执行。通常用来执行一些清理工作 package main import ( \"fmt\" \"os\" ) //本例为创建一个文件，对其进行写操作，结束后关闭 func main() { //创建文件，进行写操作，结束时关闭文件 f := createFile(\"F:/test/test.txt\") defer closeFile(f) writeFile(f) } func createFile(s string) *os.File { fmt.Println(\"creating\") file, err := os.Create(s) if err != nil { panic(err) } return file } func closeFile(f *os.File) { fmt.Println(\"closing\") f.Close() } func writeFile(f *os.File) { fmt.Println(\"writing\") fmt.Fprintln(f, \"data ok\") } ","date":"2021-03-22","objectID":"/go-instance-13/:2:0","tags":["golang"],"title":"Go Instance 13","uri":"/go-instance-13/"},{"categories":["学习"],"content":"redis面试02","date":"2021-03-18","objectID":"/redis-interview-02/","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"过期键的删除策略 ","date":"2021-03-18","objectID":"/redis-interview-02/:1:0","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"Redis的过期键的删除策略 Redis是一个key-value数据库，我们可以在Redis中设置键的过期时间。Redis的过期策略就是指当前Redis中的缓存key过期了，Redis如何处理。 通常过期策略有以下三种： 定时过期：每个设置了过期时间的key都需要创建一个定时器，过到期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的相应时间和吞吐量。 惰性过期：只有当访问一个key时，才会判断这个key是否过期，过期则立即清除。该策略可以最大化的节省CPU资源，却对内存非常不友好。极端情况下可能出现大量过期的key没有再次被访问，从而不会被删除，占用大量内存。 定期过期：每隔一定时间，会扫描一定数量数据库的expires字典中一定数量的key，并清除其中已经过期的key。该策略是前两种的折中策略。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。 （expires字典会保存所有设置了过期时间的key的过期时间和数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度Unix时间戳表示的过期时间，键空间是指该Redis集群中保存的所有键） Redis中同时使用了惰性过期和定期过期两种过期方式。 ","date":"2021-03-18","objectID":"/redis-interview-02/:1:1","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"Redis key的过期时间和永久有效分别怎么设置 EXPIRE和PERSIST命令 ","date":"2021-03-18","objectID":"/redis-interview-02/:1:2","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"通过EXPIRE来设置key的过期时间，那么对过期的数据怎么处理 除了缓存服务器自带的缓存失效策略之外（Redis中有6中策略可以选择），还可以根据具体业务自定义的缓存淘汰，常见的策略有两种： 定时去清理过期缓存 当有用户请求时，再判断这个所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 ","date":"2021-03-18","objectID":"/redis-interview-02/:1:3","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"内存相关 ","date":"2021-03-18","objectID":"/redis-interview-02/:2:0","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据 redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略 ","date":"2021-03-18","objectID":"/redis-interview-02/:2:1","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"Redis的内存淘汰策略有哪些 Redis的内存淘汰策略是指在Redis的用于缓存的内存不足，怎么处理需要新写入且需要申请额外空间的数据 全局的键空间选择性移除： noeviction：当内存不足容纳写入新数据时，新写入操作会报错 allkeys-lru：当内存不足容纳写入新数据时，在键空间中，移除最近最少使用的key（这个是最常用的） allkeys-random：当内存不足容纳写入新数据时，在键空间随机移除某个key 设置过期时间的键空间选择性移除 volatile-lru：当内存不足容纳写入新数据时，在设置了过期时间的键空间中，移除最近最少使用的key volatile-random：当内存不足容纳写入新数据时，在设置了过期时间的键空间中，随机移除某个key volatile-ttl：当内存不足容纳写入新数据时，在设置了过期时间的键空间中，有更早过期的key优先移除 ","date":"2021-03-18","objectID":"/redis-interview-02/:2:2","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"Redis如何做内存优化 可以利用Hash，Set，Zset，List等集合类型数据。因为通常情况下很多小的key-value可以用更紧凑的方式放在一起。尽量使用散列表（hash），散列表使用的内存非常小。 ","date":"2021-03-18","objectID":"/redis-interview-02/:2:3","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"线程模型 ","date":"2021-03-18","objectID":"/redis-interview-02/:3:0","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"Redis线程模型 Redis基于Reactor模式开发了网络时间处理器，这个处理器被称为文件时间处理器。它的组成结构为4部分多个套接字，IO多路复用程序，文件事件分派器，事件处理器。因为文件事件分配器队列的消费是单线程的，所以Redis才叫单线程模型。 ","date":"2021-03-18","objectID":"/redis-interview-02/:3:1","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"事务 ","date":"2021-03-18","objectID":"/redis-interview-02/:4:0","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"什么是事务 事务是一个单独的隔离操作，事务中的所有命令都会序列化，按一定顺序执行。事务在执行的过程中，不会被其他客户端发来的命令请求打断。 事务是一个原子操作。事务中的命令要么全部执行要么都不执行。 ","date":"2021-03-18","objectID":"/redis-interview-02/:4:1","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"Redis事务概念 Redis事务的本质是通过MULTI，EXEC，WATCH等一组命令的集合。事务支持一次执行多条指令，一个事务中的所有命令都会被序列化。在事务执行过程中，会按照序列串行化执行队列中的命令，其他客户端的请求不会插入到事务执行命令序列中。 总结：Redis事务就是一次性、顺序性、排他性的执行一个队列里的一系列命令。 ","date":"2021-03-18","objectID":"/redis-interview-02/:4:2","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"Redis事务的三个命令 事务开始 MULTI 命令入队 事务结束 EXEC ","date":"2021-03-18","objectID":"/redis-interview-02/:4:3","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"Redis保证原子性吗？支持回滚吗？ Redis中单条命令是原子性的，但是事务不保证原子性不支持回滚。事务中的命令只要没有语法错误，事务中的命令都会依次执行。 ","date":"2021-03-18","objectID":"/redis-interview-02/:4:4","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"集群方案 ","date":"2021-03-18","objectID":"/redis-interview-02/:5:0","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"哨兵模式 哨兵主要功能： 集群监控：负责监控master和slave是否正常工作。 消息通知：如果某个实例有故障，哨兵负责发送消息作为报警通知给管理员 故障转移：如果master挂了，会投票选一个slave作为master 配置中心：如果故障转移了，通知client客户端新的master地址 哨兵模式用于实现Redis集群的高可用，本身也是分布式的，是以集群运行工作的。 故障转移时，判断一个主机是否宕机，需要大部分哨兵同意，这涉及分布式选举。 即使部分哨兵失效了，哨兵集群还是能正常工作的。 哨兵的核心知识： 哨兵至少要有三个实例来保证健壮性 哨兵+redis主从的部署结构，不会保证数据零丢失，只能保证Redis集群的高可用性 ","date":"2021-03-18","objectID":"/redis-interview-02/:5:1","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"缓存异常 ","date":"2021-03-18","objectID":"/redis-interview-02/:6:0","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"缓存雪崩 缓存雪崩是指缓存同一时间大面积失效，所以后面的请求都会落在数据库上，造成数据库短时间内承受大量请求而崩掉。 解决方案 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 一般并发量不是特别多的时候，使用最多的是加锁排队 给每个缓存数据添加缓存标记，记录缓存是否失效，如果标记失效，更新缓存。 ","date":"2021-03-18","objectID":"/redis-interview-02/:6:1","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"缓存穿透 缓存穿透是指缓存和数据库中都没有数据，导致所有的请求都落在数据库上，造成数据短时间承受大量请求而崩掉 解决方案： 接口层添加校验，如用户鉴权校验，id作为基础校验，id小于等于0直接拦截 从缓存中取不到数据，在数据库中也取不到数据，这时可以将key-value写成key-null，缓存有效时间可以写短一点，（设置太长可能导致正常情况也没法使用）。这样可以防止攻击用户反复使用一个id攻击。 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免对底层存储系统的查询压力。 ","date":"2021-03-18","objectID":"/redis-interview-02/:6:2","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"缓存击穿 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间过期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库取数据，引起数据库压力瞬间增大，造成过大压力。 和雪崩不同的是：缓存击穿指并发差同一条数据，缓存雪崩是指不同的数据都过期了，很多数据查不到从而查数据库 解决方案： 设置热点数据永不过期 加互斥锁 ","date":"2021-03-18","objectID":"/redis-interview-02/:6:3","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"缓存预热 缓存预热就是指系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据 解决方案： 直接写个缓存刷新页面，上线时手工操作一下 数据量不大，可以在项目启动的时候自动进行加载 自动刷新缓存 ","date":"2021-03-18","objectID":"/redis-interview-02/:6:4","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"缓存降级 当访问量剧增，服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然要保证服务还是可用的，即使是有损服务，系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级 缓存降级的最终目标是保证核心服务可用，即使是有损的，而且有些服务是无法降级的（如加入购物车，结算） 在进行降级之前要对系统进行梳理，看看系统是不是可以弃车保帅；从而梳理出哪些必须誓死保护，哪些可以降级，比如可以参考日志级别设置预案 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级 警告：有些服务在一段时间内成功率有波动（如在95%~100%之间），可以自动降级或人工降级，并发送警告 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量忽然间猛增到系统能承受的最大阈值，此时可以根据情况自动降级或人工降级 严重错误：比如因为特殊原因数据错误，此时需要紧急人工降级 服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。 ","date":"2021-03-18","objectID":"/redis-interview-02/:6:5","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"热点数据和冷数据 热点数据，缓存才有价值 对于冷数据而言，大部分数据可能还没有再次访问就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存 对于热点数据，缓存以后可能读取数十万次或百万次 缓存数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有其作用就失效了，那就太没有价值了。 那存不存在，修改频率很高，但是又不得不考虑缓存的场景？存在，如这个读取接口对数据库压力很大，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮 ","date":"2021-03-18","objectID":"/redis-interview-02/:6:6","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"缓存热点key 缓存中的一个Key（比如一个促销商品），在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求发送过来，这些请求发现缓存过期，一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮 解决方案： 对缓存查询加锁，如果key不存在，就加锁，然后查DB入缓存，然后解锁。其他进程如果发现有锁就等待，然后等解锁后返回锁具或者进入DB查询 ","date":"2021-03-18","objectID":"/redis-interview-02/:6:7","tags":["redis"],"title":"Redis Interview 02","uri":"/redis-interview-02/"},{"categories":["学习"],"content":"redis学习04","date":"2021-03-15","objectID":"/redis-study-04/","tags":["redis"],"title":"Redis Study 04","uri":"/redis-study-04/"},{"categories":["学习"],"content":"Redis主从复制 ","date":"2021-03-15","objectID":"/redis-study-04/:1:0","tags":["redis"],"title":"Redis Study 04","uri":"/redis-study-04/"},{"categories":["学习"],"content":"概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（master/leader），后者称为从节点（slave/follower）。数据的复制是单向的，只能从主节点到从节点。master以写为主，salve以读为主。 默认情况下，每台Redis服务器都是主节点。且每个主节点可以有多个从节点（或没有从节点），但是一个从节点只能有一个主节点 主从复制包括： 数据冗余：主从复制实现了数据的热备份，是持久化的一种数据冗余方式 故障修复：当主节点出现问题，可以由从节点提供服务，实现快速的故障修复，实际上是一种服务的冗余 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据是应用连接从节点），分担服务器负载；尤其在写少读多的情况下，通过多个节点分担读负载，可以大大提高Redis服务的并发量 高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis的高可用的基础。 一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下： 从结构上，单个Redis服务器会发生单点故障，并且一台服务器要处理所有的请求负载，压力较大。 从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256GB，也不能将所有内存作为Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20GB 一般电商网站上的商品，一般都是一次上传，无数次浏览，说专业点就是多读少写 主从复制，读写分离！80%的情况下都是在进行读操作！减缓服务器压力！架构中经常使用一主二从！ ","date":"2021-03-15","objectID":"/redis-study-04/:1:1","tags":["redis"],"title":"Redis Study 04","uri":"/redis-study-04/"},{"categories":["学习"],"content":"环境配置 只配置从库，不用配置主库 127.0.0.1:6379\u003e info replication # 查看当前库的信息 # Replication role:master # 角色 connected_slaves:0 # 连接的从机个数 master_replid:c3d733dbffb09746cf8ef0b4b87ce62406dd0c83 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 复制3个配置文件，然后修改对应的配置信息 端口号 pid文件名 日志名 dump.rdb文件 修改完毕后启动，启动3个Redis集群 redis主从复制配置\u0026ldquo;redis主从复制配置\u0026rdquo; \"\rredis主从复制配置\r ","date":"2021-03-15","objectID":"/redis-study-04/:1:2","tags":["redis"],"title":"Redis Study 04","uri":"/redis-study-04/"},{"categories":["学习"],"content":"一主二从 默认情况下，每台Redis服务器都是主节点；我们一般情况下只要配置从机就可以了 127.0.0.1:6380\u003e SLAVEOF 127.0.0.1 6379 # 选择主机 OK 127.0.0.1:6380\u003e info replication # Replication role:slave # 当前角色是从机 master_host:127.0.0.1 # 主机ip master_port:6379 # 主机端口号 master_link_status:up master_last_io_seconds_ago:2 master_sync_in_progress:0 slave_repl_offset:14 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:60116b0ccf67baa49701e78ea9cbb17c2673dded master_replid2:0000000000000000000000000000000000000000 master_repl_offset:14 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:14 # 配置完两台从机 127.0.0.1:6379\u003e info replication # Replication role:master connected_slaves:2 slave0:ip=127.0.0.1,port=6380,state=online,offset=1148,lag=0 slave1:ip=127.0.0.1,port=6381,state=online,offset=1148,lag=0 master_replid:60116b0ccf67baa49701e78ea9cbb17c2673dded master_replid2:0000000000000000000000000000000000000000 master_repl_offset:1148 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:1148 真实的从主配置应该在配置文件中，这样的话是永久的，这里使用命令配置，暂时的。 主机可以写，从机不能写只能读！主机中的所有信息都会被从机自动保存 主机断开连接，从机依旧可以连到主机，但没有写操作。如果主机重新连接了，从机依旧可以直接获取主机写的信息! 如果使用命令行配置主从，如果从机重启了，就会变回主机！只要变回从机，就能立马从主机获取值 ","date":"2021-03-15","objectID":"/redis-study-04/:1:3","tags":["redis"],"title":"Redis Study 04","uri":"/redis-study-04/"},{"categories":["学习"],"content":"redis学习04","date":"2021-03-15","objectID":"/redis-study-03/","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"三大特殊数据类型 ","date":"2021-03-15","objectID":"/redis-study-03/:1:0","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"geospatial（地理位置） Redis的GEO ####################################################### # geoadd 添加geo # geopos 获取geo 127.0.0.1:6379\u003e GEOADD china:city 116.40 39.90 beijing (integer) 1 127.0.0.1:6379\u003e GEOADD china:city 121.47 31.23 shanghai 106.50 29.53 chongqin (integer) 2 127.0.0.1:6379\u003e GEOADD china:city 120.16 30.24 hangzhou 108.96 34.26 xian (integer) 2 127.0.0.1:6379\u003e GEOPOS china:city beijing chongqin 1) 1) \"116.39999896287918091\" 2) \"39.90000009167092543\" 2) 1) \"106.49999767541885376\" 2) \"29.52999957900659211\" ####################################################### # geodist 两点之间的距离 127.0.0.1:6379\u003e GEODIST china:city beijing shanghai km # 查看北京到上海的距离 \"1067.3788\" ####################################################### # georadius 获取坐标点周围的数据 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 1000 km # 获取坐标点位110,30方圆1000km在china:city数据 1) \"chongqin\" 2) \"xian\" 3) \"hangzhou\" 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 500 km 1) \"chongqin\" 2) \"xian\" ####################################################### # georadiusbymember 以城市为中心方圆的数据 127.0.0.1:6379\u003e GEORADIUSBYMEMBER china:city beijing 100 km 1) \"beijing\" 127.0.0.1:6379\u003e GEORADIUSBYMEMBER china:city beijing 1000 km 1) \"beijing\" 2) \"xian\" 127.0.0.1:6379\u003e GEORADIUSBYMEMBER china:city hanghai 1000 km (error) ERR could not decode requested zset member 127.0.0.1:6379\u003e GEORADIUSBYMEMBER china:city shanghai 1000 km 1) \"hangzhou\" 2) \"shanghai\" ####################################################### # geohash 以hash返回数据的经纬度 127.0.0.1:6379\u003e GEOHASH china:city beijing 1) \"wx4fbxxfke0\" ####################################################### # geo底层实现原理其实是zset 127.0.0.1:6379\u003e ZRANGE china:city 0 -1 # 查看全部元素 1) \"chongqin\" 2) \"xian\" 3) \"hangzhou\" 4) \"shanghai\" 5) \"beijing\" 127.0.0.1:6379\u003e ZREM china:city beijing # 移除元素 (integer) 1 127.0.0.1:6379\u003e ZRANGE china:city 0 -1 1) \"chongqin\" 2) \"xian\" 3) \"hangzhou\" 4) \"shanghai\" ","date":"2021-03-15","objectID":"/redis-study-03/:1:1","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"hyperloglog 基数：一个set不重复元素的数量 hyperloglog主要用来做统计 如果可以容错可以使用这个。这个空间占用少。 ####################################################### # pfadd 添加元素 # pfcount 获得元素个数 # pfmerge 将两个set整合到一个新的集合 127.0.0.1:6379\u003e PFADD myset a b c d e f g h i j k (integer) 1 127.0.0.1:6379\u003e PFCOUNT myset (integer) 11 127.0.0.1:6379\u003e PFADD myset2 b s d j o l m n u (integer) 1 127.0.0.1:6379\u003e PFCOUNT myset2 (integer) 9 127.0.0.1:6379\u003e PFMERGE myset3 myset myset2 OK 127.0.0.1:6379\u003e PFCOUNT myset3 (integer) 17 ","date":"2021-03-15","objectID":"/redis-study-03/:1:2","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"bitmaps 位存储 只有存储0和1 ####################################################### # setbit 添加数据 # getbit 获得数据 # bitcount 统计个数 127.0.0.1:6379\u003e SETBIT sign 0 1 (integer) 0 127.0.0.1:6379\u003e SETBIT sign 1 1 (integer) 0 127.0.0.1:6379\u003e SETBIT sign 2 0 (integer) 0 127.0.0.1:6379\u003e SETBIT sign 3 0 (integer) 0 127.0.0.1:6379\u003e SETBIT sign 4 1 (integer) 0 127.0.0.1:6379\u003e GETBIT sign 3 (integer) 0 127.0.0.1:6379\u003e GETBIT sign 4 (integer) 1 127.0.0.1:6379\u003e BITCOUNT sign (integer) 3 ","date":"2021-03-15","objectID":"/redis-study-03/:1:3","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"事务 Redis事务本质：一组命令的集合。一个事务中的所有命令会被序列化，在事务执行的过程中，会按顺序执行。 一次性、顺序性、排他性。执行一些命令 Redis单条命令保持原子性，事务不保证原子性 Redis事务： 开始事务（） 命令入队（） 执行事务（） ####################################################### # multi 开始事务 # exec 执行事务 127.0.0.1:6379\u003e MULTI OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e EXEC 1) OK 2) OK 3) \"v2\" 4) OK ####################################################### # discard 放弃事务（相当于回滚） 127.0.0.1:6379\u003e MULTI OK 127.0.0.1:6379\u003e set k4 v4 QUEUED 127.0.0.1:6379\u003e set k5 v5 QUEUED 127.0.0.1:6379\u003e DISCARD OK 127.0.0.1:6379\u003e get k4 (nil) ","date":"2021-03-15","objectID":"/redis-study-03/:2:0","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"编译型异常（代码有问题，命令有错），事务中的命令都不会执行 127.0.0.1:6379\u003e MULTI OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e GETSET k4 # 错误命令 (error) ERR wrong number of arguments for 'getset' command 127.0.0.1:6379\u003e set k4 v4 QUEUED 127.0.0.1:6379\u003e set k5 v5 QUEUED 127.0.0.1:6379\u003e EXEC # 执行事务报错 (error) EXECABORT Transaction discarded because of previous errors. 127.0.0.1:6379\u003e get k5 # 所有命令都不会执行 (nil) ","date":"2021-03-15","objectID":"/redis-study-03/:2:1","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"运行时异常，如果队列中存在语法性（语法没有问题），那么执行命令的时候其他命令是可以正常执行的，错误命令抛出异常 127.0.0.1:6379\u003e set k1 v1 OK 127.0.0.1:6379\u003e MULTI OK 127.0.0.1:6379\u003e INCR k1 # 会执行报错 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e get k3 QUEUED 127.0.0.1:6379\u003e EXEC 1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但其他还是正常执行了 2) OK 3) OK 4) \"v3\" ","date":"2021-03-15","objectID":"/redis-study-03/:2:2","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"Redis锁 ","date":"2021-03-15","objectID":"/redis-study-03/:3:0","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"悲观锁 很悲观，认为什么时候都会出现问题，无论做什么都会加锁 ","date":"2021-03-15","objectID":"/redis-study-03/:3:1","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"乐观锁 很乐观，认为什么时候都不会出现问题，所以不会上锁，更新的时候去判断一下，在此期间是否有人修改过值 主要通过获取version 更新的时候比较第一次获取的version 正常执行成功 127.0.0.1:6379\u003e set money 100 OK 127.0.0.1:6379\u003e set out 0 OK 127.0.0.1:6379\u003e watch money # 监视money对象 OK 127.0.0.1:6379\u003e MULTI # 事务开始，事务执行期间数据没有发生变化，事务正常执行 OK 127.0.0.1:6379\u003e DECR money QUEUED 127.0.0.1:6379\u003e INCR out QUEUED 127.0.0.1:6379\u003e EXEC 1) (integer) 99 2) (integer) 1 测试多线程修改值，使用watch可以当做redis的乐观锁操作 127.0.0.1:6379\u003e watch money #监视money OK 127.0.0.1:6379\u003e MULTI OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY out 20 QUEUED 127.0.0.1:6379\u003e EXEC (nil) 执行前另一个事务修改值 127.0.0.1:6379\u003e INCRBY money 300 (integer) 399 ","date":"2021-03-15","objectID":"/redis-study-03/:3:2","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"redis.conf详解 启动的时候就通过配置文件来启动 ","date":"2021-03-15","objectID":"/redis-study-03/:4:0","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"单位 redis单位\u0026ldquo;redis单位\u0026rdquo; \"\rredis单位\r 配置文件，unit单位，对大小写不敏感 ","date":"2021-03-15","objectID":"/redis-study-03/:4:1","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"包含 redis包含\u0026ldquo;redis包含\u0026rdquo; \"\rredis包含\r 导入文件 ","date":"2021-03-15","objectID":"/redis-study-03/:4:2","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"网络 bind 127.0.0.1 # 绑定的ip protected-mode yes # 保护模式是否开启 port 6379 # 端口号 ","date":"2021-03-15","objectID":"/redis-study-03/:4:3","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"通用GENERAL daemonize yes # 以守护进程的方式运行，默认是no pidfile /var/run/redis_6379.pid # 如果以后台的方式运行，我们就需要指定一个pid文件 ","date":"2021-03-15","objectID":"/redis-study-03/:4:4","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"日志 redis日志\u0026ldquo;redis日志\u0026rdquo; \"\rredis日志\r logfile \"\" # 日志的文件位置名 databases 16 # 数据库数量，默认是16个数据库 always-show-logo yes # 是否总是显示logo ","date":"2021-03-15","objectID":"/redis-study-03/:4:5","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"快照 持久化，在规定的时间执行了多少次操作，则会持久化到文件.rdb或.aof中 redis是内存数据库，如果没有持久化，数据库断点即失 # 如果900内至少有1个key进行修改，就会进行持久化操作 save 900 1 # 如果300内有10个key进行修改，就会进行持久化操作 save 300 10 # 如果60内有10000个key进行修改，就会进行持久化操作 save 60 10000 stop-writes-on-bgsave-error yes # 持久化如果出错是否还需要继续运行 rdbcompression yes # 是否压缩rdb文件，需要消耗一些cpu资源 rdbchecksum yes # 保存rdb文件的时候，进行错误的检查校验 dir ./ # rdb文件的保存路径 ","date":"2021-03-15","objectID":"/redis-study-03/:4:6","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"REPLICATION 复制 ","date":"2021-03-15","objectID":"/redis-study-03/:4:7","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"SECURITY 安全 ","date":"2021-03-15","objectID":"/redis-study-03/:4:8","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"限制CLIENTS maxclients 10000 # 设置能连接上redis的最多客户端数量 maxmemory \u003cbytes\u003e # redis配置的最大内存容量 maxmemory-policy noeviction # 内存达到上限的处理策略 1. volatile-lru：只对设置了过期时间的key进行LRU（默认值） 2. allkeys-lru：删除LRU算法的key 3. volatile-lfu：只对设置了过期时间的key进行LFU 4. allkeys-lfu：删除LFU算法的key 5. volatile-random：随机删除即将过期的key 6. allkeys-random：随机删除 7. volatile-ttl：删除即将过期的 8. noeviction：永不过期，返回错误 ","date":"2021-03-15","objectID":"/redis-study-03/:4:9","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"APPEND ONLY模式 aof持久化 appendonly no # 默认是不开启aof模式 appendfilename \"appendonly.aof\" # 持久化文件的名字 # appendfsync always # 每次修改都会sync。消耗性能 appendfsync everysec # 每秒执行一次sync。可能会丢失这1s的数据 # appendfsync no # 不执行sync，这个时候操作系统自己同步数据，速度最快 ","date":"2021-03-15","objectID":"/redis-study-03/:4:10","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"Redis持久化 Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以redis提供了持久化功能 ","date":"2021-03-15","objectID":"/redis-study-03/:5:0","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"RDB 什么是RDB 在指定的时间间隔内将内存中的数据集体快照写入磁盘中，也就是快照，恢复时是将快照文件直接读到内存中。 Redis会单独创建一个（fork）一个子进程进行持久化，会将数据写入到一个临时的文件中，待持久化过程都结束了，再用这个临时文件替换掉上次持久化好的文件。整个过程中，主进程不会进行任何IO操作。这就确保了极高的性能。如果需要大规模数据的恢复，且对数据恢复的完整性不是很敏感，RDB要比AOF高效。RDB缺点是最后一次持久化的数据可能丢失。 RDB保存的dump.rdb文件，在conf文件中进行配置 dbfilename dump.rdb 触发机制 save规则满足的情况下，会自动触发rdb规则 执行flushall命令也会触发rdb规则 退出redis，也会产生rdb文件 备份就会生成dump.rdb 如何恢复rdb文件 只需要将rdb文件放在启动目录下即可，redis启动的时候回自动检查dump.rdb恢复其中的数据。 查看需要存在的位置 127.0.0.1:6379\u003e clear 127.0.0.1:6379\u003e config get dir 1) \"dir\" 2) \"/root\" # 如果目录下存在dump.rdb文件，启动的时候就会自动恢复其中的数据 几乎默认的配置就够用了 优点： 适合大规模的数据恢复！ 如果对数据的完整性要求不高 缺点： 需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改数据就没了 fork进程的时候会占用一定的内容空间 ","date":"2021-03-15","objectID":"/redis-study-03/:5:1","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"AOF（Append Only File） 什么是AOF： 将执行过的所有命令记录下来 以日志的形式来记录每个写操作，将Redis执行过程中的所有指令记录下来（读操作不记录），只许追加文件，但不可以改写文件，Redis启动之初会读取该文件重新构造数据。换言之，Redis重启的话就是根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 AOF 保存的是appendonly.aof文件 默认是不开启的，需要手动进行配置，只许将appendonly改为yes就开启的AOF 重启，Redis就生效了 如果appendonly.aof文件有错，redis是启动不了的，需要修复aof文件。redis提供了一个工具redis-check-aof –fix 如果文件正常，重启就可以直接恢复了 优点： 每一次修改都同步，文件完整会更好 每秒同步一次，可能会丢失一秒的数据 从不同步，效率最高 缺点： 相对于数据文件来说，aof远大于rdb，修复速度也比rdb慢 aof运行效率比rdb慢，所以默认的是rdb持久化 ","date":"2021-03-15","objectID":"/redis-study-03/:5:2","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"Redis订阅发布 订阅端 127.0.0.1:6379\u003e SUBSCRIBE cc # 订阅一个频道 Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" 2) \"cc\" 3) (integer) 1 # 等待读取推送的信息 1) \"message\" #消息 2) \"cc\" #频道 3) \"hello,world\" #具体内容 发送端 127.0.0.1:6379\u003e PUBLISH cc hello,world # 发布者发布消息到频道 (integer) 1 ","date":"2021-03-15","objectID":"/redis-study-03/:6:0","tags":["redis"],"title":"Redis Study 03","uri":"/redis-study-03/"},{"categories":["学习"],"content":"redis学习02","date":"2021-03-12","objectID":"/redis-study-02/","tags":["redis"],"title":"Redis Study 02","uri":"/redis-study-02/"},{"categories":["学习"],"content":"五大数据类型 ","date":"2021-03-12","objectID":"/redis-study-02/:1:0","tags":["redis"],"title":"Redis Study 02","uri":"/redis-study-02/"},{"categories":["学习"],"content":"Stirng（字符串） ####################################################### # set # get # exists # append 127.0.0.1:6379\u003e set key1 v1 # 设置key1 OK 127.0.0.1:6379\u003e get key1 # 获得值 \"v1\" 127.0.0.1:6379\u003e exists key1 # 判断key是否存在 (integer) 1 127.0.0.1:6379\u003e append key1 \"hello\" # 追加字符串，如果当前key不存在相当于set key (integer) 7 127.0.0.1:6379\u003e get key1 \"v1hello\" ####################################################### # strlen 127.0.0.1:6379\u003e strlen key1 # 获取字符串长度 (integer) 7 127.0.0.1:6379\u003e append key1 \",cc\" (integer) 10 127.0.0.1:6379\u003e strlen key1 (integer) 10 127.0.0.1:6379\u003e get key1 \"v1hello,cc\" ####################################################### # 步长 i++ 127.0.0.1:6379\u003e incr views # 自增1 (integer) 1 127.0.0.1:6379\u003e get views \"1\" 127.0.0.1:6379\u003e decr views # 自减1 (integer) 0 127.0.0.1:6379\u003e incrby views 10 # 设置步长，指定增量 (integer) 10 127.0.0.1:6379\u003e get views \"10\" 127.0.0.1:6379\u003e DECRBY views 5 (integer) 5 127.0.0.1:6379\u003e GET views \"5\" ####################################################### # 字符串范围 127.0.0.1:6379\u003e set key1 \"hello,cc\" OK 127.0.0.1:6379\u003e GETRANGE key1 0 3 # 截取字符串， [0,3] \"hell\" 127.0.0.1:6379\u003e GETRANGE key1 0 -1 # 获取全部字符串，相当于get key \"hello,cc\" # 替换 127.0.0.1:6379\u003e set key2 abcdefg OK 127.0.0.1:6379\u003e GET key2 \"abcdefg\" 127.0.0.1:6379\u003e SETRANGE key2 1 xx # 替换指定位置开始的字符串 (integer) 7 127.0.0.1:6379\u003e GET key2 \"axxdefg\" ####################################################### # setex (set with expire) 设置过期时间 # setnx (set if not exist) 不存在才设置（在分布式锁中常使用） 127.0.0.1:6379\u003e SETEX key3 30 \"hello\" # 设置key3为hello，30秒后过期 OK 127.0.0.1:6379\u003e ttl key3 # 查看剩余时间 (integer) 22 127.0.0.1:6379\u003e get key3 \"hello\" 127.0.0.1:6379\u003e SETNX mykey redis # 如果mykey不存在，创建mykey (integer) 1 127.0.0.1:6379\u003e get mykey \"redis\" 127.0.0.1:6379\u003e SETNX mykey mongodb # 如果mykey存在，创建失败 (integer) 0 127.0.0.1:6379\u003e get mykey \"redis\" 127.0.0.1:6379\u003e ttl key3 (integer) -2 127.0.0.1:6379\u003e get key3 (nil) ####################################################### # mset （同时设置多个值） # mget （同时获取多个值） 127.0.0.1:6379[1]\u003e mset k1 v1 k2 v2 k3 v3 # 同时设置多个值 OK 127.0.0.1:6379[1]\u003e keys * 1) \"k1\" 2) \"k3\" 3) \"k2\" 127.0.0.1:6379[1]\u003e mget k1 k2 k3 # 同时获取多个值 1) \"v1\" 2) \"v2\" 3) \"v3\" 127.0.0.1:6379[1]\u003e mset k1 v1 k4 v4 OK 127.0.0.1:6379[1]\u003e keys * 1) \"k1\" 2) \"k4\" 3) \"k3\" 4) \"k2\" 127.0.0.1:6379[1]\u003e mget k1 k2 k3 k4 1) \"v1\" 2) \"v2\" 3) \"v3\" 4) \"v4\" 127.0.0.1:6379[1]\u003e msetnx k1 v1 k5 v5 # msetnx是一个原子性操作，要么都成功，要么都失败 (integer) 0 127.0.0.1:6379[1]\u003e keys * 1) \"k1\" 2) \"k4\" 3) \"k3\" 4) \"k2\" ####################################################### # 对象 127.0.0.1:6379[1]\u003e set user:1 {name:zhangsan,age:3} # 设置一个user:1对象，值为json字符来保存一个对象 OK 127.0.0.1:6379[1]\u003e mset user:1:name zhangsan user:1:age 3 # 这里的key是一个巧妙的设计：user:{id}:{filed}，如此设计在redis中是完全ok的 OK 127.0.0.1:6379[1]\u003e mget user:1:name user:1:age 1) \"zhangsan\" 2) \"3\" ####################################################### # getset 先get后set 127.0.0.1:6379[1]\u003e GETSET db redis # 如果不存在值，返回nil，并设置值 (nil) 127.0.0.1:6379[1]\u003e get db \"redis\" 127.0.0.1:6379[1]\u003e GETSET db mongodb # 如果存在值，返回原来的值，并做更新操作 \"redis\" 127.0.0.1:6379[1]\u003e get db \"mongodb\" ","date":"2021-03-12","objectID":"/redis-study-02/:1:1","tags":["redis"],"title":"Redis Study 02","uri":"/redis-study-02/"},{"categories":["学习"],"content":"List 列表是一种基本的数据类型 在Redis里面，我们可以把list完成，栈、队列、堵塞队列。 ####################################################### # lpush # lpop # lrange 127.0.0.1:6379[1]\u003e LPUSH list one # 将一个值或多个值，插入到列表头部 (integer) 1 127.0.0.1:6379[1]\u003e LPUSH list two (integer) 2 127.0.0.1:6379[1]\u003e LPUSH list three (integer) 3 127.0.0.1:6379[1]\u003e LRANGE list 0 -1 # 获取list中的值 1) \"three\" 2) \"two\" 3) \"one\" 127.0.0.1:6379[1]\u003e LRANGE list 0 1 # 通过区间获取具体的值 1) \"three\" 2) \"two\" 127.0.0.1:6379[1]\u003e RPUSH list right # 将一个或多个值放到列表的尾部 (integer) 4 127.0.0.1:6379[1]\u003e LRANGE list 0 -1 1) \"three\" 2) \"two\" 3) \"one\" 4) \"right\" 127.0.0.1:6379[1]\u003e LPOP list # 移除列表的第一个元素 \"three\" 127.0.0.1:6379[1]\u003e RPOP list # 移除列表的最后一个元素 \"right\" 127.0.0.1:6379[1]\u003e LRANGE list 0 -1 1) \"two\" 2) \"one\" ####################################################### # lindex # llen 127.0.0.1:6379[1]\u003e LINDEX list 0 # 通过下标获取list中的某一个值 \"two\" 127.0.0.1:6379[1]\u003e LINDEX list 1 \"one\" 127.0.0.1:6379\u003e LPUSH list one (integer) 1 127.0.0.1:6379\u003e LPUSH list two (integer) 2 127.0.0.1:6379\u003e LPUSH list three (integer) 3 127.0.0.1:6379\u003e LLEN list # 返回列表的长度 (integer) 3 ####################################################### # lrem 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"three\" 2) \"three\" 3) \"two\" 4) \"one\" 127.0.0.1:6379\u003e LREM list 1 one # 移除list集合中指定个数的value (integer) 1 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"three\" 2) \"three\" 3) \"two\" 127.0.0.1:6379\u003e LREM list 2 three (integer) 2 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"two\" ####################################################### # trim修剪 127.0.0.1:6379\u003e RPUSH mylist hello (integer) 1 127.0.0.1:6379\u003e RPUSH mylist hello1 (integer) 2 127.0.0.1:6379\u003e RPUSH mylist hello2 (integer) 3 127.0.0.1:6379\u003e RPUSH mylist hello3 (integer) 4 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"hello\" 2) \"hello1\" 3) \"hello2\" 4) \"hello3\" 127.0.0.1:6379\u003e LTRIM mylist 1 2 # 通过下标截取指定长度，这个list已经改变，只剩下截取的元素 OK 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"hello1\" 2) \"hello2\" ####################################################### # rpoplpush 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"hello1\" 2) \"hello2\" 127.0.0.1:6379\u003e RPOPLPUSH mylist myotherlist # 移动列表的最后一个元素到其他表中 \"hello2\" 127.0.0.1:6379\u003e LRANGE mylist 0 -1 # 查看原来的表 1) \"hello1\" 127.0.0.1:6379\u003e LRANGE myotherlist 0 -1 # 查看新的表 1) \"hello2\" ####################################################### # exists # lset 将列表指定下标的值，替换为另外一个值，更新操作 127.0.0.1:6379\u003e exists list # 判断列表是否存在 (integer) 0 127.0.0.1:6379\u003e lset list 0 item # 不存在，更新，报错 (error) ERR no such key 127.0.0.1:6379\u003e LPUSH list value (integer) 1 127.0.0.1:6379\u003e lset list 0 item # 存在，更新当前下标的值 OK 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"item\" 127.0.0.1:6379\u003e lset list 1 other # 列表不存在，也报错 (error) ERR index out of range ####################################################### # linsert 将某个具体的value插入列表中某个元素的前面或者后面 127.0.0.1:6379\u003e LPUSH mylist hello (integer) 1 127.0.0.1:6379\u003e LPUSH mylist world (integer) 2 127.0.0.1:6379\u003e LINSERT mylist before world other (integer) 3 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"other\" 2) \"world\" 3) \"hello\" 127.0.0.1:6379\u003e LINSERT mylist after world other1 (integer) 4 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"other\" 2) \"world\" 3) \"other1\" 4) \"hello\" 小结： list实际上是一个链表，before Node after，left，right都可以插入 如果key不存在，创建新的链表 如果key存在，新增内容 如果移除了key，空链表，也代表不存在 在两边插入或改动值，效率最高。中间元素，相对来说效率会低一点 使用场景： 消息排队 消息队列 ","date":"2021-03-12","objectID":"/redis-study-02/:1:2","tags":["redis"],"title":"Redis Study 02","uri":"/redis-study-02/"},{"categories":["学习"],"content":"Set（集合） Set中的值是不能重复的 ####################################################### # sadd # smembers # sismember 127.0.0.1:6379\u003e sadd myset \"hello\" # set集合中添加元素 (integer) 1 127.0.0.1:6379\u003e sadd myset cc (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset # 查看指定set所有值 1) \"cc\" 2) \"hello\" 127.0.0.1:6379\u003e SISMEMBER myset cc # 判断某一个值在不在set中 (integer) 1 127.0.0.1:6379\u003e SISMEMBER myset a (integer) 0 ####################################################### # scard # 获取set集合中的内容元素个数 127.0.0.1:6379\u003e scard myset # 获取set集合元素个数 (integer) 2 127.0.0.1:6379\u003e SMEMBERS myset 1) \"cc\" 2) \"hello\" 127.0.0.1:6379\u003e SADD myset cc # set 已存在元素 (integer) 0 127.0.0.1:6379\u003e SADD myset cc1 (integer) 1 127.0.0.1:6379\u003e SCARD myset (integer) 3 127.0.0.1:6379\u003e SMEMBERS myset 1) \"cc\" 2) \"hello\" 3) \"cc1\" ####################################################### # srem 移除set集合里的指定元素 127.0.0.1:6379\u003e srem myset hello (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset 1) \"cc\" 2) \"cc1\" ####################################################### # srandmember 随机抽选出几个元素 127.0.0.1:6379\u003e SRANDMEMBER myset # 随机抽选一个元素 \"cc\" 127.0.0.1:6379\u003e SRANDMEMBER myset \"cc1\" 127.0.0.1:6379\u003e SRANDMEMBER myset 2 # 随机抽选出两个元素 1) \"cc\" 2) \"cc1\" ####################################################### # spop 随机移除几个元素 127.0.0.1:6379\u003e SMEMBERS myset 1) \"cc\" 2) \"cc1\" 127.0.0.1:6379\u003e spop myset \"cc1\" 127.0.0.1:6379\u003e spop myset \"cc\" ####################################################### # smove 将指定的值移动到另一个集合 127.0.0.1:6379\u003e SMEMBERS myset 1) \"cc\" 2) \"world\" 3) \"hello\" 127.0.0.1:6379\u003e SADD myset2 set2 (integer) 1 127.0.0.1:6379\u003e smove myset myset2 cc (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset 1) \"world\" 2) \"hello\" 127.0.0.1:6379\u003e SMEMBERS myset2 1) \"cc\" 2) \"set2\" ####################################################### # 数字集合类（差集、并集、交集） 127.0.0.1:6379\u003e sadd key1 a (integer) 1 127.0.0.1:6379\u003e sadd key1 b (integer) 1 127.0.0.1:6379\u003e sadd key1 c (integer) 1 127.0.0.1:6379\u003e sadd key2 c (integer) 1 127.0.0.1:6379\u003e sadd key2 d (integer) 1 127.0.0.1:6379\u003e sadd key2 e (integer) 1 127.0.0.1:6379\u003e SDIFF key1 key2 # 差集 1) \"a\" 2) \"b\" 127.0.0.1:6379\u003e SINTER key1 key2 # 交集 共同好友实现 1) \"c\" 127.0.0.1:6379\u003e SUNION key1 key2 # 并集 1) \"a\" 2) \"b\" 3) \"c\" 4) \"e\" 5) \"d\" set是无序不重复集合，抽随机 ","date":"2021-03-12","objectID":"/redis-study-02/:1:3","tags":["redis"],"title":"Redis Study 02","uri":"/redis-study-02/"},{"categories":["学习"],"content":"Zset 在set的基础上，增加了一个值，set k1 v1，zset k2 score v2 ####################################################### zadd # 添加一个或多个值 zrange # 遍历查询 127.0.0.1:6379\u003e zadd myset 1 one (integer) 1 127.0.0.1:6379\u003e zadd myset 2 two 3 three (integer) 2 127.0.0.1:6379\u003e ZRANGE myset 0 -1 1) \"one\" 2) \"two\" 3) \"three\" ####################################################### # zrangebyscore 根据score排序 127.0.0.1:6379\u003e zset salary 2000 a (error) ERR unknown command `zset`, with args beginning with: `salary`, `2000`, `a`, 127.0.0.1:6379\u003e zadd salary 2000 a (integer) 1 127.0.0.1:6379\u003e zadd salary 5000 b (integer) 1 127.0.0.1:6379\u003e zadd salary 500 c (integer) 1 127.0.0.1:6379\u003e ZRANGEBYSCORE salary -inf +inf #显示全部用户，从小到大 1) \"c\" 2) \"a\" 3) \"b\" 127.0.0.1:6379\u003e ZRANGEBYSCORE salary -inf +inf withscores #显示全部用户并且附带成绩 1) \"c\" 2) \"500\" 3) \"a\" 4) \"2000\" 5) \"b\" 6) \"5000\" 127.0.0.1:6379\u003e ZREVRANGE salary 0 -1 withscores # 显示全部用户，从大到小 1) \"b\" 2) \"5000\" 3) \"c\" 4) \"500\" ####################################################### # zrem 移除指定元素 # zcard 获取集合中的个数 127.0.0.1:6379\u003e ZRANGEBYSCORE salary -inf +inf 1) \"c\" 2) \"a\" 3) \"b\" 127.0.0.1:6379\u003e ZREM salary a (integer) 1 127.0.0.1:6379\u003e ZRANGEBYSCORE salary -inf +inf 1) \"c\" 2) \"b\" 127.0.0.1:6379\u003e zcard salary (integer) 2 ####################################################### # zcount 获取指定区间的个数 127.0.0.1:6379\u003e zadd myset 1 hello (integer) 1 127.0.0.1:6379\u003e zadd myset 2 world 3 c (integer) 2 127.0.0.1:6379\u003e ZCOUNT myset 1 3 (integer) 3 ","date":"2021-03-12","objectID":"/redis-study-02/:1:4","tags":["redis"],"title":"Redis Study 02","uri":"/redis-study-02/"},{"categories":["学习"],"content":"Hash ####################################################### # hset set一个具体的value # hget get一个具体的value # hmset set多个具体的value # hmget get多个具体的value # hgetall get所有 # hdel 删除hash指定key字段！对应的value值也就消失了 127.0.0.1:6379\u003e hset myhash field1 c (integer) 1 127.0.0.1:6379\u003e HGET myhash field1 \"c\" 127.0.0.1:6379\u003e HMSET myhash field1 hello field2 world OK 127.0.0.1:6379\u003e HMGET myhash field1 field2 1) \"hello\" 2) \"world\" 127.0.0.1:6379\u003e HGETALL myhash 1) \"field1\" 2) \"hello\" 3) \"field2\" 4) \"world\" 127.0.0.1:6379\u003e HGETALL myhash 1) \"field2\" 2) \"world\" 3) \"field1\" 4) \"hello\" 127.0.0.1:6379\u003e HDEL myhash field1 (integer) 1 127.0.0.1:6379\u003e HGETALL myhash 1) \"field2\" 2) \"world\" ####################################################### # hlen 获取hash表的字符字段 127.0.0.1:6379\u003e hgetall myhash 1) \"field2\" 2) \"world\" 127.0.0.1:6379\u003e hlen myhash (integer) 1 ####################################################### # hexists 判断hash中指定字段是否存在 127.0.0.1:6379\u003e hgetall myhash 1) \"field2\" 2) \"world\" 127.0.0.1:6379\u003e HEXISTS myhash field2 (integer) 1 127.0.0.1:6379\u003e HEXISTS myhash field1 (integer) 0 ####################################################### # hkeys 只获得所有的field # hvals 只获得所有的value 127.0.0.1:6379\u003e HKEYS myhash 1) \"field2\" 127.0.0.1:6379\u003e HVALS myhash 1) \"world\" ####################################################### # hincrby 步长 自增 127.0.0.1:6379\u003e hset myhash field3 5 (integer) 1 127.0.0.1:6379\u003e HINCRBY myhash field3 1 (integer) 6 127.0.0.1:6379\u003e HINCRBY myhash field3 -1 (integer) 5 ####################################################### # hsetnx 没有元素则创建，有元素失败 127.0.0.1:6379\u003e HSETNX myhash field4 hello (integer) 1 127.0.0.1:6379\u003e HSETNX myhash field4 hello1 (integer) 0 map集合， key-map，本质和string类型有太大区别，还是一个简单的key-value 使用场景： hash变更数据，hash更适合对象的存储，string更适合字符串的存储 ","date":"2021-03-12","objectID":"/redis-study-02/:1:5","tags":["redis"],"title":"Redis Study 02","uri":"/redis-study-02/"},{"categories":["学习"],"content":"redis学习01","date":"2021-03-11","objectID":"/redis-study-01/","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"NoSQL的四大分类 ","date":"2021-03-11","objectID":"/redis-study-01/:1:0","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"KV键值对 新浪：Redis 美团：Redis+Tair 阿里、百度：Redis+Memecache ","date":"2021-03-11","objectID":"/redis-study-01/:1:1","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"文档型数据库 MongoDB（一般必须掌握） MongoDB是一个基于分布式文件存储的数据库，C++编写，用来处理大量文档 MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，MongoDB是非关系型数据库中功能最丰富的，最像关系型数据库的 ConthDB（国外，不需了解） ","date":"2021-03-11","objectID":"/redis-study-01/:1:2","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"列存储数据库 HBase 分布式文件系统 ","date":"2021-03-11","objectID":"/redis-study-01/:1:3","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"图关系数据库 不是存放图形，是存放关系的 Neo4j、infoGrid ","date":"2021-03-11","objectID":"/redis-study-01/:1:4","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis概述 ","date":"2021-03-11","objectID":"/redis-study-01/:2:0","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis是什么 Redis（Remote Dictionary Server）远程字典服务 是一个开源的使用C语言编写、支持网络，可基于内存亦可持久化的日志型，Key-Value的数据库，提供多种语言的API redis会周期性的把更新的数据写进磁盘或者把修改操作写入追加的记录文件，并在此基础上实现master-slave（主从）同步 ","date":"2021-03-11","objectID":"/redis-study-01/:2:1","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis能干嘛 内存存储，持久化，内存中是断点即失的，所以说持久化很重要（rdb，aof） 效率高，可以用于高速缓存 发布订阅系统 地图信息分析 计时器，计数器 。。。 ","date":"2021-03-11","objectID":"/redis-study-01/:2:2","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis特性 多样的数据类型 持久化 集群 事务 。。。 ","date":"2021-03-11","objectID":"/redis-study-01/:2:3","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"测试Redis性能 ","date":"2021-03-11","objectID":"/redis-study-01/:3:0","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"使用benchmark性能测试 使用Redis-benchmark性能测试 ","date":"2021-03-11","objectID":"/redis-study-01/:3:1","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis基础知识 ","date":"2021-03-11","objectID":"/redis-study-01/:4:0","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis基本操作命令 Redis默认有16个数据库 默认使用第0个数据库 select index，切换数据库 DBSIZE，查看当前数据库大小 keys *，查看当前数据库所有的key flushdb，清除当前数据库 flushall，清除所有数据库 set name cc，set key exists name，判断当前的key是否存在 move name，移除当前的key expire name 10，设置key的过期时间单位秒 ttl name，查看key的剩余时间 get name，获得key type name，查看key的类型 ","date":"2021-03-11","objectID":"/redis-study-01/:4:1","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis是单线程的 Redis是很快的。官方表示Redis是基于内存操作的，CPU并不是Redis的瓶颈Redis是根据机器的内存和网络带宽，可以使用单线程就使用单线程。 ","date":"2021-03-11","objectID":"/redis-study-01/:4:2","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis为什么单线程还这么快 误区1：高性能的服务器一定是多线程的 误区2：多线程（CPU上下文切换）一定比单线程效率高 核心，Redis是将所有的数据全部存放在内存中，所以使用单线程去操作效率就是最高的。多线程（CPU上下文切换：耗时操作），对于内存系统来说，没有上下文切换效率就是最高的。多次读写都是在一个CPU上，在内存情况下，这个就是最优的方案。 ","date":"2021-03-11","objectID":"/redis-study-01/:4:3","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"redis面试01","date":"2021-03-11","objectID":"/redis-interview-01/","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"概述 ","date":"2021-03-11","objectID":"/redis-interview-01/:1:0","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"什么是Redis Redis是一个使用C语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。 Redis可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持5种数据类型：字符串，列表，集合，散列表，有序集合。 与传统数据库不同的是Redis的数据是存在内存中的，所以读写速度非常快，因此Redis被广泛引用与缓存方向，每秒可以处理11万写操作，8万读操作，是已知性能最快的Key-Value DB。另外，Redis也经常用来做分布式锁。除此之外，Redis支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案。 ","date":"2021-03-11","objectID":"/redis-interview-01/:1:1","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"Redis有哪些优缺点 优点 读写性能优异，Redis能写的速度是11w次/秒，写的速度是8w次/秒 支持数据持久化，支持RDB和AOF两种持久化方式 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性操作 数据结构丰富，除了支持String类型的Value外还支持hash、set、zset、list等数据结构 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离 缺点 数据库容量容易受到物理内存限制，不能作为海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis不具备自动容错和回复功能，主机从机宕机都会导致前端部分读写请求失败，需要等待机器重启或手动切换前端的IP才能回复 主机宕机，宕机前有部分数据未及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。 Redis较难支持在线扩容，在集群容量到达上限时在线扩容会变得很复杂，为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费 ","date":"2021-03-11","objectID":"/redis-interview-01/:1:2","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"为什么要用Redis 高性能： 假如用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将用户访问的数据缓存在缓存中，这样下次再访问这些数据会直接从缓存中获取。操作缓存就是直接操作内存，所以速度相当快，如果数据库中的对应数据改变的之后，同步改变缓存中的对应数据即可。 高并发： 直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。 ","date":"2021-03-11","objectID":"/redis-interview-01/:1:3","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"为什么要用Redis而不用map/guava做缓存 缓存分为本地缓存和分布式缓存。以Java为例，使用自带的map或guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每一个实例需要各自保存一份缓存，缓存不具备一致性。 使用Redis或Memcache之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。确定需要保持redis或memcache服务的高可用，整个程序架构上较为复杂。 ","date":"2021-03-11","objectID":"/redis-interview-01/:1:4","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"Redis为什么这么快 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。 使用多路I/O复用模型，非阻塞IO。 使用底层模型不同，他们之间底层的实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定时间去移动和请求。 ","date":"2021-03-11","objectID":"/redis-interview-01/:1:5","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"数据类型 ","date":"2021-03-11","objectID":"/redis-interview-01/:2:0","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"Redis有哪些数据类型 Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求 数据类型 可以存储的值 操作 应用场景 String 字符串、整数或浮点型 对整个字符串或者字符串的其中一部分执行操作。对整数和浮点数执行自增或自减操作 做简单的键值对缓存 List 列表 从两端压入或弹出元素，对单个或多个元素进行修剪，只保留一个范围内的元素 存储一些列表型的数据结构，类似粉丝列表，文章的评论列表之类的数据 Set 无序集合 添加、获取、移除单个元素，检查一个元素是否在集合中。计算交集、并集、差集从集合里面随机获取元素 交集、并集、差集的操作，比如交集，可以把两个人的粉丝表整成一个交集 Hash 包含键值对的无序散列表 添加、获取、删除单个键值对，获取所有键值对，检查某个键是否存在 结构化的数据，比如一个对象 Zset 有序集合 添加、获取、删除元素。根据分值范围或者成员来获取元素。计算一个键的排名 去重但可以排序，如获取排名前几名的用户 ","date":"2021-03-11","objectID":"/redis-interview-01/:2:1","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"Redis的应用场景 ","date":"2021-03-11","objectID":"/redis-interview-01/:3:0","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"计数器 可以对string进行自增或自减运算，从而实现计数器功能。Redis这种内存型数据库的读写性能特别高，最适合存储频繁读写的计数量 ","date":"2021-03-11","objectID":"/redis-interview-01/:3:1","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"缓存 将热点数据放在内存中，设置内存的最大使用以及淘汰策略来保证缓存的命中率 ","date":"2021-03-11","objectID":"/redis-interview-01/:3:2","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"会话缓存 可以使用Redis来同一存储多态应用服务器的会话信息。当服务器不在存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性 ","date":"2021-03-11","objectID":"/redis-interview-01/:3:3","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"全页缓存（FPC） 除基本的会话token之外，Redis还提供很简单的FPC平台。以Megento为例，Megento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件wp-redis，这个插件可以帮助以最快速度加载已经浏览过的页面。 ","date":"2021-03-11","objectID":"/redis-interview-01/:3:4","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"查找表 例如DNS记录就很适合用Redis进行存储。查找表和缓存类似，也是利用了Redis快速查找的特性。但是查找表的内容不能失效，而缓存内容可以失效，因为缓存不作为可靠的数据来源 ","date":"2021-03-11","objectID":"/redis-interview-01/:3:5","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"消息队列（发布/订阅功能） List是一个双向链表，可以通过lpush和rpop写入和读取消息。不过最好使用kafka，RabbitMQ等消息中间件。 ","date":"2021-03-11","objectID":"/redis-interview-01/:3:6","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"分布式锁实现 在分布式场景下，无法使用单机环境下的锁对多个节点上的进程进行同步。可以使用Redis自带的SETNX命令实现分布式锁，除此之外还可以使用官方提供的RedLock分布式锁实现 ","date":"2021-03-11","objectID":"/redis-interview-01/:3:7","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"其他 Set可以实现交集、并集等操作，从而实现共同好友等功能。Zset可以实现有序性操作，从而实现排行榜的功能。 ","date":"2021-03-11","objectID":"/redis-interview-01/:3:8","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"持久化 ","date":"2021-03-11","objectID":"/redis-interview-01/:4:0","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"什么是Redis持久化 持久化就是把内存的数据写到磁盘，防止服务宕机，内存数据丢失 ","date":"2021-03-11","objectID":"/redis-interview-01/:4:1","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"Redis的持久化机制是什么？各自的优缺点？ Redis提供两种持久化机制RDB（默认）和AOF机制 RDB：是Redis DataBase缩写快照 RDB是Redis默认的持久化方式。按照一定时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期 RDB机制\u0026ldquo;RDB机制\u0026rdquo; \"\rRDB机制\r 优点： 只有一个文件dump.rdb，方便持久化 容灾性好，一个文件可以保存在安全磁盘 性能最大化，fork子进程来完成写操作，让主程序继续执行命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了Redis的高性能 相对于数据集大时，比AOF的启动效率更高 缺点 数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间Redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候 AOF（Append Only File）持久化：将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。 AOF机制\u0026ldquo;AOF机制\u0026rdquo; \"\rAOF机制\r 当两种方式同时打开时，数据恢复Redis会优先 优点： 数据安全，aof持久化可以配置appendfsync属性，有always，每进行一个命令操作就记录到aof文件中一次 通过append模式写文件，即使中途遇到宕机，也可以通过redis-check-aof工具解决数据一致性的问题 AOF机制的rewrite模式。AOF文件没被rewrite之前（文件过大会对命令进行合并或重写），可以删除其中的某些命令（比如误操作的flushall） 缺点 AOF文件比RDB文件大，且恢复速度慢 数据量大的时候，比rdb启动效率低 两者的区别 AOF文件比RDB更新频率高，优先使用AOF还原数据 AOF比RDB更安全也更大 RDB性能比AOF好 ","date":"2021-03-11","objectID":"/redis-interview-01/:4:2","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"如何选择合适的持久化方式 一般来说，如果想达到足以媲美PostgreSQL的数据安全性，应该同时使用两种持久化功能。在这种情况下，Redis重启的时候会优先载入AOF文件来恢复原始数据，因为通常情况下AOF保存的数据要比RDB文件保存的数据更完整 如果非常关心数据，但仍然可以承受数分钟内的数据丢失，可以只使用AOF持久化 许多用户只使用AOF持久化，但是不推荐这种方式，因为定时生成RDB快照非常便利于进行数据库备份，并且RDB恢复数据的速度要比AOF的速度快得多，除此之外，使用RDB还可以避免AOF程序的bug 如果只希望数据在服务器运行时存在时，可以不使用任何持久化方式。 ","date":"2021-03-11","objectID":"/redis-interview-01/:4:3","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"Redis持久化数据和缓存怎么做扩容 如果Redis被当做缓存使用，使用一致性的hash实现动态扩容缩容 如果Redis被当做一个持久化存储使用，必须使用固定的key-to-nodes映射关系，节点数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。 ","date":"2021-03-11","objectID":"/redis-interview-01/:4:4","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"mysql面试05","date":"2021-03-11","objectID":"/mysql-interview-05/","tags":["mysql"],"title":"Mysql Interview 05","uri":"/mysql-interview-05/"},{"categories":["学习"],"content":"mysql面试04","date":"2021-03-10","objectID":"/mysql-interview-04/","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"MySQL锁 ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:0","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"MVCC总结 MVCC（多版本并发控制）指的就是在使用READ COMMITTED，REPEATABLE READ这两种隔离级别的事务在执行普通的select操作时访问记录的版本链的过程。可以使不同事务的读-写，写-读操作并发执行，从而提升系统性能。READ COMMITTED、REPEATABLE READ这两个隔离级别一个很大的不同就是：生成ReadView的时机不同，READ COMMITTED是每一次进行普通SELECT操作前都会生成一次ReadView。而REPEATABLE READ只会在第一次进行普通SELECT的时候偶生成ReadView。之后的查询重复使用这个ReadView。 ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:1","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"MySQL锁的介绍 按照锁的粒度来说，MySQL主要包含三种锁：全局锁，表级锁，行级锁 全局锁，锁的是整个database，由MySQL的Sql layer层实现 表级锁，锁的是整张表，由MySQL的Sql layer层实现 行级锁，锁的是某行数据，也可能锁的是行之间的间隙，由存储引擎实现 按照锁的功能来分，可以分为共享锁和排他锁 共享锁：也称S锁，加了S锁，允许其他事务再加S锁，但是不允许其他事务加X锁。加锁方式select … lock in share mode 排他锁：也称X锁，加了X锁，不允许其他事务再加X锁或S锁。加锁方式：select … for update(delete|insert) ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:2","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"不同粒度锁的比较 表级锁：开销小，加锁快。不会出现死锁，锁定粒度大，发生锁冲突概率最高，并发度最低。 这些存储引擎通过总是一次性同时获取所有需要锁以及总是按相同顺序获取表锁避免死锁 表级锁主要适合以查询为主，并发数量少，只有少量按索引条件更新数据的应用，如WEB应用 行级锁：开销大，加锁慢。会出现死锁，锁定粒度最小，发生锁冲突概率最低，并发度也最高 最大程度支持并发，同时也带来了最大的锁开销 在InnoDB中，除单个SQL组成的事务外，锁是逐步获取的，这就决定了在InnoDB发生死锁是可能的 行级锁只是在存储引擎层实现，而MySQL服务层没有实现。行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理系统 ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:3","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"InnoDB锁模式 InnoDB实现了以下两种锁 共享锁（S）：允许一个事务去读行，阻止其他事务获得相同数据集的排他锁 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，这两种锁都是表锁 意向共享锁（IS）：事务打算个数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁 锁与锁之间如果相容，MySQL会给予锁，不相容则会阻塞。 ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:4","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"InnoDB加锁方式 意向锁是InnoDB自动加的，不需用户干预 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加共享锁或排他锁 对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显式给记录集加共享锁或排他锁： 共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。其他session仍然可以查询记录，并也可以对该记录加SHARE MODE的共享锁。但如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE。其他session可以查询该记录。但是不能对该记录加共享锁或排他锁，而是等待获得锁。 隐式锁定 InnoDB在事务执行过程中，使用两阶段锁协议： 随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自行加锁； 锁只有在执行commit或rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。 显示锁定 select … lock in share mode //共享锁 in share mode子句在作用就是将查找到的数据加上一个share锁，这个就是表示其他的事务只能进行简单的select操作，并不能够进行DML操作。 select … lock in share mode使用场景：为了确保自己查到的数据没有被其他事务正在修改，也就是确保查到的数据是最新的数据，并且不允许其他事务来修改数据。但是自己不一定能修改数据，因为有可能其他事务也对这些数据使用了in share mode的方式上了S锁 select … for update //排他锁 在执行这个select查询语句的时候，会将相应的索引访问条目进行上排他锁（X锁），也就是说这个语句对应的锁就相当于update带来的效果 select … for update 的使用场景：为了让自己查到的数据确保是最新的数据，并且查到后的数据只允许自己来修改的时候，需要用到for update子句 性能影响 select … for update语句，相当于一个UPDATE语句。在业务繁忙的情况下，如果事务没有及时的commit或rollback可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。 select … lock in share mode语句是给一个查找语句上一个共享锁（S）的功能，它允许其他事务也对该事务上S锁，但是不能够允许对数据进行修改。如果不及时的commit或rollback也可能造成大量的事务等待。 InnoDB行锁实现方式 InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL和Oracle完全不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只用通过索引条件检索数据，InnoDB才使用行锁，否则InnoDB将使用表锁。 不论是主键索引，唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁 只有在执行计划中真正使用了索引，才能使用行锁：即使在条件中使用了索引字段，但是否使用索引来检索数据是有MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，MySQL就不会使用索引，这种情况下InnoDB将使用表锁，而不是使用行锁。因此在分析锁冲突的时候可以检查SQL的执行计划（可以通过explain检查SQL的执行计划），已确认是否真正使用了索引。 ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:5","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"乐观锁和悲观锁 悲观锁是指在数据处理过程中是数据处于锁定状态。在MySQL中使用悲观锁，必须关闭MySQL自动提交，set autocommit = 0，MySQL默认使用自动提交模式，即使你执行一个更新操作，MySQL会自动将结果提交。 select … for update 是MySQL提供实现悲观锁的方式。执行后该数据将被锁定，直到获得该锁的事务提交或回滚后，锁才能释放。其他要执行该数据的事务才能执行。 乐观锁相对于悲观锁来说，一般来说是不会造成冲突，所以只有在数据提交更新的时候，才会正式对数据的冲突与否进行检测。如果发现冲突了，则让返回错误信息，让用户决定如何去做。 利用数据版本号（version）机制是乐观锁最常用的一种实现方式，一般通过为数据库添加一个version字段，当读取数据的时候，将version字段的数据一同读出，数据每更新一次，对此version值+1。当提交更新的时候，判断数据库对应的当前的版本信息是否与第一次去出来的版本信息相等，相等则予以更新，不相等认为是过期的数据，返回更新失败。 ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:6","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"mysql面试03","date":"2021-03-09","objectID":"/mysql-interview-03/","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"MySQL索引 ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:0","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"MySQL目前主要有以下几种索引类型 普通索引 最基本的索引，没有任何限制，有以下几种创建方式： 直接创建索引 CREATE INDEX index_name ON table(column(length)) 修改表结构的方式添加索引 ALTER TABLE table_name ADD INDEX index_name ON (column(length)) 创建表的时候同时创建索引 CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` char(255) CHARACTER NOT NULL, `content` TEXT CHARACTER NULL, `time` int(10) NULL DEFAULT NULL, PRIMARY KEY (`id`), INDEX index (title(length)) ) 删除索引 DROP INDEX index_name ON table 唯一索引 与前面的普通索引类似。不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一，有以下几种创建方式 创建唯一索引 CREATE UNIQUE INDEX index_name ON table(column(length)) 修改表结构 ALTER TABLE table_name ADD UNIQUE index_name ON table(column(length)) 创建表的时候直接指定 CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` char(255) CHATACTER NOT NULL, `content` text CHARACTER NULL, `time` int(10) NULL DEFAULT NULL, UNIQUE indexName (title(length)) ) 主键索引 是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值，一般建表的时候同时创建主键索引 CREATE TABLE `table` ( `id` int(10) NOT NULL AUTO_INCREMENT, `title` char(255) NOT NULL, PRIMARY KEY (`id`) ) 组合索引 多个字段上创建索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用，使用组合索引遵循最左前缀集合 ALTER TABLE `table` ADD INDEX city_name_age(city, name, age) 全文索引 主要用来查找文本中的关键字，而不是直接与索引中的值进行比较。fulltext（全文索引）跟其他索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where+like。它可以在create table，alter table，create index使用。不过目前只用char，varchar，text列上可以创建全文索引。值得一提的是，在数据量比较大的时候，先将数据放入一个没有全文索引的表中，然后再用CREATE index创建fulltext（全文索引），要比先为一张表建立fulltext全文索引然后再将数据写入快得多。 创建表的时候添加全文索引 CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` char(255) CHARACTER NOT NULL, `content` text CHARACTER NULL, `time` int(10) NULL DEFAULT NULL, PRIMARY KEY (`id`), FULLTEXT (content) ) 修改表结构添加全文索引 ALTER TABLE table ADD FULLTEXT index_content(content) 直接创建索引 CREATE FULLTEXT INDEX index_content ON table(content) ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:1","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"缺点 虽然索引大大提高了查询速度，同时会降低表的更新速度，如对表进行delete，update，insert。因为更新表时，不仅要保存数据，还要保存一下索引文件。 建立索引会建立占用磁盘空间的索引文件。一般这个问题不太严重，但如果在一个大表上创建多种组合索引，索引文件会增长很快。 索引只是提高效率的一个因素，如果有大数据量的表，就需要花时间研究建立优秀索引，或优化查询语句。 ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:2","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"注意事项 索引不会包含有null值的列。只要列中包含null值豆浆不会被包含在索引中，复合索引中只要有一列含有null值，那么这一列对于索引就是无效的。所以在设计数据库的时候尽量不要让字段的默认值为null。 使用短索引 对串列进行索引，如果可能就指定一个前缀长度。例如：一个char(255)的列，如果在前10个或20个字符内，多数值是唯一的，那么就不需要对整列进行索引。短索引不仅可以提高查询速度还可以节省磁盘空间和I/O操作。 索引列排序 查询只用一个索引，因此如果where已经使用了索引，那么order by就不会在使用索引。因此数据库默认排序符合可以符合要求的情况下不要使用排序操作。尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。 like语句操作 一般情况下不推荐使用like，如果非使用不可，如何使用也是一个问题，like“%aaa%”不会使用索引而like“aaa%”可以使用索引。 不要在列上进行运算 这将导致索引失效而进行全表扫描，例如 SELECT * FROM table_name WHERE YEAR(column_name) \u003c 2017 不使用not in和\u003c\u003e操作 ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:3","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"mysql索引类型normal，unique，fulltext的区别是什么 normal：表示普通索引 unique：表示唯一的，不允许出现重复的索引，如果该字段信息不会出现重复。例如使用身份证号作为索引，可以设置为unique fulltext：表示全文搜索的索引，fulltext用于搜索很长一片文章的时候，效果最好。如果就一两行字，使用普通的index也可以。 总结，索引的类别由建立索引的字段内容特性来决定，通常normal最常见。 ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:4","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"实际操作中，应选取表中哪些字段作为索引 建立索引上有7大原则： 选择唯一性索引 为经常需要排序、分组和联合操作的字段建立索引 为常作为查询条件的字段建立索引 限制索引数目 尽量使用数据量小的索引 尽量使用前缀来索引 删除不再使用或很少使用的索引 ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:5","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"聚集索引和非聚集索引区别 聚集索引一个表只有一个，非聚集索引一个表可以有多个 聚集索引存储记录在物理上是连续存在的，而非聚集索引在逻辑上是连续的，物理存储并不连续 ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:6","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"mysql面试02","date":"2021-03-09","objectID":"/mysql-interview-02/","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"事务的四大特性（ACID）原子性，一致性，隔离性，持久性？ ","date":"2021-03-09","objectID":"/mysql-interview-02/:1:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"原子性 根据定义，原子性是指一个事务是一个不可分割的工作单位，其中操作要么都做，要么都不做。不存在中间状态。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:1:1","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"一致性 根据定义一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:1:2","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"隔离性 根据定义，隔离性是指多个事务并发执行时，事务内部操作和其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:1:3","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"持久性 根据定义，持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来其他操作或故障不应该对其有任何影响。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:1:4","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"数据库隔离级别，每个级别会引发什么问题，mysql默认是什么级别的 ","date":"2021-03-09","objectID":"/mysql-interview-02/:2:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"脏读 脏读是指在一个事务中读到另一个未提交事务的数据。 当一个事务正在多次修改某个数据而这个事务中多次修改都尚未提交，此时另一个并发事务来访问该数据，就会造成两个事务得到的数据不一致。 举个例子：A在一个转账事务中，转了100给B，此时，B读到了这个转账数据，然后做了一些操作（发货给A或其他操作），可这个时候A的事务并没有提交，如果A回滚了事务，就会发生数据问题。这就是脏读。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:2:1","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"不可重复读 不可重复读是指对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据。这是由于在查询间隔，被另一个事务修改并提交了。 例如：事务T1读取某一数据，而事务T2马上修改数据并提交给数据库，事务T1再次读取就得到了不同的结果，发生了不可重复读。 不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，不可重复读则是读取了前一事务提交的数据 ","date":"2021-03-09","objectID":"/mysql-interview-02/:2:2","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"幻读 幻读是指事务非独立执行时发生的一种现象。 例如：事务T1对一个表中的所有的行的某一数据做了从1修改为2的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项还是1并且提交给了数据库。而事务T1如果再次查看刚刚修改的数据，会发现还有一行未修改，其实这行是T2添加的，就好像产生了幻觉。这就是幻读。 幻读和不可重复读的区别，幻读和不可重复读都是读取另一个以提交的事务（这点就和脏读不同），不同的是，不可重复读查询的都是同一个数据项，而幻读是针对一批数据整体（比如数据个数） ","date":"2021-03-09","objectID":"/mysql-interview-02/:2:3","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MySQL提供的四种隔离模式 Serializable（串行化）：可以避免脏读，不可重复读和幻读的发生。 Repeatable read（可重复读）：可以避免脏读，不可重复读的发生。 Read committed（读已提交）：可避免脏读的发生。 Read uncommitted（读未提交）：最低级别，都无法避免。 以上四种模式最高是Serializable级别，最低是Read uncommitted级别。级别越高效率越低。像是Serializable这样的级别就是以锁表的方式使得其他事务只能在锁外等待。MySQL数据库默认的级别为Read committed ","date":"2021-03-09","objectID":"/mysql-interview-02/:2:4","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别 ","date":"2021-03-09","objectID":"/mysql-interview-02/:3:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"InnoDB 支持事务，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大优势。如果需要频繁的更新，删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback） ","date":"2021-03-09","objectID":"/mysql-interview-02/:3:1","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MyISAM 插入数据快，空间和内存使用比较低。如果表主要是用于插入新数据和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性和并发性要求比较低，也可以使用。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:3:2","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MEMORY 所有数据都在内存中，数据的处理快，但是安全性不高，如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMORY。其对表的大小有所要求，不能建立太大的表。所以这类数据库只使用在相对较小的数据库表。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:3:3","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MySQL的MyISAM和InnoDB两种存储引擎在事务、锁级别，各自的使用场景 ","date":"2021-03-09","objectID":"/mysql-interview-02/:4:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MyISAM特点 不支持行锁（MyISAM只有表锁），读取时对需要读到的所有表进行加锁，写入时则对表加排它锁 不支持事务 不支持外键 不支持崩溃后安全修复 在表有读取查询时，支持往表中插入新数据 支持BLOG和TEXT的前500个字符索引，支持全文索引 支持延时更新索引，极大的提升写入性能 对于不会进行修改的表，支持压缩表，极大的减少对磁盘空间的占用 ","date":"2021-03-09","objectID":"/mysql-interview-02/:4:1","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"InnoDB特点 支持行锁，采用MVCC来支持高并发，有可能死锁 支持事务 支持外键 支持崩溃后的安全修复 不支持全文索引 ","date":"2021-03-09","objectID":"/mysql-interview-02/:4:2","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"各自的使用场景 MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询时，那么MyISAM是更好的选择。 InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。 但是实际场景中，针对具体问题具体分析，一般遵循以下几个问题？ 数据库是否有外键 是否需要事务支持 是否需要全文索引 数据库经常使用什么查询模式？在写多读少的应用中还是InnoDB插入性能更稳定，在并发情况下也基本，如果是对读取速度要求比较快的应用还是选MyISAM 数据库的数据大小？大尺寸倾向与InnoDB，因为有事务日志，故障修复 ","date":"2021-03-09","objectID":"/mysql-interview-02/:4:3","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"SQL查询语句（where，join，limit，group by，having）执行先后顺序 一个查询语句同时出现以上关键词时执行顺序是： 执行where xxx对全表数据做筛选，返回第一个结果集 针对第一个结果集使用group by分组，返回第二个结果集 针对第二个结果集中的每一组数据执行select xxx，有几组就执行几次，返回第三个结果集 针对第三个结果集执行having xxx进行筛选，返回第四个结果集 针对第四个结果集排序 总结一个顺序：我（W）哥（G）是（SH）偶（O）像（W-\u003eG-\u003eS-\u003eH-\u003eO） ","date":"2021-03-09","objectID":"/mysql-interview-02/:5:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"什么是临时表，临时表什么时候删除 ","date":"2021-03-09","objectID":"/mysql-interview-02/:6:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"什么是临时表 MySQL用于存储一些中间结果集的表，临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:6:1","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"为什么会产生临时表 一般是由于复杂的SQL导致临时表被大量创建 ","date":"2021-03-09","objectID":"/mysql-interview-02/:6:2","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"临时表的分类 临时表分为两种，一种是内存临时表，一种是磁盘临时表。内存临时表采用的是MEMORY存储引擎，磁盘临时表采用的是MyISAM存储引擎（磁盘临时表也可以使用InnoDB存储引擎，通过参数来控制使用那种存储引擎，从MySQL5.7.6版本后默认为InnoDB存储引擎，之前版本一直默认的是MyISAM存储引擎） ","date":"2021-03-09","objectID":"/mysql-interview-02/:6:3","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"下面操作会使用到临时表 union查询 对于视图操作，比如使用一些TEMPTABLE算法，union或aggregation 子查询 join包括not in，exist等 查询产生的派生表 复杂的group by或order by insert，select同一个表，mysql会产生一个临时表缓存select行 多个表更新 GROUP_CONCAT()或COUNT(DISTINCT) ","date":"2021-03-09","objectID":"/mysql-interview-02/:6:4","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MySQL以下操作会阻止内存临时表的建立，直接使用磁盘临时表 表含有BLOG或TEXT列 使用union或union all时，select子句有大于512字节的列 Show columns或desc表时，有LOB或TEXT GROUP BY或DISTINCY子句中包含列大于512字节的列 ","date":"2021-03-09","objectID":"/mysql-interview-02/:6:5","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MySQL B+Tree索引和Hash索引的区别 ","date":"2021-03-09","objectID":"/mysql-interview-02/:7:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"区别 由于Hash索引结构的特殊性，其检索效率特别高，索引的检索可以一次定位，不想B-Tree索引需要从根节点到枝节点，最后才能访问到叶节点这样多次访问，所以Hash索引的查询效率是要远高于B-Tree索引 ","date":"2021-03-09","objectID":"/mysql-interview-02/:7:1","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"为何采用B-Tree而不采用Hash 任何事物都有两面性，Hash索引也一样，虽然Hash索引效率高，但是Hash索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些 Hash索引仅仅能满足于“=”，“in”和“\u003c=\u003e”查询，不能使用范围查询。 由于Hash索引比较的是Hash运算之后的Hash值，所以只能使用等值过滤，不能用于基于范围的过滤，因为经过相应的Hash算法处理后的Hash值的大小关系，并不能保证和Hash运算前完全一样 Hash索引无法用来避免数据的排序操作。 由于Hash索引中存放是经过Hash计算之后的Hash值，而且Hash值的大小关系还不一定和Hash运算之前的键值完全一样，所以数据库无法通过索引的数据来避免任何排序运算 Hash索引不能利用部分索引键查询 对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用。 Hash索引在任何时候都不能避免表扫描 Hash索引是将索引键通过Hash运算后，将Hash运算结果和所对应的指针信息存放在一个Hash表中由于不同的索引键中存在相同的Hash值，所以即使满足某个Hash键值数据的记录条数也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。 Hash索引遇到大量Hash值相等的情况后性能就不一定比B-Tree高 对于选择性较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样会浪费多次表数据访问，造成整体性能低下。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:7:2","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"mysql面试01","date":"2021-03-08","objectID":"/mysql-interview-01/","tags":["mysql"],"title":"Mysql Interview 01","uri":"/mysql-interview-01/"},{"categories":["学习"],"content":"drop、delete和truncate分别在什么场景下使用？对比一下区别 ","date":"2021-03-08","objectID":"/mysql-interview-01/:1:0","tags":["mysql"],"title":"Mysql Interview 01","uri":"/mysql-interview-01/"},{"categories":["学习"],"content":"drop table 属于DDL 不可回滚 不可带where 表内容结构删除 删除速度快 ","date":"2021-03-08","objectID":"/mysql-interview-01/:1:1","tags":["mysql"],"title":"Mysql Interview 01","uri":"/mysql-interview-01/"},{"categories":["学习"],"content":"truncate table 属于DDL 不可回滚 不可带where 表内容删除 速度快 ","date":"2021-03-08","objectID":"/mysql-interview-01/:1:2","tags":["mysql"],"title":"Mysql Interview 01","uri":"/mysql-interview-01/"},{"categories":["学习"],"content":"delete from 属于DML 可回滚 可带where 表结构在，表内容看具体where 删除速度慢 ","date":"2021-03-08","objectID":"/mysql-interview-01/:1:3","tags":["mysql"],"title":"Mysql Interview 01","uri":"/mysql-interview-01/"},{"categories":["学习"],"content":"使用场景 不再需要一张表的时候，使用drop 想删除部分数据行时候，使用delete，并且带上where子句 想保留表结构而删除所有数据时，使用truncate ","date":"2021-03-08","objectID":"/mysql-interview-01/:1:4","tags":["mysql"],"title":"Mysql Interview 01","uri":"/mysql-interview-01/"},{"categories":["学习"],"content":"mysql优化01","date":"2021-03-08","objectID":"/mysql-optimize-01/","tags":["mysql"],"title":"Mysql Optimize 01","uri":"/mysql-optimize-01/"},{"categories":["学习"],"content":"优化的方面 表设计 范式 存储引擎 字段类型 功能 索引 缓存 分区 sql语句 合理的sql 经验 架构 主从复制 负载均衡 读写分离 ","date":"2021-03-08","objectID":"/mysql-optimize-01/:1:0","tags":["mysql"],"title":"Mysql Optimize 01","uri":"/mysql-optimize-01/"},{"categories":["生活"],"content":"简历","date":"2021-03-07","objectID":"/resume/","tags":["简历"],"title":"Resume","uri":"/resume/"},{"categories":["生活"],"content":"陈进煌 ","date":"2021-03-07","objectID":"/resume/:1:0","tags":["简历"],"title":"Resume","uri":"/resume/"},{"categories":["生活"],"content":"个人信息 性别：男 年龄：24 手机号：18759882615 邮箱：2219316464@qq.com 专业：计算机科学与技术 应聘岗位：Golang开发工程师 ","date":"2021-03-07","objectID":"/resume/:2:0","tags":["简历"],"title":"Resume","uri":"/resume/"},{"categories":["生活"],"content":"工作及教育经历 厦门美城行动科技有限公司 2019-08~至今 软件研发部-后端开发 厦门青叶软件股份有限公司 2019-03~2019-07 软件研发部-后端开发 厦门通元微智能科技有限公司 2018-03~2018~11 软件研发部-软件测试 三明学院 2014-09~2018-07 计算机科学与技术 ","date":"2021-03-07","objectID":"/resume/:3:0","tags":["简历"],"title":"Resume","uri":"/resume/"},{"categories":["生活"],"content":"专业技能 掌握Golang，了解Java，C++，C等编程语言 掌握基础数据结构和算法的基本原理 等等 ","date":"2021-03-07","objectID":"/resume/:4:0","tags":["简历"],"title":"Resume","uri":"/resume/"},{"categories":["生活"],"content":"项目经历 厦门美城行动管理系统 后端开发 2019-08~至今 项目介绍：这个项目是公司的后台管理系统。该系统主要是对公司对应的小程序和app提供数据的统计展示和管理等。系统后端是采用beego框架，数据库使用mysql，部分功能使用到redis进行缓存。系统前端采用react框架，大部分使用antdesign的UI组件。 我的职责： 根据实际业务需求，与产品经理确定具体功能及展现方式。 依据具体功能进行数据表的设计。 实现具体功能编写管理系统前端展示代码，与产品进行确认。 根据前端界面确定后台的接口，进行后台代码数据操作代码的编写。 若小程序，app有该功能相关的，为其提供相应的接口。 提交Git，交付测试进行测试。 根据测试提交的bug对代码进行调试修改。 主要实现功能： 考试模块 这个功能实现功能如下： 1、题库管理，在题库中对试卷题目，答案等进行数据操作。 2、试卷管理，编辑试卷名称等具体信息，从题库中筛选题目，从用户列表中筛选用户参与该试卷考试。 3、分数排行榜，对试卷分数进行统计，排行及数据展示。 功能难点： 1、用户小程序上提交试卷后展示考试成绩 2、试卷修改时，用户提交过的试卷内容不变 难点解决： 1、使用redis对答案数据进行缓存，用户提交后根据试卷id获取对应缓存数据，进行对比，统计分数并返回。 2、将用户提交的试卷数据序列化进行保存，展示时再反序列化。 ","date":"2021-03-07","objectID":"/resume/:5:0","tags":["简历"],"title":"Resume","uri":"/resume/"},{"categories":["实例"],"content":"Go Instance 12-排序","date":"2021-03-03","objectID":"/go-instance-12/","tags":["golang"],"title":"Go Instance 12","uri":"/go-instance-12/"},{"categories":["实例"],"content":"sort自带排序 Go 的 sort 包实现了内置和用户自定义数据类型的排序功能 package main import ( \"fmt\" \"sort\" ) func main() { //排序方法是正对内置数据类型的；这里是一个字符串的例子。 // 注意排序是原地更新的，所以他会改变给定的序列并且不返回一个新值。 strs := []string{\"c\", \"b\", \"d\", \"a\"} sort.Strings(strs) fmt.Println(strs) //一个 int 排序的例子。 ints := []int{4,2,3,1} sort.Ints(ints) fmt.Println(ints) //我们也可以使用 sort 来检查一个序列是不是已经是排好序的。 sorted := sort.IntsAreSorted(ints) fmt.Println(sorted) } ","date":"2021-03-03","objectID":"/go-instance-12/:1:0","tags":["golang"],"title":"Go Instance 12","uri":"/go-instance-12/"},{"categories":["实例"],"content":"使用函数自定义排序 使用和集合的自然排序不同的方法对集合进行排序。例如按字母的长度而不是首字母顺序对字符串排序。 package main import ( \"fmt\" \"sort\" ) //为了在Go中使用自定义函数进行排序，需要定义一个对应类型 //这里创建一个为内置[]string类型的别名ByLength类型 type ByLength []string //在类型中实现了sort.Interface 的Len，Less，Swap方法 //这样就可以使用sort包内通用的Sort方法了，Len和Swap通常在各个类型中差不多 //Less将控制实际的自定义排序逻辑 //在这个例子中按字符串的长度来进行排序，所以这里用到了len(s[i])和len(s[j]) func (s ByLength) Len() int { return len(s) } func (s ByLength) Less(i int, j int) bool { return len(s[i]) \u003c len(s[j]) } func (s ByLength) Swap(i int, j int) { s[i], s[j] = s[j], s[i] } func main() { //将原始的fruits转型成ByLength来实现自定义排序 //然后对这个转型的切片使用sort.Sort方法 fruits := []string{\"peach\", \"banana\", \"kiwi\"} sort.Sort(ByLength(fruits)) fmt.Println(fruits) } ","date":"2021-03-03","objectID":"/go-instance-12/:2:0","tags":["golang"],"title":"Go Instance 12","uri":"/go-instance-12/"},{"categories":["实例"],"content":"Go Instance 11-Go协程状态","date":"2021-02-28","objectID":"/go-instance-11/","tags":["golang"],"title":"Go Instance 11","uri":"/go-instance-11/"},{"categories":["实例"],"content":"Go协程状态 在前面的例子中，我们用互斥锁进行了明确的锁定来让共享的state 跨多个 Go 协程同步访问。另一个选择是使用内置的 Go协程和通道的的同步特性来达到同样的效果。这个基于通道的方法和 Go 通过通信以及 每个 Go 协程间通过通讯来共享内存，确保每块数据有单独的 Go 协程所有的思路是一致的。 package main import ( \"fmt\" \"math/rand\" \"sync/atomic\" \"time\" ) //在这个例子中，state将被一个单独的协程拥有 //这就能保证数据在并行读取时不会混乱，为了对state进行读取或写入 //其他Go协程将发送一条数据到拥有的Go协程中，然后接受对应的回复 //结构体readOp和writeOp封装这些状态，并且是拥有Go协程响应的一个方式 type readOp struct { key int resp chan int } type writeOp struct { key int value int resp chan bool } func main() { //计算执行操作的次数 var ops int64 = 0 //reads和writes通道分别将被其他Go协程用来发布读和写请求 reads := make(chan *readOp) writes := make(chan *writeOp) //这个就是拥有state的协程。这个协程的state是私有的 //这个Go协程反复响应到达的请求 //先响应到达的请求，然后返回一个值到响应通道resp表示操作成功 go func() { var state = make(map[int]int) for { select { case read := \u003c- reads: read.resp \u003c- state[read.key] case write := \u003c- writes: state[write.key] = write.value write.resp \u003c- true } } }() //启动100个协程通过reads通道发起对state所有者Go协程的读取请求 //每个读取请求需要构建一个readOp，发送它到reads通道中，并通过给定的resp接收结果 for i := 0; i \u003c 100; i++ { go func() { for { read := \u0026 readOp{ key: rand.Intn(5), resp: make(chan int), } reads \u003c- read \u003c- read.resp atomic.AddInt64(\u0026ops, 1) } }() } //用相同的方法启动10个写操作 for i := 0; i \u003c 10; i++ { go func() { for { write := \u0026writeOp{ key: rand.Intn(5), value: rand.Intn(100), resp: make(chan bool), } writes \u003c- write \u003c- write.resp atomic.AddInt64(\u0026ops, 1) } }() } //让Go协程先跑1秒 time.Sleep(time.Second) //最后获取并显示ops值 opsfinal := atomic.LoadInt64(\u0026ops) fmt.Println(opsfinal) } ","date":"2021-02-28","objectID":"/go-instance-11/:1:0","tags":["golang"],"title":"Go Instance 11","uri":"/go-instance-11/"},{"categories":["实例"],"content":"Go Instance 10-原子计数器，互斥锁","date":"2021-02-28","objectID":"/go-instance-10/","tags":["golang"],"title":"Go Instance 10","uri":"/go-instance-10/"},{"categories":["实例"],"content":"原子计数器 Go中最主要的状态管理方法是通过通道之间的通信完成的。在工作池的例子中有遇到，但是还是有一些其他方式来管理状态。如何使用sync/atomic包在多个Go协程中进行原子计数 package main import ( \"fmt\" \"runtime\" \"sync/atomic\" \"time\" ) //原子计数器 func main() { //使用一个无符号整型(永远是正整数)来代表这个计数器 var ops uint64 = 0 //为了模拟并发更新，启动50个协程，对计数器每个1毫秒进行一次加一操作 for i := 0; i \u003c 50; i++ { go func() { for { //使用AddUint64来让计数器自动增加，使用\u0026语法来抛出ops内存地址 atomic.AddUint64(\u0026ops, 1) //允许其他Go协程执行 runtime.Gosched() } }() } //等待1秒,让Go协程有时间运行 time.Sleep(time.Second) //在计数器还在被其他Go协程更新时,安全的使用 //通过LoadUint将当前值拷贝到opsfinal //LoadUint64 需要的是内存地址 opsfinal := atomic.LoadUint64(\u0026ops) fmt.Println(opsfinal) } ","date":"2021-02-28","objectID":"/go-instance-10/:1:0","tags":["golang"],"title":"Go Instance 10","uri":"/go-instance-10/"},{"categories":["实例"],"content":"互斥锁 相较于简单的原子计数器，对于更复杂的情况，可以使用一个互斥锁在Go协程里安全的访问数据 package main import ( \"fmt\" \"math/rand\" \"runtime\" \"sync\" \"sync/atomic\" \"time\" ) func main() { //在这个例子中state是一个map var state = make(map[int]int) //这里的mutex将同步对mutex的访问 var mutex = \u0026sync.Mutex{} //为了比较基于互斥锁的处理方式和其他方式，ops将记录对state的操作次数 var ops int64 = 0 //运行100Go协程同时读取state for i := 0; i \u003c 100; i++ { go func() { total := 0 for { //每次循环读取，使用一个键进行访问 //Lock()这个mutex来确保对state的独占访问，读取选定键的值 //Unlock()这个state并使ops+1 key := rand.Intn(5) //fmt.Println(\"key:\", key) mutex.Lock() total += state[key] mutex.Unlock() atomic.AddInt64(\u0026ops, 1) //为了确保这个Go协程不会在调度中饿死 //每次操作后明确使用runtime.Gosched()进行释放 //这个释放一般是自动处理的，例如每个通道操作后或者time.Sleep的阻塞调用后相似 //但在这个例子中需要手动处理 runtime.Gosched() } }() } //运行10个Go协程来模拟写操作，使用和读取相同模式 for i := 0; i \u003c 10; i++ { go func() { for { key := rand.Intn(5) value := rand.Intn(100) mutex.Lock() state[key] = value mutex.Unlock() atomic.AddInt64(\u0026ops, 1) runtime.Gosched() } }() } //让这10个Go协程对state和mutex的操作运行1秒 time.Sleep(time.Second) //获取并输出最终操作数 opsFinal := atomic.LoadInt64(\u0026ops) fmt.Println(\"ops:\", opsFinal) //对state使用一个最终锁，显示是如何结束的 mutex.Lock() fmt.Println(state) mutex.Unlock() } ","date":"2021-02-28","objectID":"/go-instance-10/:2:0","tags":["golang"],"title":"Go Instance 10","uri":"/go-instance-10/"},{"categories":["实例"],"content":"Go Instance 09-速率限制","date":"2021-02-27","objectID":"/go-instance-09/","tags":["golang"],"title":"Go Instance 09","uri":"/go-instance-09/"},{"categories":["实例"],"content":"速率限制 速率限制(英) 是一个重要的控制服务资源利用和质量的途径。Go 通过 Go 协程、通道和打点器优美的支持了速率限制。 package main import ( \"fmt\" \"time\" ) func main() { //基本速率限制 //如果想限制接收请求处理，可以将这些请求发送到一个相同通道 requests := make(chan int, 5) for i := 1; i \u003c= 5; i++ { requests \u003c- i } close(requests) //这个tick通道将每200毫秒接收一个值，这个是速率限制任务中的管理器 tick := time.Tick(time.Millisecond * 200) //通过在每次请求前阻塞tick通道的一个接收，限制每隔200毫秒接收一个值 for row := range requests { \u003c-tick fmt.Println(\"request:\", row, time.Now()) } //有时候想临时进行速率限制，并且不影响整体速率控制可以使用通道缓冲来实现 //burstyLimter通道用来进行3次临时的脉冲型速率限制 burstyLimter := make(chan time.Time, 3) //将需要临时改变值传入 for i := 0; i \u003c 3; i++ { burstyLimter \u003c- time.Now() } //每个200毫秒添加一个新值到通道内，直到达到3个限制 go func() { for t := range time.Tick(time.Millisecond * 200) { burstyLimter \u003c- t } }() //现在模拟5个接入请求 //刚开始3个受临时的脉冲影响 burstyRequests := make(chan int, 5) for i := 0; i \u003c 5; i++ { burstyRequests \u003c- i } close(burstyRequests) for row := range burstyRequests { \u003c- burstyLimter fmt.Println(\"request2: \", row, time.Now()) } } 运行程序，将看到第一批请求意料之中的大约每 200ms 处理一次。第二批请求，我们直接连续处理了 3 次，这是由于这个“脉冲”速率控制，然后大约每 200ms 处理其余的 2 个。 ","date":"2021-02-27","objectID":"/go-instance-09/:1:0","tags":["golang"],"title":"Go Instance 09","uri":"/go-instance-09/"},{"categories":["实例"],"content":"Go Instance 08-模拟工作池","date":"2021-02-26","objectID":"/go-instance-08/","tags":["golang"],"title":"Go Instance 08","uri":"/go-instance-08/"},{"categories":["实例"],"content":"工作池 在这个例子中，将看到如何使用GO协程和通道实现一个工作池 package main import ( \"fmt\" \"time\" ) //这是将要在多个并发实例中支持的任务 //这些执行者将从jobs通道接收任务，并通过results发送对应结果 //让每个任务睡1秒，模拟耗时任务 func worker(i int, jobs \u003c-chan int, results chan\u003c- int) { for j := range jobs{ fmt.Printf(\"worker %d processing job %d \\n\", i, j ) time.Sleep(time.Second) results \u003c- j } } func main() { //使用worker工作池并收集结果，需要两个通道 jobs := make(chan int, 100) results := make(chan int, 100) //这里启动三个worker，初始是阻塞的，因为还没有任务 for i := 1; i \u003c= 3; i++ { go worker(i, jobs, results) } //发送9个任务，然后close表示这些就是所有任务了 for i := 1; i \u003c= 9; i++ { jobs \u003c- i } close(jobs) //收集所有任务的返回值 for i := 1; i \u003c= 9; i++ { \u003c-results } } 执行这个程序，显示9个任务被多个worker执行。整个程序处理所有任务仅执行了3秒，因为是3个worker并行的 ","date":"2021-02-26","objectID":"/go-instance-08/:1:0","tags":["golang"],"title":"Go Instance 08","uri":"/go-instance-08/"},{"categories":["实例"],"content":"Go Instance 07-Go定时器和打点器","date":"2021-02-25","objectID":"/go-instance-07/","tags":["golang"],"title":"Go Instance 07","uri":"/go-instance-07/"},{"categories":["实例"],"content":"定时器 当需要在后面一个时刻运行Go代码，或者在某段时间内重复运行。Go内置的定时器和打点器让这些很容易实现 package main import ( \"fmt\" \"time\" ) func main() { //定时器表示在未来某一时刻的独立事件 //提供定时器需要的时间，定时器将提供一个用于通知的通道 //这里设置定时器将等待2秒 timer1 := time.NewTimer(time.Second * 2) //\u003c-timer1.C 直到这个定时器的通道C明确的发送了定时器失效的值之前，一直阻塞 \u003c-timer1.C fmt.Println(\"Timer 1 expired\") //如果需要的仅仅是等待，可以使用Sleep //定时器有用的原因之一是可以在定时器失效前取消定时器 timer2 := time.NewTimer(time.Second * 2) go func() { \u003c- timer2.C fmt.Println(\"Timer 2 expired\") }() stop := timer2.Stop() if stop { fmt.Println(\"Timer 2 stop\") } } 第一个定时器将在程序开始后2秒失效，第二个在其还没失效前就被停止了 ","date":"2021-02-25","objectID":"/go-instance-07/:1:0","tags":["golang"],"title":"Go Instance 07","uri":"/go-instance-07/"},{"categories":["实例"],"content":"打点器 定时器是当你想要在未来某一时刻执行一次时使用，打点器是当你想要在固定的时间间隔重复执行准备的。这是一个打点器的例子，它将定时执行，直到我们将它停止 package main import ( \"fmt\" \"time\" ) func main() { //打点器和定时器的机制有点相似：一个通道用来发送数据。 // 这里我们在这个通道上使用内置的 range 来迭代值每隔500ms 发送一次的值。 ticker := time.NewTicker(time.Millisecond * 500) go func() { for t := range ticker.C { fmt.Println(\"Tick at \", t) } }() //打点器可以和定时器一样被停止。一旦一个打点停止了，将不能再从它的通道中接收到值。 // 我们将在运行后 1600ms停止这个打点器。 time.Sleep(time.Millisecond * 1000) ticker.Stop() fmt.Println(\"Ticker stopped\") } ","date":"2021-02-25","objectID":"/go-instance-07/:2:0","tags":["golang"],"title":"Go Instance 07","uri":"/go-instance-07/"},{"categories":["生活"],"content":"学习进度","date":"2021-02-25","objectID":"/learning-process/","tags":["我的"],"title":"Learning Process","uri":"/learning-process/"},{"categories":["生活"],"content":"狂神说java java零基础学习视频通俗易懂(p27) ","date":"2021-02-25","objectID":"/learning-process/:1:0","tags":["我的"],"title":"Learning Process","uri":"/learning-process/"},{"categories":["生活"],"content":"Tears-Tearing Google资深工程师带你通关golang/go语言(p43) ","date":"2021-02-25","objectID":"/learning-process/:2:0","tags":["我的"],"title":"Learning Process","uri":"/learning-process/"},{"categories":["生活"],"content":"崔永华csdn博客 单元测试案例 学习go语言必备案例(4) ","date":"2021-02-25","objectID":"/learning-process/:3:0","tags":["我的"],"title":"Learning Process","uri":"/learning-process/"},{"categories":["实例"],"content":"Go Instance 06-defer+recover解决panic","date":"2021-02-23","objectID":"/go-instance-06/","tags":["golang"],"title":"Go Instance 06","uri":"/go-instance-06/"},{"categories":["实例"],"content":"defer+recover解决panic导致程序崩溃 ","date":"2021-02-23","objectID":"/go-instance-06/:1:0","tags":["golang"],"title":"Go Instance 06","uri":"/go-instance-06/"},{"categories":["实例"],"content":"案例1 如果我们起了一个协程，但这个协程出现了panic，但我们没有捕获这个协程，就会造成程序的崩溃，这时可以在goroutine中使用recover来捕获panic，进行处理，这样主线程不会受到影响 package main import ( \"fmt\" \"time\" ) func sayhello() { for i := 0; i \u003c 10; i++ { fmt.Println(\"hello\") time.Sleep(time.Second) } } func test() { //使用defer+recover defer func() { //捕获test抛出的panic if err := recover(); err != nil { fmt.Println(\"test 发生错误：\", err) } }() var myMap map[int]string myMap[0] = \"golang\" } func main() { go sayhello() go test() for i := 0; i \u003c 10; i++ { fmt.Println(\"main() ok=\", i) time.Sleep(time.Second) } } ","date":"2021-02-23","objectID":"/go-instance-06/:1:1","tags":["golang"],"title":"Go Instance 06","uri":"/go-instance-06/"},{"categories":["实例"],"content":"Go Instance 05-select解决通道堵塞","date":"2021-02-23","objectID":"/go-instance-05/","tags":["golang"],"title":"Go Instance 05","uri":"/go-instance-05/"},{"categories":["实例"],"content":"使用select解决从管道取数据堵塞问题 使用select解决从管道取数据堵塞的问题，语法如下： select语法\u0026ldquo;select语法\u0026rdquo; \"\rselect语法\r package main import ( \"fmt\" \"time\" ) func main() { //定义一个管道，可以放10个int类型数据 intChan := make(chan int, 10) for i := 0; i \u003c 10; i++ { intChan \u003c- i } //定义一个管道，可以放5个string类型数据 stringChan := make(chan string, 5) for i := 0; i \u003c 5; i++ { stringChan \u003c- \"hello\" + fmt.Sprintf(\"%d\", i) } //传统的方法遍历管道时，如果不关闭会阻塞而导致deadlock //实际开发中，不好确定什么时候关闭通道 //这时可以使用select方式解决 //label for { select { //管道不关闭不会deadlock，会自动到下一个case匹配 case v := \u003c-intChan: fmt.Printf(\"从intChan读取的数据%d\\n\", v) time.Sleep(time.Second) case v := \u003c-stringChan: fmt.Printf(\"从stringChan读取的数据%v\\n\", v) time.Sleep(time.Second) default: fmt.Printf(\"取不到数据\\n\") time.Sleep(time.Second) return //break label } } } ","date":"2021-02-23","objectID":"/go-instance-05/:1:0","tags":["golang"],"title":"Go Instance 05","uri":"/go-instance-05/"},{"categories":["实例"],"content":"Go Instance 04-goroutine和channel","date":"2021-02-23","objectID":"/go-instance-04/","tags":["golang"],"title":"Go Instance 04","uri":"/go-instance-04/"},{"categories":["实例"],"content":"goroutine和channel ","date":"2021-02-23","objectID":"/go-instance-04/:1:0","tags":["golang"],"title":"Go Instance 04","uri":"/go-instance-04/"},{"categories":["实例"],"content":"goroutine和channel协同工作 具体要求 开启一个writeData协程，向管道intChan中写入50个整数 开启一个readData协程，从管道intChan中读取writeData写入的数据 注意writeData和readData操作的是同一个管道 主线程需要等待writeData和readData协程都完成工作才能退出管道 思路分析 思路分析\u0026ldquo;思路分析\u0026rdquo; \"\r思路分析\r package main import \"fmt\" func writeData(intChan chan int) { for i := 1; i \u003c= 50; i++ { intChan \u003c-i fmt.Println(\"write:\", i) } close(intChan) } func readData(intChan chan int, exitChan chan bool) { for { n, ok := \u003c-intChan if !ok { break } fmt.Println(\"read:\", n) } exitChan \u003c- true close(exitChan) } func main() { intChan := make(chan int, 50) exitChan := make(chan bool, 1) go writeData(intChan) go readData(intChan, exitChan) for { _, ok := \u003c-exitChan if !ok { break } } } 读和写频率不一样也没有问题 package main import ( \"fmt\" \"time\" ) func writeData(intChan chan int) { for i := 0; i \u003c 50; i++ { intChan \u003c- i fmt.Println(\"write:\", i) } close(intChan) } func readData(intChan chan int, exitChan chan bool) { for { v, ok := \u003c-intChan if !ok { break } time.Sleep(time.Second) fmt.Println(\"read:\", v) } exitChan \u003c- true close(exitChan) } func main() { intChan := make(chan int, 10) exitChan := make(chan bool, 1) go writeData(intChan) go readData(intChan, exitChan) for { if _, ok := \u003c-exitChan; !ok{ break } } } 注意：如果只向管道写入数据而没有读取，就会造成堵塞而deadlock ","date":"2021-02-23","objectID":"/go-instance-04/:1:1","tags":["golang"],"title":"Go Instance 04","uri":"/go-instance-04/"},{"categories":["学习"],"content":"Go Study 15-channel","date":"2021-02-22","objectID":"/go-study-15/","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"channel ","date":"2021-02-22","objectID":"/go-study-15/:1:0","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"channel ","date":"2021-02-22","objectID":"/go-study-15/:1:1","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"buffered channel(带缓冲区的channel) ","date":"2021-02-22","objectID":"/go-study-15/:1:2","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"range(关闭channel) ","date":"2021-02-22","objectID":"/go-study-15/:1:3","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"理论基础Communication Sequential Process(CSP) ","date":"2021-02-22","objectID":"/go-study-15/:1:4","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-22","objectID":"/go-study-15/:2:0","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"channel(通道) 通道是连接多个Go协程的管道，可以从一个Go协程将值发送到通道，然后在别的Go协程中接收 package main import ( \"fmt\" ) func channel1() { //使用make(chan val-type)创建一个新的通道 //通道类型就是传递值的类型 message := make(chan string) //使用 channel \u003c- 语法发送一个新的值到通道中 go func() { message \u003c- \"ping\" }() fmt.Println(message) //使用 \u003c- channel 语法从通道中获取一个值 msg := \u003c- message fmt.Println(msg) } func main() { channel1() } 运行程序时，通过通道，消息“ping”成功的从一个Go协程传到另一个。默认发送和接收操作是阻塞的，直到发送方和接收方都准备完毕。这个特性允许不使用任何其他的同步操作，可以在程序结尾等待消息“ping” ","date":"2021-02-22","objectID":"/go-study-15/:2:1","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"通道缓冲 默认通道是无缓冲的，这意味着只有在对应的接收(\u003c-chan)通道准备好接收时才允许发送(chan\u003c-)。可缓冲通道允许在没有接收方的情况下，缓存限定数量的值 package main import ( \"fmt\" ) func channel2() { //这里make了一个通道，最多允许缓存2个值 message := make(chan string, 2) //因为这个通道有缓冲区，即使没有一个对应的并发接收方，也可以继续发送 message \u003c- \"buffered\" message \u003c- \"channel\" //接收时，也可以接收两个值 fmt.Println(\u003c-message) fmt.Println(\u003c-message) } func main() { channel2() } ","date":"2021-02-22","objectID":"/go-study-15/:2:2","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"通道同步 可以使用通道来同步Go协程间的执行状态。这里使用阻塞的接收方式来等待一个Go协程的运行结束 package main import ( \"fmt\" \"time\" ) func channel3() { //创建一个缓存为1的bool类型通道 done := make(chan bool, 1) //运行一个worker Go协程，并给予用于通知的通道 go worker(done) //程序将在接收到通道中worker发出的通知前一直阻塞 \u003c-done } //这是一个我们将要在 Go 协程中运行的函数。 // done 通道将被用于通知其他 Go 协程这个函数已经工作完毕 func worker(done chan bool) { fmt.Println(\"working...\") time.Sleep(time.Second) fmt.Println(\"done\") //发送一个值来通知完工啦。 done \u003c- true } func main() { channel3() } 如果将done \u003c- true这行代码从程序中移除，程序甚至会在worker还没开始运行就结束 ","date":"2021-02-22","objectID":"/go-study-15/:2:3","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"通道方向 当使用通道作为函数参数时，可以指定通道是不是只用来接收或发送值。这个特性提升了程序的类型安全性 package main import ( \"fmt\" ) func channel4() { pings := make(chan string, 1) pongs := make(chan string, 1) ping(pings, \"message\") pong(pings, pongs) fmt.Println(\u003c-pongs) } //ping函数定义一个只允许发送数据的通道 //尝试使用这个函数来接收数据会得到一个编译时错误 func ping(pings chan\u003c- string, str string) { pings \u003c- str } //pong函数允许通道pings接收函数，通道pongs发送函数 func pong(pings \u003c-chan string, pongs chan\u003c- string) { msg := \u003c-pings pongs \u003c- msg } func main() { channel4() } ","date":"2021-02-22","objectID":"/go-study-15/:2:4","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"通道选择器 Go的通道选择器可以同时等待多个通道操作。Go协程和通道以及选择器的结合是Go的一个强大特性 package main import ( \"fmt\" \"time\" ) func main() { //创建2个通道，从这两个选择 c1 := make(chan string, 1) c2 := make(chan string, 1) //c1通道在1秒后接收值，这个模拟Go协程中阻塞的RPC操作 go func() { time.Sleep(time.Second) c1 \u003c- \"one\" }() //c2通道在2秒后接收值 go func() { time.Sleep(time.Second * 2) c2 \u003c- \"two\" }() //使用select关键字来同时等待这两个值，并打印各自的值 for i :=0; i \u003c 2; i++ { select { case msg := \u003c-c1: fmt.Println(msg) case msg := \u003c-c2: fmt.Println(msg) } } } 注意两个协程并发运行，程序总共仅运行2秒左右 ","date":"2021-02-22","objectID":"/go-study-15/:2:5","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"超时处理 超时对于一个连接外部资源，或者其他一些需要花费执行时间操作的程序而言是很重要的。得益于通道和select，在Go中实现超时操作是简洁而优雅的 package main import ( \"fmt\" \"time\" ) func main() { //在这个例子中，执行一个外部调用，在2秒后通过通道c1返回执行结果 c1 := make(chan string, 1) go func() { time.Sleep(time.Second * 2) c1 \u003c- \"result 1\" }() //使用select实现超时操作 //result := \u003c-c1等待结果，\u003c-Time.After等待超时1秒后发送的值 //由于select默认处理第一个已准备好的接收操作，如果这个操作超过允许的1秒的话，将会执行超时case select { case result := \u003c- c1: fmt.Println(result) case \u003c-time.After(time.Second * 1): fmt.Println(\"result1 超时\") } //执行一个外部调用，2秒后通过通道c2返回执行结果 c2 := make(chan string, 1) go func() { time.Sleep(time.Second * 2) c2 \u003c- \"result 2\" }() //将超时延长至3秒，如果操作小于3秒将执行result输出case select { case result := \u003c-c2: fmt.Println(result) case \u003c-time.After(time.Second * 3): fmt.Println(\"result2超时\") } } 运行程序，首先显示运行超时的操作，然后是成功接收的。使用select超时方式需要使用通道传递结果。这对于一般情况是个好方式，因为其他重要的Go特性是基于通道和select的 ","date":"2021-02-22","objectID":"/go-study-15/:2:6","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"非阻塞式通道操作 常规的通过通道发送和接收数据是阻塞的。然而，可以使用带default子句select来实现非阻塞的发送、接收，甚至是非阻塞的多路select package main import \"fmt\" //这是一个非阻塞接收的例子 func main() { message := make(chan string, 1) signal := make(chan string, 1) //如果message有值存在，select将值传到msg中 //如果不存在直接执行default select { case msg := \u003c-message: fmt.Println(\"received message:\", msg) default: fmt.Println(\"no message receives\") } //这个非阻塞方法，如果msg成功向message传值，执行case //否则执行default msg := \"hi\" select { case message \u003c- msg: fmt.Println(\"sent message:\", msg) default: fmt.Println(\"no message sent\") } signal \u003c- \"world\" //可以在default前使用多个case子句实现一个多路的非阻塞的选择器 //这里尝试在message和signal上同时使用非阻塞的接收操作 //如果case1和case2都满足，只执行case1 select { case msg := \u003c-message: fmt.Println(\"receives message:\", msg) case sign := \u003c-signal: fmt.Println(\"receives signal:\", sign) default: fmt.Println(\"no activity\") } } ","date":"2021-02-22","objectID":"/go-study-15/:2:7","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"通道的关闭 关闭一个通道意味着不能再向这个通道发送值了。这个特性可以用来给这个通道接收方传达工作已经完成的消息 package main import \"fmt\" func main() { //在这个例子中，将使用一个jobs通道来传递main()中Go协程任务执行的结果信息到一个工作Go协程中 //当没有多余任务给这个工作Go协程时，可以close这个jobs通道 job := make(chan int, 5) done := make(chan bool, 1) //这是工作Go协程，使用j, more := \u003c-job循环从job接收数据 //在接收的这个特殊的二值形式的值中，如果job已经关闭，并且通道中的所有值都已经接收完毕 //那么more的值将是false。当完成所有任务时，将使用这个特性通过done通道去进行通知 go func() { for { j, more := \u003c-job if more { fmt.Println(\"received job:\", j) } else { fmt.Println(\"received all jobs\") done \u003c- true return } } }() //这里使用job发送3个任务到工作函数中，然后关闭job for i := 1; i \u003c= 3; i++ { job \u003c- i fmt.Println(\"sent job:\", i) } close(job) fmt.Println(\"sent all job\") //使用通道同步方法等待任务结束 \u003c-done } ","date":"2021-02-22","objectID":"/go-study-15/:2:8","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"通道遍历 可以使用range语法来遍历从通道中取得的值。一个非空通道是可以关闭的，但是通道中的值仍然可以被接收到 package main import \"fmt\" func main() { //遍历在queue通道中的两个值 queue := make(chan string, 2) queue \u003c- \"one\" queue \u003c- \"two\" close(queue) //这个range迭代从queue中得到的每个值 //因为close了通道，这个通道会在接收完第二个值后结束 //如果没有close，那么这个循环将继续阻塞执行，等待接收第三个值 for elem := range queue { fmt.Println(elem) } } ","date":"2021-02-22","objectID":"/go-study-15/:2:9","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["实例"],"content":"Go Instance 03-字符操作","date":"2021-02-22","objectID":"/go-instance-03/","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"字符操作 ","date":"2021-02-22","objectID":"/go-instance-03/:1:0","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"案例1 统计一个文本文件的字符个数 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) //定义一个结构体保存统计结果 type charCount struct { //英文个数 chCount int //空格个数 spaceCount int //数字个数 numCount int //其他个数 otherCount int } func main() { /** 思路：打开一个文件，创建一个Reader 每读取一行，统计字符保存到结构体中 */ file, err := os.Open(\"fileOperations/abc.txt\") if err != nil { fmt.Println(\"file open err:\", err) } reader := bufio.NewReader(file) fileC := charCount{} //循环读取file内容 for { s, err := reader.ReadString('\\n') //为了兼容中文转化为rune for _, r := range []rune(s) { switch { case r \u003e= 'a' \u0026\u0026 r \u003c= 'z': fallthrough case r \u003e= 'A' \u0026\u0026 r \u003c= 'Z': fileC.chCount++ case r \u003e '0' \u0026\u0026 r \u003c '9': fileC.numCount++ case r == ' ' || r == '\\t': fileC.spaceCount++ default: fileC.otherCount++ } } if err == io.EOF { break } } fmt.Printf(\"file has chcount: %d, numcount: %d, spaceCount: %d, otherCount: %d\", fileC.chCount, fileC.numCount, fileC.spaceCount, fileC.otherCount) } ","date":"2021-02-22","objectID":"/go-instance-03/:1:1","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"将数据序列化成json字符串 ","date":"2021-02-22","objectID":"/go-instance-03/:2:0","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"将数据(结构体，Map，Slice，基础数据类型)序列化成json字符串 json序列化是指将有key-value结构的数据类型(比如：结构体，Map，Slice)序列化成json字符串的操作 package main import ( \"encoding/json\" \"fmt\" ) type Hero struct { Name string `json:\"hero_name\"` Age int `json:\"hero_age\"` Sex string } //结构体序列化 func changeStruct() { hero := Hero{ Name: \"小陈\", Age: 18, Sex: \"男\", } //将结构体序列化 bytes, err := json.Marshal(hero) if err != nil{ fmt.Println(\"json marshal fail:\", err) } fmt.Printf(\"结构体序列化后的字段：%v\\n\", string(bytes)) } //Map序列化 func changeMap() { map1 := make(map[string]interface{}) map1[\"name\"] = \"张无忌\" map1[\"age\"] = 22 map1[\"address\"] = \"冰火岛\" //将map序列化 bytes, err := json.Marshal(map1) if err != nil { fmt.Println(\"json marshal fail:\", err) } fmt.Printf(\"Map序列化后的字段：%v\\n\", string(bytes)) } //Slice序列化 func changeSlice() { var slice []map[string]interface{} m1 := make(map[string]interface{}) m1[\"name\"] = \"张无忌\" m1[\"age\"] = 25 m1[\"address\"] = \"冰火岛\" slice = append(slice, m1) m2 := make(map[string]interface{}) m2[\"name\"] = \"张三丰\" m2[\"age\"] = \"88\" m2[\"address\"] = []string{\"武当山\", \"夏威夷\"} slice = append(slice, m2) //slice序列化 bytes, err := json.Marshal(slice) if err != nil { fmt.Println(\"json marshal fail:\", err) } fmt.Printf(\"Slice序列化后的字段：%v\\n\", string(bytes)) } //基本类型序列化(对基础类型序列化意义不大) func changeFloat() { var f float64 = 3.14 //对float序列化 bytes, err := json.Marshal(f) if err != nil { fmt.Println(\"json marshal fail:\", err) } fmt.Println(\"Float序列化后的字段：\", string(bytes)) } func main() { changeStruct() changeMap() changeSlice() changeFloat() } ","date":"2021-02-22","objectID":"/go-instance-03/:2:1","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"将json字符串反序列化成对应数据 ","date":"2021-02-22","objectID":"/go-instance-03/:3:0","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"将json字符串 反序列化成对应数据（比如：结构体，map，切片） package main import ( \"encoding/json\" \"fmt\" ) type Hero struct { Name string `json:\"hero_name\"` Age int `json:\"hero_age\"` Sex string } //将json字符串反序列化为结构体 func unmarshalStruct() { str := \"{\\\"hero_name\\\":\\\"小陈\\\",\\\"hero_age\\\":18,\\\"Sex\\\":\\\"男\\\"}\" var hero Hero err := json.Unmarshal([]byte(str), \u0026hero) if err != nil { fmt.Println(\"json unmarshal fail:\", err) } fmt.Printf(\"json反序列化为结构体：%v\\n\", hero) } //将json字符串反序列化为Map func unmarshalMap() { str := \"{\\\"name\\\": \\\"张无忌\\\",\\\"age\\\": 22,\\\"address\\\": \\\"冰火岛\\\"}\" //定义一个map，反序列化的时候不需要make，因为unmarshal封装了make var map1 map[string]interface{} err := json.Unmarshal([]byte(str), \u0026map1) if err != nil { fmt.Println(\"json unmarshal fail:\", err) } fmt.Printf(\"json反序列化为Map：%v\\n\",map1) } //将json字符串反序列化为Slice func unmarshalSlice() { str := \"[{\\\"address\\\":\\\"冰火岛\\\",\\\"age\\\":25,\\\"name\\\":\\\"张无忌\\\"},{\\\"address\\\":[\\\"武当山\\\",\\\"夏威夷\\\"],\\\"age\\\":\\\"88\\\",\\\"name\\\":\\\"张三丰\\\"}]\" //定义一个slice，反序列化的时候不需要make，因为unmarshal封装了make var slice []map[string]interface{} err := json.Unmarshal([]byte(str), \u0026slice) if err != nil { fmt.Println(\"json unmarshal fail:\", err) } fmt.Printf(\"json反序列化为Slice：%v\\n\", slice) } func main() { unmarshalStruct() unmarshalMap() unmarshalSlice() } ","date":"2021-02-22","objectID":"/go-instance-03/:3:1","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"Go Instance 02-文件操作","date":"2021-02-22","objectID":"/go-instance-02/","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"读取文件 ","date":"2021-02-22","objectID":"/go-instance-02/:1:0","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例1 读取文件的内容并显示在终端(带缓冲区的方式) package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) //读取文件的内容并显示在终端(带缓冲区的方式) func main() { //打开文件 file, err := os.Open(\"fileOperations/abc.txt\") if err != nil { fmt.Println(\"文件打开失败\") } //函数退出时关闭文件 defer file.Close() //输出文件 fmt.Printf(\"file=%v \\n\", \u0026file) //创建一个*Reader，带缓冲的，默认缓冲区大小为4096 reader := bufio.NewReader(file) //循环读取文件内容 for { //读到一个换行结束 s, err := reader.ReadString('\\n') //输出文件内容 fmt.Print(s) //io.EOF表示文件末尾 if err == io.EOF { fmt.Println() break } } fmt.Println(\"文件读取结束\") } ","date":"2021-02-22","objectID":"/go-instance-02/:1:1","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例2 对于文件不太大的情况，可以使用ioutil一次将整个文件读到内存里 package main import ( \"fmt\" \"io/ioutil\" ) //对于文件不太大的情况，可以使用ioutil一次将整个文件读到内存里 func main() { //打开文件 file, err := ioutil.ReadFile(\"fileOperations/abc.txt\") if err != nil { fmt.Println(\"open file err:\", err) } //把读取到的文件显示在终端 //不需要显式的Open和Close文件，因为这两个操作已经被封装在ioutilFile函数内部 fmt.Printf(\"file is %v\\n\", file) fmt.Printf(\"file is %v\\n\", string(file)) } ","date":"2021-02-22","objectID":"/go-instance-02/:1:2","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"写入文件 ","date":"2021-02-22","objectID":"/go-instance-02/:2:0","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例1 创建一个新文件写入5句hello package main import ( \"bufio\" \"fmt\" \"os\" ) //创建一个新文件写入5句hello func main() { //打开文件，可写可创建 file, err := os.OpenFile(\"fileOperations/write.txt\", os.O_WRONLY|os.O_CREATE, 0666) if err != nil{ fmt.Printf(\"open file err: %v\\n\", err) } //函数退出关闭文件 defer file.Close() //写入文件，使用带缓存的*writer writer := bufio.NewWriter(file) for i := 0; i \u003c 5; i++ { writer.WriteString(\"hello\\n\") } //Flush将缓存的文件真正写入到文件中 writer.Flush() fmt.Println(\"文件写入成功\") } ","date":"2021-02-22","objectID":"/go-instance-02/:2:1","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例2 打开已有文件追加内容 package main import ( \"bufio\" \"fmt\" \"os\" ) //打开已有文件追加内容 func main() { //打开文件，文件可写可以追加 file, err := os.OpenFile(\"fileOperations/write.txt\", os.O_APPEND|os.O_WRONLY, 0666) if err != nil { fmt.Println(\"file is err\", err) } //函数最后关闭文件 defer file.Close() //写入文件，使用带缓存的*writer writer := bufio.NewWriter(file) for i := 0; i \u003c 5; i++ { writer.WriteString(\"abc \\r\\n\") } //Flush将缓存文件真正写入到文件中 writer.Flush() } ","date":"2021-02-22","objectID":"/go-instance-02/:2:2","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例3 打开一个存在的文件读取内容并追加内容 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) //打开一个存在的文件读取内容并追加内容 func main() { //打开文件，可读可写可追加 file, err := os.OpenFile(\"fileOperations/write.txt\", os.O_APPEND|os.O_RDWR, 0666) if err != nil { fmt.Println(\"file open err:\", err) } //函数结束关闭文件 defer file.Close() //读取文件 reader := bufio.NewReader(file) for{ s, err := reader.ReadString('\\n') fmt.Print(s) if err == io.EOF { break } } //写入文件 writer := bufio.NewWriter(file) for i := 0; i \u003c 5; i++ { writer.WriteString(\"hello world\\n\") } writer.Flush() } ","date":"2021-02-22","objectID":"/go-instance-02/:2:3","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例4 将一个文件内容复制到另一个文件中 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) //将一个文件内容复制到另一个文件中 func main() { os.OpenFile(\"fileOperations/writecopy.txt\", os.O_CREATE|os.O_WRONLY, 0666) file, err := ioutil.ReadFile(\"fileOperations/write.txt\") if err != nil { fmt.Println(\"file1 open err:\", err) } err = ioutil.WriteFile(\"fileOperations/writecopy.txt\", file, 0666) if err != nil { fmt.Println(\"file2 copy err\", err) } } ","date":"2021-02-22","objectID":"/go-instance-02/:2:4","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"拷贝文件 ","date":"2021-02-22","objectID":"/go-instance-02/:3:0","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例1 将一个图片拷贝到另一个文件下 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) //编写一个函数，传入两个文件路径 func copyFile(dstFile string, srcFile string) (written int64, err error) { //打开srcFile read, err := os.OpenFile(srcFile, os.O_RDONLY, 0) if err != nil { fmt.Println(\"srcFile open err:\", err) } defer read.Close() //通过srcFile找到 reader reader := bufio.NewReader(read) //打开dstFile write, err := os.OpenFile(dstFile, os.O_WRONLY|os.O_CREATE, 0666) if err != nil { fmt.Println(\"dstFile open err:\", err) } defer write.Close() //通过dstFile找到writer writer := bufio.NewWriter(write) return io.Copy(writer, reader) } func main() { //将srcFile文件拷贝到dstFile文件 srcFile := \"F:/hugo-blog/cc/static/go7.jpg\" dstFile := \"D:/bgird.jpg\" //调用copyFile完成拷贝 written, err := copyFile(dstFile, srcFile) if err != nil { fmt.Println(\"copy file err:\", err) } else { fmt.Println(\"copy file success, written:\", written) } } ","date":"2021-02-22","objectID":"/go-instance-02/:3:1","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["学习"],"content":"Go Study 14-goroutine","date":"2021-02-21","objectID":"/go-study-14/","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"goroutine ","date":"2021-02-21","objectID":"/go-study-14/:1:0","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"协程Coroutine 轻量级“线程” 非抢占式多任务处理，由协程主动交出控制权 编译器/解释器/虚拟机层面的多任务 多个协程可能在一个或多个线程上运行 coroutine\u0026ldquo;coroutine\u0026rdquo; \"\rcoroutine\r ","date":"2021-02-21","objectID":"/go-study-14/:1:1","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"goroutine的定义 任何函数只需加上go就能送给调度器运行 不需要在定义时区分是否是异步函数 调度器会在合适的点进行切换 使用-race来检测数据访问冲突 goroutine\u0026ldquo;goroutine\u0026rdquo; \"\rgoroutine\r ","date":"2021-02-21","objectID":"/go-study-14/:1:2","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"goroutine可能的切换点 I/O，select channel 等待锁 函数调用(有时) runtime.Gosched() 以上只是参考，不能保证切换，不能保证在其他地方不切换 ","date":"2021-02-21","objectID":"/go-study-14/:1:3","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-21","objectID":"/go-study-14/:2:0","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"协程 Go协程在执行上来说是轻量级的线程 package main import \"fmt\" func f(s string) { for i := 0; i \u003c 3; i++ { fmt.Println(s) } } //Go协程在执行上来说是轻量级的线程 func main() { //使用一般方式运行f函数 f(\"direct\") //使用go f(s)在一个Go协程中调用这个函数 //这个新的Go协程会并行的执行这个函数的调用 go f(\"gorouting\") //为匿名函数启动一个Go协程 go func(msg string) { for i := 0; i \u003c 10; i++ { fmt.Println(msg) } }(\"going\") //现在这两个Go协程在独立的Go协程中异步运行，所以需要等他们结束 //Scanln代码，我们在程序退出前按下任意键结束 var in string fmt.Scanln(\u0026in) fmt.Println(\"done\") } 当运行这个程序时，将先看见阻塞式调用，然后是两个go协程交替输出，这种交替输出表示Go运行时是以异步方式运行协程的 ","date":"2021-02-21","objectID":"/go-study-14/:2:1","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"Go Study 13-测试","date":"2021-02-21","objectID":"/go-study-13/","tags":["golang"],"title":"Go Study 13","uri":"/go-study-13/"},{"categories":["学习"],"content":"测试 testing.T的应用 运行测试 ","date":"2021-02-21","objectID":"/go-study-13/:1:0","tags":["golang"],"title":"Go Study 13","uri":"/go-study-13/"},{"categories":["学习"],"content":"代码覆盖率 使用IDE查看代码覆盖 使用go test获取代码覆盖报告 使用go tool cover查看代码覆盖报告 ","date":"2021-02-21","objectID":"/go-study-13/:1:1","tags":["golang"],"title":"Go Study 13","uri":"/go-study-13/"},{"categories":["学习"],"content":"性能测试 testing.B的使用 ","date":"2021-02-21","objectID":"/go-study-13/:1:2","tags":["golang"],"title":"Go Study 13","uri":"/go-study-13/"},{"categories":["学习"],"content":"使用pprof进行性能调优 终端进入项目目录下 go test -bench . -cpuprofile cpu.out生成cpu.out go tool pprof cpu.out查看cpu.out 在交互式命令行输入web进行查看 ","date":"2021-02-21","objectID":"/go-study-13/:1:3","tags":["golang"],"title":"Go Study 13","uri":"/go-study-13/"},{"categories":["学习"],"content":"案例","date":"2021-02-21","objectID":"/go-study-13/:2:0","tags":["golang"],"title":"Go Study 13","uri":"/go-study-13/"},{"categories":["面试"],"content":"Go Interview 01-new与make的区别","date":"2021-02-20","objectID":"/go-interview-01/","tags":["golang"],"title":"Go Interview 01","uri":"/go-interview-01/"},{"categories":["面试"],"content":"new和make的定义 func new(Type) *Type func make(t Type, size ...IntegerType) Type 其中Type代表一个数据类型 ","date":"2021-02-20","objectID":"/go-interview-01/:1:0","tags":["golang"],"title":"Go Interview 01","uri":"/go-interview-01/"},{"categories":["面试"],"content":"二者的区别 ","date":"2021-02-20","objectID":"/go-interview-01/:2:0","tags":["golang"],"title":"Go Interview 01","uri":"/go-interview-01/"},{"categories":["面试"],"content":"返回值 从定义中可以看出，new返回的是指向Type的指针，make直接返回的是Type类型值 ","date":"2021-02-20","objectID":"/go-interview-01/:2:1","tags":["golang"],"title":"Go Interview 01","uri":"/go-interview-01/"},{"categories":["面试"],"content":"入参 new只有一个Type参数，Type可以是任意数据类型。make可以有多个参数，但是只能是slice，map或者chan中的一种。对于不同类型，size参数说明如下： 对于slice,第一个size表示长度，第二个size表示容量，且容量不能小于长度。如果省略第二个size，默认容量等于长度。 对于map，会根据size大小分配资源，以足够存储size个元素。如果省略size，会默认分配一个小的起始size 对于chan，size表示缓冲区容量。如果省略size，channel为无缓冲channel ","date":"2021-02-20","objectID":"/go-interview-01/:2:2","tags":["golang"],"title":"Go Interview 01","uri":"/go-interview-01/"},{"categories":["面试"],"content":"分配类型 new：用来分配内存，主要用来分配值类型 make：用来分配内存，主要用来分配引用类型 ","date":"2021-02-20","objectID":"/go-interview-01/:2:3","tags":["golang"],"title":"Go Interview 01","uri":"/go-interview-01/"},{"categories":["实例"],"content":"Go Instance 01-豆瓣爬虫","date":"2021-02-19","objectID":"/go-instance-01/","tags":["golang"],"title":"Go Instance 01","uri":"/go-instance-01/"},{"categories":["实例"],"content":"使用Go爬取豆瓣电影排行榜 package main import ( \"encoding/json\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"regexp\" \"strings\" ) func main() { data, err := GetHtml(\"https://movie.douban.com/chart\") if err != nil { fmt.Println(\"获取源代码失败:\", err) return } //创建文件 file, err := os.Create(\"movie.json\") if err != nil { fmt.Println(\"创建文件失败:\", err) return } encoder := json.NewEncoder(file) encoder.SetIndent(\" \", \" \") encoder.Encode(GetItem(data)) } func GetHtml(url string) ([]byte, error) { var clent http.Client req, err := http.NewRequest(\"GET\", url, nil) if err != nil { fmt.Println(\"创建请求失败:\", err) return nil, err } //添加请求头，才能访问到需要的网页源码 req.Header.Add(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36 Edg/85.0.564.51\") resp, err := clent.Do(req) if err != nil { fmt.Println(\"请求失败:\", err) return nil, err } data, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(\"读取失败:\", err) return nil, err } defer resp.Body.Close() return data, nil } type Item struct { Link string `json:\"link\"` Name string `json:\"name\"` Info string `json:\"info\"` Rate string `json:\"rate\"` RateNum string `json:\"rate_num\"` } func GetItem(data []byte) []Item { //正则匹配需要的内容 pattern := regexp.MustCompile(`(?s)\u003cdiv.*?class=\"pl2\".*?\u003e.*?\u003ca href=\"(.*?)\".*?\u003e(.*?)/.*?\u003cspan.*?\u003c/span\u003e.*?\u003cp class=\"pl\"\u003e(.*?)\u003c/p\u003e.*?\u003cdiv.*?\u003e.*?\u003cspan class=\"rating_nums\"\u003e(.*?)\u003c/span\u003e.*?\u003cspan class=\"pl\"\u003e\\((.*?)\\)\u003c/span\u003e.*?\u003c/div\u003e`) //查找网页中所有的匹配项 items := pattern.FindAllSubmatch(data, -1) var res []Item for _, item := range items { res = append(res, Item{ Link: string(item[1]), Name: strings.TrimSpace(string(item[2])), Info: string(item[3]), Rate: string(item[4]), RateNum: string(item[5]), }) } return res } ","date":"2021-02-19","objectID":"/go-instance-01/:1:0","tags":["golang"],"title":"Go Instance 01","uri":"/go-instance-01/"},{"categories":["学习"],"content":"Go Study 12-资源管理与出错处理","date":"2021-02-18","objectID":"/go-study-12/","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"defer调用 确保调用在函数结束时发生 多defer相当于栈(先进后出) 参数在defer语句时计算 ","date":"2021-02-18","objectID":"/go-study-12/:1:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"何时使用defer调用 Open/Close Lock/Unlock PrintHeader/PrintFooter ","date":"2021-02-18","objectID":"/go-study-12/:2:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"错误处理二 如何实现统一的错误处理逻辑 ","date":"2021-02-18","objectID":"/go-study-12/:3:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"panic 停止当前函数运行 一直向上返回，执行每一层的defer 如果没有遇见recover，程序退出 ","date":"2021-02-18","objectID":"/go-study-12/:4:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"recover 仅在defer调用中使用 获取panic的值 如果无法处理，可重新panic ","date":"2021-02-18","objectID":"/go-study-12/:5:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"error vs panic 意料之中的：使用error。如：文件打不开 意料之外的：使用panic。如：数组越界 ","date":"2021-02-18","objectID":"/go-study-12/:6:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"错误处理综合实例 defer + panic + recover Type Assertion 函数式编程的应用 ","date":"2021-02-18","objectID":"/go-study-12/:7:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-18","objectID":"/go-study-12/:8:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"错误处理 Go语言使用一个独立的明确的返回值来传递错误信息。这与使用异常的Java和Ruby以及在C语言中常见到的超重的单返回值/错误值相比，Go语言的处理方式能清楚知道那个函数返回了错误，并能像调用那些没有出错函数一样调用 package main import ( \"errors\" \"fmt\" ) //按照惯例，错误通常是最后一个返回值并且是error类型，一个内建的接口 func f1(arg int) (int, error) { if arg == 42 { //error.New 构造一个使用给定错误信息的基本error值 return -1, errors.New(\"can't work with 42\") } //返回错误值为nil，代表没有错误 return arg+3, nil } //通过实现Error方法来自定义error是可以的 //这里使用自定义错误类型来表示上面的参数错误 type argError struct { arg int prob string } func (e *argError) Error() string { return fmt.Sprintf(\"%d-%s\", e.arg, e.prob) } func f2(arg int) (int, error) { if arg == 42 { //这个例子中，使用\u0026argError语法来建立一个新的结构体 //提供arg和prob两个字段的值 return -1, \u0026argError{arg, \"can't work with it\"} } return arg+3, nil } func main() { //下面两个循环测试了各个返回错误的函数 //注意在if行内的错误检查代码，在Go中是一个普遍的用法 for _, i := range []int{7, 42}{ if r, e := f1(i); e != nil { fmt.Println(\"f1 failed: \", e) } else { fmt.Println(\"f1 worked: \", r) } } for _, i := range []int{7, 42} { if r, e := f2(i); e != nil { fmt.Println(\"f2 failed: \", e) } else { fmt.Println(\"f2 worked: \", r) } } //如果想在程序中使用一个自定义错误类型中的数据 //需要通过类型断言来得到这个错误类型的实例 _, e := f2(42) if ae, ok := e.(*argError); ok { fmt.Println(ae.arg) fmt.Println(ae.prob) } } ","date":"2021-02-18","objectID":"/go-study-12/:8:1","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"Go Study 11-函数与闭包","date":"2021-02-18","objectID":"/go-study-11/","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"函数与闭包 ","date":"2021-02-18","objectID":"/go-study-11/:1:0","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"函数式编程 vs 函数指针 函数式一等公民：参数，变量，返回值都可以是函数 高阶函数 函数 -\u003e 闭包 ","date":"2021-02-18","objectID":"/go-study-11/:1:1","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"“正统”函数式编程 不可变性：不能有状态，只有常量和函数 函数只能有一个参数 ","date":"2021-02-18","objectID":"/go-study-11/:1:2","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"go 语言闭包的应用 更为自然，不需要修饰如何访问自由变量 没有Lambda表达式，但是有匿名函数 闭包与函数\u0026ldquo;闭包与函数\u0026rdquo; \"\r闭包与函数\r ","date":"2021-02-18","objectID":"/go-study-11/:1:3","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-18","objectID":"/go-study-11/:2:0","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"基本函数 函数是Go的中心 package main import \"fmt\" //这里是一个函数，接受两个int，并以int返回它们的和 func plus(a, b int) int { //Go需要明确的返回值 return a+b } func main() { //通过name(args)来调用一个函数 result := plus(1, 2) fmt.Println(result) } ","date":"2021-02-18","objectID":"/go-study-11/:2:1","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"多返回值函数 Go内建多返回值支持。这个特性在Go语言中经常被用到，例如用来同时返回一个函数的结果和错误信息 package main import \"fmt\" //(int, int)在这个函数中标志着这个函数返回2个int func vals() (int, int) { return 3, 7 } func main() { //通过多赋值操作来使用两个不同的返回值 a, b := vals() fmt.Println(a) fmt.Println(b) //如果想返回一部分值，可以使用空白定义符_ _, c := vals() fmt.Println(c) } ","date":"2021-02-18","objectID":"/go-study-11/:2:2","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"可变参数函数 可变参数函数。可以用任意数量的参数调用。例如，fmt.Println是一个常见的变参函数 package main import \"fmt\" //这个函数使用任意数目的int作为参数 func sum(nums ...int) { fmt.Print(nums, \" \") total := 0 for _, num := range nums { total += num } fmt.Println(total) } func main() { //变参函数使用常规的调用方法，除了参数比较特殊 sum(1, 2) sum(1, 2, 3) //如果slice已经有多个值，想作为变参使用，可以这样调用func(slice...) nums := []int{1, 2, 3, 4, 5} sum(nums...) } ","date":"2021-02-18","objectID":"/go-study-11/:2:3","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"闭包 Go支持通过闭包来使用匿名函数。匿名函数在你想定义一个不需要命名的内联函数时很实用 package main import \"fmt\" //这个intSeq函数返回另一个在intSeq函数体内定义的匿名函数 //这个函数的返回使用闭包的方式 隐藏 变量 i func intSeq() func() int { i := 0 return func() int { i += 1 return i } } func main() { //调用nextInt函数，将返回值(也是一个函数)赋给nextInt //这个函数的值包含了自己的值i，在每次调用nextInt都会更新i nextInt := intSeq() //多次调用闭包，查看效果 fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) //更换函数，确定每个函数的i是独立的 nextInts := intSeq() fmt.Println(nextInts()) } ","date":"2021-02-18","objectID":"/go-study-11/:2:4","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"递归函数 Go支持递归，这是一个经典的阶乘案例 package main import \"fmt\" //fact函数在到达fact(0)前一直在调用自身 func fact(n int) int { if n == 0 { return 1 } return n * fact(n-1) } func main() { fmt.Println(fact(5)) } ","date":"2021-02-18","objectID":"/go-study-11/:2:5","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"Go Study 10-接口","date":"2021-02-17","objectID":"/go-study-10/","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"接口 接口由使用者定义 ","date":"2021-02-17","objectID":"/go-study-10/:1:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"duck typing “像鸭子走路，像鸭子叫(长得像鸭子)，那么就是鸭子” 描述事物的外部行为而非内部结构 严格来说go属于结构化类型系统，类似duck typing ","date":"2021-02-17","objectID":"/go-study-10/:2:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"接口变量里有什么 接口变量1\u0026ldquo;接口变量1\u0026rdquo; \"\r接口变量1\r 接口变量2\u0026ldquo;接口变量2\u0026rdquo; \"\r接口变量2\r 接口变量自带指针 接口变量同样采用值传递，几乎不需要使用接口的指针 指针接收者实现只能以指针方式使用；值接收者都可以 ","date":"2021-02-17","objectID":"/go-study-10/:3:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"查看接口变量 表示任何变量：interface{} Type Assertion Type Switch ","date":"2021-02-17","objectID":"/go-study-10/:4:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"特殊接口 Stringer Reader/Writer ","date":"2021-02-17","objectID":"/go-study-10/:5:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-17","objectID":"/go-study-10/:6:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"接口 接口：Go语言中组织和命名相关的方法集合的机制。接口是方法特征的命名集合 package main import ( \"fmt\" \"math\" ) //这里是一个几何体的基本接口 type geometry interface { area() float64 perim() float64 } //这个例子中，将让rect和circle实现这个接口 type rect struct { width float64 height float64 } type circle struct { radius float64 } //在Go中实现接口，需要实现这个接口的所有方法 //rect实现接口 func (r rect) area() float64 { return r.width * r.height } func (r rect) perim() float64 { return 2*r.width + 2*r.height } //circle实现接口 func (c circle) area() float64 { return math.Pi * c.radius * c.radius } func (c circle) perim() float64 { return math.Pi * c.radius * 2 } //如果有一个变量是接口类型，可以调用这个被命名接口的方法 //这里有一个通用的measure函数，利用特性，可以用在任何geometry(几何学)上 func measure(g geometry) { fmt.Println(g) fmt.Println(g.area()) fmt.Println(g.perim()) } func main() { r := rect{width: 3, height: 4} c := circle{radius: 5} //结构体类型circle和rect都实现了geometry接口 //所以可以使用他们的实例作为measure的参数 measure(r) measure(c) } ","date":"2021-02-17","objectID":"/go-study-10/:6:1","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"Go Study 09-GOPATH","date":"2021-02-17","objectID":"/go-study-09/","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"GOPATH环境变量 默认在~/go(unix，linux)，%USERPOFILE%\\go(windows) 官方推荐：所有项目和第三方库都放在同一个GOPATH下 也可以将每个项目放在不同的GOPATH ","date":"2021-02-17","objectID":"/go-study-09/:1:0","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"go get 获取第三方库 go get + 包(github可以，golang不行) 使用gopm来获取无法下载的包 go get -v github.com/gpmgo/gopm ","date":"2021-02-17","objectID":"/go-study-09/:2:0","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"GOPATH下目录结构 go build来编译 go install 产生pkg文件和可执行文件 go run 直接编译运行 ","date":"2021-02-17","objectID":"/go-study-09/:3:0","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"GOPATH下目录结构 src git repository 1 git repository 2 pkg git repository 1 git repository 2 bin 执行文件1,2,3… ","date":"2021-02-17","objectID":"/go-study-09/:4:0","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"Go Study 08-封装","date":"2021-02-16","objectID":"/go-study-08/","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"封装 名字一般使用CamelCase 首字母大写：public 首字母小写：private ","date":"2021-02-16","objectID":"/go-study-08/:1:0","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"包 每个目录一个包 main包包含可执行入口 为结构定义的方法必须放在同一个包内 可以是不同文件 ","date":"2021-02-16","objectID":"/go-study-08/:2:0","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"如何扩充系统类型或者别人的类型 定义别名 使用组合 ","date":"2021-02-16","objectID":"/go-study-08/:2:1","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"Go Study 07-面向对象，struct","date":"2021-02-16","objectID":"/go-study-07/","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"面向对象 go语言仅支持封装，不支持继承和多态 go语言没有class，只有struct ","date":"2021-02-16","objectID":"/go-study-07/:1:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"结构的创建 type treeNode struct { value int left, right *treeNode } //自定义工厂函数 func createNode(value int) *treeNode { //返回局部变量地址 return \u0026treeNode{value: value} } func main() { var root treeNode fmt.Println(root) root = treeNode{value: 3} root.left = \u0026treeNode{} root.right = \u0026treeNode{5, nil, nil} root.right.left = new(treeNode) root.left.right = createNode(2) } 不论地址还是结构本身，一律使用.来访问成员 使用自定义工厂函数(createNode) 注意返回了局部变量的地址 ","date":"2021-02-16","objectID":"/go-study-07/:2:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"为结构定义方法 func (node treeNode) print() { fmt.Println(node.value) } 显示定义和命名方法接受者 ","date":"2021-02-16","objectID":"/go-study-07/:3:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"使用指针作为方法接受者 func (node *treeNode) setValue(value int) { node.value = value } 只有使用指针才可以改变结构内容 nil指针也可以调用方法 ","date":"2021-02-16","objectID":"/go-study-07/:4:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"值接受者 vs 指针接受者 要改变内容必须使用指针接收者 结构过大也考虑使用指针接收者(因为值接收者使用时会拷贝一份，结构过大拷贝代价也大) 一致性：如有指针接收者，最好都使用指针接收者 很简单的不可变对象使用值接收者可以减轻GC负担(太多的指针会增加垃圾服务器GC的负担) 值接收者是go语言特有 值/指针接收者均可接收值/指针 ","date":"2021-02-16","objectID":"/go-study-07/:5:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-16","objectID":"/go-study-07/:6:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"结构体 Go的结构体是各个字段 字段类型的集合 package main import \"fmt\" type person struct { name string age int } func main() { //使用这个语法创建一个新的结构体函数 fmt.Println(person{\"Bob\", 20}) //可以在初始化一个结构体元素时指定字段名 fmt.Println(person{name:\"Alice\", age:18}) //省略的字段将被初始化为零值 fmt.Println(person{name:\"Fred\"}) //\u0026前缀生成一个结构体指针 fmt.Println(\u0026person{name:\"Ann\", age:40}) //使用点来访问结构体字段 s := person{name:\"Sean\", age:50} fmt.Println(s.name) fmt.Println(s.age) //也可以对结构体指针引用，指针会被自动解引用 sp := \u0026s fmt.Println(sp.age) //结构体是可变的 sp.age = 51 fmt.Println(s.age) s.age = 52 fmt.Println(s.age) } ","date":"2021-02-16","objectID":"/go-study-07/:6:1","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"方法 Go支持在结构体类型中定义方法 package main import \"fmt\" type rect struct { wight int height int } //area方法有一个接收器类型rect来计算矩形面积 func (r rect) area() int { return r.height * r.wight } //可以为值或指针类型的接收器定义方法，这是个值类型接收器 //计算矩形周长 func (r rect) perim() int { return 2*r.wight + 2*r.height } //指针类型接收器可以改变实际值 func (r *rect) changeH(val int) { r.height = val } //值类型接收器改变拷贝值 func (r rect) changeW(val int) { r.wight = val } func main() { r := rect{10, 5} //调用上面为结构体定义的方法 fmt.Println(r.area()) fmt.Println(r.perim()) r.changeH(20) r.changeW(15) fmt.Println(r) //Go自动处理方法调用时值和指针之间的转换 //可以使用指针来调用方法避免在方法调用时产生一个拷贝或让方法能够改变接收的数据 rp := \u0026r rp.changeH(25) rp.changeW(30) fmt.Println(rp.area()) fmt.Println(rp.perim()) } ","date":"2021-02-16","objectID":"/go-study-07/:6:2","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"值和指针 Go支持指针，允许在程序中通过引用传递值或数据结构 package main import \"fmt\" //通过两个不同的函数来比较值和指针类型的不同 //zeroVal有一个int型参数，所以使用值传递 //zeroVal将从调用它的函数中获得一个ival形参的拷贝 func zeroVal(ival int) { ival = 0 } //zeroPtr和上面不同是*int，意味着它使用的是指针 //函数体内的*iptr接着解引用这个指针，从它内存地址得到这个地址当前值 //对一个解引用指针进行赋值会改变这个指针引用的真实地址的值 func zeroPtr(iptr *int) { *iptr = 0 } func main() { i := 1 fmt.Println(\"initial: \", i) zeroVal(i) fmt.Println(\"zeroVal: \", i) //通过\u0026i语法来获取i的内存地址 zeroPtr(\u0026i) //指针也是可以被打印的 fmt.Println(\"zeroPtr: \", i) fmt.Println(\"point: \", \u0026i) } ","date":"2021-02-16","objectID":"/go-study-07/:6:3","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"Go Study 06-rune字符串","date":"2021-02-16","objectID":"/go-study-06/","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"rune相当于go的char ","date":"2021-02-16","objectID":"/go-study-06/:1:0","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用range遍历pos，rune对 s := \"Yes我是你爸爸!\" for _, b := range []byte(s) { fmt.Printf(\"%X \", b) } fmt.Println() for i, ch := range s { fmt.Printf(\"(%d %X) \", i, ch) } ","date":"2021-02-16","objectID":"/go-study-06/:1:1","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用utf8.RuneCountInString获得字符数量 fmt.Println(\"Rune count:\", utf8.RuneCountInString(s)) ","date":"2021-02-16","objectID":"/go-study-06/:1:2","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用len获得字节长度 fmt.Println(len(s)) ","date":"2021-02-16","objectID":"/go-study-06/:1:3","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用[]byte获得字节 bytes := []byte(s) for len(bytes) \u003e 0 { ch, size := utf8.DecodeRune(bytes) bytes = bytes[size:] fmt.Printf(\"%c \", ch) } ","date":"2021-02-16","objectID":"/go-study-06/:1:4","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"其他字符串操作 ","date":"2021-02-16","objectID":"/go-study-06/:2:0","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Fields，Split，Join ","date":"2021-02-16","objectID":"/go-study-06/:2:1","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Contains，Index ","date":"2021-02-16","objectID":"/go-study-06/:2:2","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"ToLower，ToUpper ","date":"2021-02-16","objectID":"/go-study-06/:2:3","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Trim，TrimRight，TrimLeft","date":"2021-02-16","objectID":"/go-study-06/:2:4","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Go Study 05-leetcode例题","date":"2021-02-16","objectID":"/go-study-05/","tags":["golang"],"title":"Go Study 05","uri":"/go-study-05/"},{"categories":["学习"],"content":"寻找最长不含有重复字符的子串 abcabcbb -\u003e abc bbbbb -\u003e b pwwkew -\u003ewke func lenthofNonRepeatingSubStr(s string) int { lastOccurred := make(map[rune]int) start := 0 maxLength := 0 for i, ch := range []rune (s){ if lastI, ok := lastOccurred[ch]; ok \u0026\u0026 lastI \u003e= start { fmt.Println(lastI) fmt.Println(ok) start = lastI + 1 } if i-start+1 \u003e maxLength { maxLength = i-start+1 } lastOccurred[ch] = i } return maxLength } ","date":"2021-02-16","objectID":"/go-study-05/:1:0","tags":["golang"],"title":"Go Study 05","uri":"/go-study-05/"},{"categories":["学习"],"content":"Go Study 04-数组、切片和容器","date":"2021-02-15","objectID":"/go-study-04/","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组 var arr1 [5]int arr2 := [3]int{1,3,5} arr3 := [...]int{2,4,6,8,10} var grid [4][5]int 数量写在类型前 ","date":"2021-02-15","objectID":"/go-study-04/:1:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组的遍历 长度遍历 for i := 0; i \u003c len(arr3); i++ { fmt.Println(arr3[i]) } range只取index for i := range arr3 { fmt.Println(arr3[i]) } range取index和value maxi := -1 maxnum := -1 for i, v := range arr3{ if v \u003e maxnum { maxi = i maxnum = v } } fmt.Println(maxi, maxnum) range只取value sum := 0 for _, v := range arr3 { sum += v } 可以通过_省略变量 不仅range，任何地方都可以通过_省略变量 如果只要i，可写成 for i := range numbers ","date":"2021-02-15","objectID":"/go-study-04/:2:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"为什么要用range 意义明确，美观 ","date":"2021-02-15","objectID":"/go-study-04/:3:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组是值类型 [10]int 和[20]int 是不同类型 调用func f(arr [10]int) 会拷贝数组 在go语言中一般不直接使用数组 ","date":"2021-02-15","objectID":"/go-study-04/:4:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Slice(切片) arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s := arr[2:6] s的值为[2 3 4 5] arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s := arr[2:6] s[0] = 10 Slice 本身没有数据，是对底层array的一个view arr 的值变为[0 1 10 3 4 5 6 7] ","date":"2021-02-15","objectID":"/go-study-04/:5:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Reslice s := arr[2:6] s = s[:3] s = s[1:] s = arr[:] ","date":"2021-02-15","objectID":"/go-study-04/:6:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Slice 的实现 slice的实现\u0026ldquo;slice的实现\u0026rdquo; \"\rslice的实现\r ","date":"2021-02-15","objectID":"/go-study-04/:7:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Slice 的扩展 arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s1 := arr[2:6] s2 := arr[3:5] s1 的值为[2 3 4 5]，s2 的值为[5 6] slice 可以向后扩展，不可以向前扩展 s[i] 不可以超越 len(s)，向后扩展不可以超越底层数组cap(s) ","date":"2021-02-15","objectID":"/go-study-04/:8:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"向Slice 添加元素 添加元素时如果超越cap，系统就会重新分配更大的底层数组 由于值传递的关系，必须接受append的返回值 s = append(s, val) ","date":"2021-02-15","objectID":"/go-study-04/:9:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建Slice ","date":"2021-02-15","objectID":"/go-study-04/:10:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个前99个奇数 var s []int for i := 0; i \u003c 100; i++ { s = append(s, 2*i+1) } ","date":"2021-02-15","objectID":"/go-study-04/:10:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个确定的切片 s1 := []int{2, 4, 6, 8} ","date":"2021-02-15","objectID":"/go-study-04/:10:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个len为16的切片 s2 := make([]int, 16) ","date":"2021-02-15","objectID":"/go-study-04/:10:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个len为10，cap为32的切片 s3 := make([]int, 10, 32) ","date":"2021-02-15","objectID":"/go-study-04/:10:4","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"复制切片 copy(s2, s1) ","date":"2021-02-15","objectID":"/go-study-04/:11:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片的元素 ","date":"2021-02-15","objectID":"/go-study-04/:12:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片里的一个元素(删除s2的第四个元素) s2 = append(s2[:3], s2[4:]...) ","date":"2021-02-15","objectID":"/go-study-04/:12:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片第一个元素 s2 = s2[1:] ","date":"2021-02-15","objectID":"/go-study-04/:12:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片最后一个元素 s2 = s2[:len(s2)-1] ","date":"2021-02-15","objectID":"/go-study-04/:12:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map m := map[string]string { \"name\": \"cc\", \"course\": \"golang\", \"site\": \"im\", \"quality\": \"notbad\" } map[K]V, map[K1]map[K2]V ","date":"2021-02-15","objectID":"/go-study-04/:13:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map的操作 ","date":"2021-02-15","objectID":"/go-study-04/:14:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map的遍历 使用range遍历key，或者遍历key，value对 for k, v := range m { fmt.Println(k, v) } 不保证遍历顺序，如需顺序，需手动对key排序 使用len来获得元素的个数 ","date":"2021-02-15","objectID":"/go-study-04/:14:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建：make(map[string]int) //m2 == empty m2 := make(map[string]int) //m3 == nil var m3 map[string]int ","date":"2021-02-15","objectID":"/go-study-04/:14:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"获取元素：map[key] name := m[\"name\"] ","date":"2021-02-15","objectID":"/go-study-04/:14:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"key不存在时，获得Value类型的初始值 name1 := m[\"name1\"] ","date":"2021-02-15","objectID":"/go-study-04/:14:4","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"用value, ok := map[key]来判断是否存在key if name1, ok := m[\"name1\"]; ok { fmt.Println(name1) } else { fmt.Println(\"key does not exist\") } ","date":"2021-02-15","objectID":"/go-study-04/:14:5","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"使用delete来删除一个元素 delete(m, \"age\") ","date":"2021-02-15","objectID":"/go-study-04/:14:6","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map的key map使用哈希表，必须可以比较相等 除了slice，map，function的内建类型都可以作为key Struct类型不包含上述字段，也可以作为key ","date":"2021-02-15","objectID":"/go-study-04/:15:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-15","objectID":"/go-study-04/:16:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组 在Go中数组是一个固定长度的数列。在Go中相对于数组而言，slice使用更多 func arraySample() { //创建了一个数组a来存放刚好5个int。元素类型和长度是数组类型的一部分 //数组默认是零值 var a [5]int fmt.Println(a) //使用array[index] = value语法来设置数组指定位置的值 //使用array[index]来得到值 a[4] = 100 fmt.Println(a) fmt.Println(a[4]) //使用内置函数len返回数组的长度 fmt.Println(\"len: \", len(a)) //使用这个语法一行内初始化一个数组 b := [5]int{1, 2, 3, 4, 5} fmt.Println(\"dcl: \", b) //数组的存储类型是单一的，但是可以组合这些数据来构造多维的数据结构 var twoD [2][3]int for i := 0; i \u003c 2; i++ { for j := 0; j \u003c 3; j++ { twoD[i][j] = i + j } } fmt.Println(\"2d: \", twoD) } ","date":"2021-02-15","objectID":"/go-study-04/:16:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"切片 Slice是Go中一个关键的数据类型，是一个比数组更加强大的序列接口 func sliceSample() { //slice的类型仅由它所包含的元素决定(不像数组还需要元素个数) //创建一个长度非零的空slice，需要使用内建的方法 make //创建一个长度为3的string类型slice(初始化为零值) s := make([]string, 3) fmt.Println(\"emp: \", s) //通过slice[index] = value来设置值 //slice[index]来获取值 s[0] = \"a\" s[1] = \"b\" s[2] = \"c\" fmt.Println(s) fmt.Println(s[2]) //通过len来获取slice长度 fmt.Println(\"len: \", len(s)) //作为基本操作的补充，slice支持比数组更多的操作 //其中一个是内建的append，它返回一个包含一个或多个新值的slice //slice底层是由指针数组和len以及cap组成的，append不会改变slice地址 s = append(s, \"d\") s = append(s, \"e\", \"f\") fmt.Println(\"append: \", s) //slice可以被copy //这里新建一个空的和s相同长度的slice c，并将s复制给c c := make([]string, len(s)) copy(c, s) fmt.Println(\"copy c: \",c) //slice支持通过slice[low:high]语法进行切片处理 l := s[2:5] fmt.Println(\"切片之后2-5slice: \", l) //这个slice从s[0]到(包含)s[5] l = s[:5] fmt.Println(\"从s[0]到s[5]: \", l) //这个slice从s[2]到s最后一个值 l = s[2:] fmt.Println(\"从s[2]到slice最后一个值: \", l) //在一行代码中声明并初始化一个slice变量 t := []string{\"g\", \"h\", \"i\"} fmt.Println(\"dcl: \", t) //slice可以组成多维数据结构 twoD := make([][]int, 3) for i := 0; i \u003c 3; i++ { innerlen := 4 twoD[i] = make([]int, innerlen) for j := 0; j \u003c innerlen; j++ { twoD[i][j] = i + j } } fmt.Println(\"2d: \", twoD) } ","date":"2021-02-15","objectID":"/go-study-04/:16:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"关联数组 map是Go内置关联数据类型(在其他语言成为哈希或字典) func mapsSample() { //要创建一个空的map，需要使用内建的map1 := make(map[key-type]value-type) m := make(map[string]int) fmt.Println(m) //使用经典的map1[key] = value语法来设置键值对 m[\"k1\"] = 1 m[\"k2\"] = 2 fmt.Println(\"map: \", m) //使用map1[key]来获取一个键的值 v1 := m[\"k1\"] fmt.Println(v1) //当对一个map调用内建len，返回的是键值对数目 fmt.Println(\"len: \", len(m)) //内建的delete可以从一个map中移除键值对 delete(m, \"k2\") fmt.Println(\"delete\", m) //从一个map中取值时，可选第二个返回值是这个键是否存在于map中 //这个可以用来消除键不存在或键有零值产生的歧义 _, prs := m[\"k2\"] fmt.Println(\"prs: \", prs) //一行申明和初始化一个map n := map[string]int{\"foo\": 1, \"bar\": 2, \"zhang\": 3} fmt.Println(n) } ","date":"2021-02-15","objectID":"/go-study-04/:16:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Go Study 03-循环语句","date":"2021-02-15","objectID":"/go-study-03/","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"for for的条件里不需要括号 for的条件里可以省略初始条件，结束条件，递增表达式 sum := 0 for i := 1; i \u003c= 100; i++ { sum += i } 省略初始条件，相当于while func convertToBin(n int) string { result := \"\" for ; n \u003e 0; n /= 2 { lsp := n % 2 result = strconv.Itoa(lsp) + result } return result } 省略初始条件和递增条件，也相当于while func printFile(filename string) { file, err := os.Open(filename) if err != nil { panic(err) } // 逐行读取file的内容 scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } } 无限循环 func forever() { for { fmt.Println(\"abc\") } } ","date":"2021-02-15","objectID":"/go-study-03/:1:0","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"基本语法要点回顾 for, if后面的条件没有括号 if条件里也可以定义变量 没有while switch不需要break，也可以直接switch多个条件 ","date":"2021-02-15","objectID":"/go-study-03/:2:0","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"案例 func sample() { //1.最常用的方式，带单个循环条件 i := 1 for i \u003c= 3 { fmt.Println(i) i += 1 } //2.经典的初始化/条件/后续形式for循环 for j := 7; j \u003c= 9; j++ { fmt.Println(j) } //3.不带条件的for循环将一直执行，直到循环体内使用了break或者return来跳出循环 for { fmt.Println(\"loop\") break } } ","date":"2021-02-15","objectID":"/go-study-03/:3:0","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"Range遍历 range迭代各种各样的数据结构 func loopSample2() { //这里使用range来统计一个slice的元素个数，数组也采用这种方式 nums := []int{2,4,5,3} sum := 0 for _, num := range nums { sum += num } fmt.Println(\"sum: \", sum) //range在数组和slice中同样提供了每项的索引和值 //不需要索引时可以使用_来忽略她 for i, num := range nums { if num == 3 { fmt.Println(\"index: \", i) } } //range在map中迭代键值对 kvs := map[string]string{ \"name\": \"cc\", \"age\": \"18\", } for k, v := range kvs { fmt.Printf(\"%v -\u003e %v\\n\", k, v) } //range在字符串中迭代Unicode编码 for i, v := range \"go\" { fmt.Println(i, v) } } ","date":"2021-02-15","objectID":"/go-study-03/:3:1","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"Go Study 02-条件语句","date":"2021-02-15","objectID":"/go-study-02/","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"if if的条件里不需要括号 func bounded(v int) int { if v \u003e 100 { return 100 } else if v \u003c 0 { return 0 } else { return v } } if的条件里可以赋值 if contents, err := ioutil.ReadFile(filename); err != nil { fmt.Println(err) } else { fmt.Printf(\"%s\\n\", contents) } if条件里赋值的变量作用域就在这个if语句里 ","date":"2021-02-15","objectID":"/go-study-02/:1:0","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"switch switch会自动break，除非使用fallthrough func eval(a, b int, op string) int { var result int switch op { case \"+\": result = a + b case \"-\": result = a - b case \"*\": result = a * b case \"/\": result = a / b default: panic(\"unsupported operator:\" + op) } return result } switch后可以没有表达式 func grade(score int) string { g := \"\" switch { case score \u003c 60: g = \"D\" case score \u003c 80: g = \"C\" case score \u003c 90: g = \"B\" case score \u003c= 100: g = \"A\" default: panic(fmt.Sprintf(\"Wrong score: %d\", score)) } return g } ","date":"2021-02-15","objectID":"/go-study-02/:2:0","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-15","objectID":"/go-study-02/:3:0","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"if/else分支 if和else分支结构在Go中当然是直接了当的了 func branchSample1() { if 7 % 2 == 0 { //7是偶数 fmt.Println(\"7 is even\") } else { //7是奇数 fmt.Println(\"7 is odd\") } //也可以不要else，只用if if 8 % 4 == 0 { fmt.Println(\"8 is divisible by 4\") } //在条件语句之前可以有一个语句，任何在这里声明的变量都可以在所有的条件分支中使用 if num := 9; num \u003c 0 { fmt.Println(num, \"is negative\") } else if num \u003c 10 { fmt.Println(num, \"has 1 digit\") } else { fmt.Println(num, \"has multiple digit\") } } ","date":"2021-02-15","objectID":"/go-study-02/:3:1","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"switch分支 func branchSample2() { //一个基本的switch i := 2 switch i { case 1: fmt.Println(\"one\") case 2: fmt.Println(\"two\") case 3: fmt.Println(\"three\") } //在一个case语句中可以使用逗号分割多个表达式 //使用了可选的default分支 switch time.Now().Weekday() { case time.Saturday, time.Sunday: fmt.Println(\"It's the weekend\") default: fmt.Println(\"It's a weekday\") } //不带表达式的switch是实现if/else的另一种方式 //这里展示了case表达式是如何使用非常量的 t := time.Now() switch { case t.Hour() \u003c 12: fmt.Println(\"it's before noon\") default: fmt.Println(\"it's after noon\") } } ","date":"2021-02-15","objectID":"/go-study-02/:3:2","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"Go Study 01-变量常量","date":"2021-02-15","objectID":"/go-study-01/","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"变量定义 ","date":"2021-02-15","objectID":"/go-study-01/:1:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"使用var关键字 var a,b,c bool var s1,s2 string = “hello”, “world” 可以放在函数内，或直接放在包内 使用var()集中定义变量 ","date":"2021-02-15","objectID":"/go-study-01/:1:1","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"让编译器自动决定类型 var a,b,i,s1,s2 = true, false, 3, “hello”, “world” ","date":"2021-02-15","objectID":"/go-study-01/:1:2","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"使用:=定义变量 a,b,i,s1,s2 := true, false, 3, “hello”, “world” 只能在函数内使用 ","date":"2021-02-15","objectID":"/go-study-01/:1:3","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"内建变量类型 bool, string (u)int, (u)int8, (u)int16, (u)int32, (u)int(64), uintptr(指针) byte, rune float32, float64, complex64, complex128 (complex是复数) ","date":"2021-02-15","objectID":"/go-study-01/:2:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"强制类型转换 类型转换是强制的 var a,b int = 3, 4 var int = math.Sqrt(aa + bb) (错误) var int = int(math.Sqrt(float64(aa + bb))) (正确) ","date":"2021-02-15","objectID":"/go-study-01/:3:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"常量定义 const filename = “abc.txt” const 数值可以作为各种类型使用 const a, b = 3, 4 var c int = int(math.Sqrt(aa + bb)) ","date":"2021-02-15","objectID":"/go-study-01/:4:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"使用常量定义枚举类型 普通枚举类型 const ( cpp = 1 java = 2 python = 3 golang = 4 ) 自增值枚举类型 const ( cpp = iota java python golang ) ","date":"2021-02-15","objectID":"/go-study-01/:5:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"变量定义要点回顾 变量类型写在变量名之后 编译器可推测变量类型 没有char，只有rune 原生支持复数类型 ","date":"2021-02-15","objectID":"/go-study-01/:6:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-15","objectID":"/go-study-01/:7:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"值 Go拥有各值类型，包括字符串，整型，浮点型，布尔型等 func value() { //字符串通过+连接 fmt.Println(\"go\" + \"lang\") //浮点数和整数 fmt.Println(\"1+1=\", 1+1) fmt.Println(\"7.0/3.0=\", 7.0/3.0) //布尔型和逻辑运算符 fmt.Println(true \u0026\u0026 false) fmt.Println(true || false) fmt.Println(!true) } ","date":"2021-02-15","objectID":"/go-study-01/:7:1","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"变量 在Go中，变量被显式声明，并被编译器所用来检查函数调用时的类型正确性 func varible() { //声明一个变量 var a string = \"initial\" fmt.Println(a) //声明多个变量 var b, c int = 1, 2 fmt.Println(b, c) //Go 将自动推断已经初始化的变量类型 var d = true fmt.Printf(\"%T %v\\n\", d, d) //声明变量且没有给出对应初始值，变量会被初始化为零值 var e int fmt.Println(e) //:=语句是申明并初始化变量的简写 f := \"short\" fmt.Println(f) } ","date":"2021-02-15","objectID":"/go-study-01/:7:2","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"常量 Go支持字符、字符串、布尔和数值常量 func constant() { //const用于声明一个常量 const s = \"constant\" fmt.Println(\"s=\", s) //const语句可以出现在任何var语句可以出现的地方 const n = 500000000 fmt.Println(n) //常数表达式可以执行任意精度的运算 const d = 3e20 / n fmt.Println(\"d = 3e20/n : \", d) //数值型常量是没有确定的类型，直到他们被给定一个类型，比如说一次显示的类型转化 fmt.Println(\"int64(d) = \", int64(d)) //当上下文需要的时候，一个数可以被给定一个类型，比如变量赋值或函数调用 //举个栗子，这里的math.Sin()需要一个float64参数 fmt.Println(\"math.Sin(n) = \", math.Sin(n)) } ","date":"2021-02-15","objectID":"/go-study-01/:7:3","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"Linux Network 02","date":"2021-02-14","objectID":"/linux-network-02/","tags":["Linux网络编程"],"title":"Linux Network 02","uri":"/linux-network-02/"},{"categories":["学习"],"content":"Socket(套接字)编程 ","date":"2021-02-14","objectID":"/linux-network-02/:1:0","tags":["Linux网络编程"],"title":"Linux Network 02","uri":"/linux-network-02/"},{"categories":["学习"],"content":"套接字概念 在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系 socket通信原理socket通信原理 \"\rsocket通信原理\r 在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区 ","date":"2021-02-14","objectID":"/linux-network-02/:1:1","tags":["Linux网络编程"],"title":"Linux Network 02","uri":"/linux-network-02/"},{"categories":["学习"],"content":"Linux Network 01","date":"2021-02-13","objectID":"/linux-network-01/","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"协议的概念 ","date":"2021-02-13","objectID":"/linux-network-01/:1:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"什么是协议？ 从应用的角度出发，协议可以理解为“规则”，是数据传输和数据解释的规则 ","date":"2021-02-13","objectID":"/linux-network-01/:1:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"典型协议 传输层 常见的协议有TCP/UDP协议 应用层 常见的协议有HTTP/FTP协议 网络层 常见的协议有IP/ICMP/IGMP协议 网络接口层 常见的协议有ARP/RARP协议 TCP传输控制协议是一种面向连接的、可靠地、基于字节流的传输层通信协议 UDP用户数据报协议是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务 HTTP超文本传输协议是互联网上应用最广泛的一种网络协议 FTP文件传输协议 IP协议是因特网互联协议 ICMP协议是Internet控制报文协议，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息 IGMP协议是Internet组管理协议，是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间 ARP协议是正向地址解析协议，通过已知IP寻找对应主机的MAC地址 RARP协议是反向地址转换协议，通过MAC地址确定IP地址 ","date":"2021-02-13","objectID":"/linux-network-01/:1:2","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"网络应用程序设计模式 ","date":"2021-02-13","objectID":"/linux-network-01/:2:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"C/S模式 传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信 ","date":"2021-02-13","objectID":"/linux-network-01/:2:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"B/S模式 浏览器(Brower)/服务器(server)模式。只需要在一端部署服务器，而另一端使用每台PC都默认配置的浏览器即可完成数据的传输 ","date":"2021-02-13","objectID":"/linux-network-01/:2:2","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"C/S优缺点 优点 1、协议选用灵活 2、数据可以提前缓存 缺点 1、对用户安全构成威胁 2、开发工作量较大 ","date":"2021-02-13","objectID":"/linux-network-01/:2:3","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"B/S优缺点 优点 1、不会安装第三方软件，安全性高 2、只需要开发服务端，工作量减小 3、可以跨平台 缺点 1、需要支持HTTP协议 2、不能进行数据缓存 ","date":"2021-02-13","objectID":"/linux-network-01/:2:4","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"分层模型 OSI参考模型 TCP/IP模型 应用层-- 表示层 |-\u003e 应用层 会话层-- 传输层 传输层 网络层 网络层 数据链路层-|-\u003e 网络接口层 物理层------ ","date":"2021-02-13","objectID":"/linux-network-01/:3:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"OSI七层模型 1、物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。他的主要作用是传输比特流 2、数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输 3、网络层：在位于不同地理位置的网络中的两个主机系统之间提供链接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层 4、传输层：定义了一些传输数据的协议和端口号(www端口80等)，如：TCP(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，UDP(用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的)。主要是将下层接受的数据进行分段和传输，达到目的地址后再进行重组，常常把这一层数据叫做段。 5、会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求(设备之间需要互相认识可以是IP也可以是MAC或者是主机名)。 6、表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用读取。如：PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码(ASCII)来表示相同字符，如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 7、应用层：是最靠近用户的OSI层，这一层为用户的应用程序(例如电子邮件、文件传输和终端仿真)提供网络服务 ","date":"2021-02-13","objectID":"/linux-network-01/:3:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"TCP/IP四层模型 TCP/IP网络协议栈分为应用层、传输层、网络层、链路层四层 其中应用层典型的是FTP协议，传输层典型的是TCP或UDP协议，网络层典型的是IP协议，链路层典型的是以太网帧协议 TCP/IP模型TCP/IP模型 \"\rTCP/IP模型\r ","date":"2021-02-13","objectID":"/linux-network-01/:3:2","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"通信过程 通信过程通信过程 \"\r通信过程\r ","date":"2021-02-13","objectID":"/linux-network-01/:4:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"协议格式 ","date":"2021-02-13","objectID":"/linux-network-01/:5:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"数据包封装 数据包封装TCP/IP数据包封装 \"\r数据包封装\r ","date":"2021-02-13","objectID":"/linux-network-01/:5:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"java02","date":"2021-02-10","objectID":"/java02/","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"标识符注意点 所有的标识符都应该以字母(A-Z或者a-z)，美元符($)或者下划线(_)开始 首字符之后可以是字母(A-Z或者a-z)，美元符($)，下划线(_)或数字的任何字符组合 不能使用关键字作为变量名或者方法名 标识符是大小写敏感的 合法标识符举例：age、$salary、_value、__1_value 非法标识符举例：123abc、-salary、#abc 可以使用中文命名，但是一般不建议这样去使用，也不建议使用拼音，很Low 数据类型 ","date":"2021-02-10","objectID":"/java02/:0:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"强类型语言 要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用 ","date":"2021-02-10","objectID":"/java02/:1:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"弱类型语言 ","date":"2021-02-10","objectID":"/java02/:2:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"java的数据类型分为两大类 基本类型(primitive type) 数值类型 整数类型 byte占一个字节范围：-128~127 short占两个字节范围：-32768~32767 int占四个字节范围：… long占八个字节范围：… 浮点类型 float占四个字节 double占八个字节 字符类型 char占两个字节 boolean类型：占一位其值只有true和false两个 引用类型(reference type) 类 接口 数组 什么是字节 位(bit)：是计算机内部数据储存的最小单位，11001100是一个八位二进制数 字节(byte)：是计算机数据处理的基本单位，习惯上用大写B来表示 1B(byte，字节) = 8bit(位) 字符：是指计算机中使用的字母、数字、字和符号 1bit表示1位 1Byte表示一个字节 1B=8b 1024B = 1KB 1024KB = 1M 1024M = 1G 类型转换 由于java是强类型语言，所以要进行有些运算的时候，需要用到类型转换 低-\u003e高 byte,short,char-\u003eint-\u003elong-\u003efloat-\u003edouble 运算中，不同的数据类型先转换成同一类型，然后进行运算 强制类型转换 (类型)变量名 高到低 自动类型转换 低到高 注意点： 1、不能对布尔值进行转换 2、不能把对象类型转换成不相关的类型 3、在把高容量转换成低容量的时候，强制转换 4、转换的时候可能存在内存溢出或者精度问题 变量 变量是什么？ 变量就是可以变化的量 java是一种强类型语言，每个变量都必须声明其类型。 java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域 注意事项： 每个变量都有类型，类型可以是基本类型，也可以是引用类型 变量名必须是合法的标识符 变量声明是一条完整的语句，因此每一个声明都必须以分号结束 变量的命名规范 所有变量、方法、类名：见名知意 类成员变量：首字母小写和驼峰原则：monthSalary 局部变量：首字母小写和驼峰原则 常量：大写字母和下划线：MAX_VALUE 类名：首字母大写和驼峰原则：Man，GoodMan 方法名：首字母小写和驼峰原则：run()，runRun() 常量 常量(Constant)：初始化(initialize)后不能再改变值！不会变动的值 所谓常量可以理解为一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变 final 常量名 = 值; 常量名一般使用大写字符 ","date":"2021-02-10","objectID":"/java02/:3:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"java01","date":"2021-02-09","objectID":"/java01/","tags":["java"],"title":"Java01","uri":"/java01/"},{"categories":["学习"],"content":"java是一门跨平台语言(jvm虚拟机) java特性和优势 简单性 面向对象 可移植性(write once, run anywhere) 高性能 分布式 动态性 多线程 安全性 健壮性 java三大版本 javaSE：标准版(桌面程序，控制台开发…) javaME：嵌入式开发(手机，小家电…) javaEE：E企业级开发(web端，服务器开发…) JDK、JRE、JVM JDK：Java Development Kit(java开发者工具) JRE：Java Runtime Environment(java运行时环境) JVM：Java Virtual Machine(java虚拟机) JDK\u003eJRE\u003eJVM","date":"2021-02-09","objectID":"/java01/:0:0","tags":["java"],"title":"Java01","uri":"/java01/"},{"categories":["学习"],"content":"dos常用命令","date":"2021-02-08","objectID":"/dos-code/","tags":["dos"],"title":"Dos Code","uri":"/dos-code/"},{"categories":["学习"],"content":"盘符切换 切换到C盘： c: 切换到E盘： e: 查看当前目录下的所有文件 dir 切换目录 cd change directory cd .. 清理屏幕 cls 退出终端 exit 查看电脑ip ipconfig 打开应用 calc mspaint notepad ping命令 ping 192.168.1.* 文件操作 创建一个文件夹：md 目录名 移除一个文件夹：rd 目录名 创建一个文件： cd\u003e 文件名 移除一个文件： del 文件名","date":"2021-02-08","objectID":"/dos-code/:0:0","tags":["dos"],"title":"Dos Code","uri":"/dos-code/"},{"categories":["学习"],"content":"markdown学习01","date":"2021-02-07","objectID":"/markdown-study01/","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"1 标题 ","date":"2021-02-07","objectID":"/markdown-study01/:0:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"h2 标题 ","date":"2021-02-07","objectID":"/markdown-study01/:1:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"h3 标题 h4 标题 h5 标题 h6 标题、 要添加自定义标题ID，请在与标题相同的行中将自定义ID放在花括号中 ###一个很棒的标题 {#custom-id} 2 注释 注释和HTML兼容的 3 水平线 HTML中的\u003chr\u003e标签是用来在段落元素之间创建一个“专题间隔”的 Markdown可以使用以下方式： -–：三个连续的破折号 ___：三个连续的下划线 ***：三个连续的星号 4 段落 HTML中将用\u003cp\u003e\u003c/p\u003e标签包裹 Markdown直接按照纯文本的方式书写段落 5 内联HTML元素 这是HTML 6 强调 ","date":"2021-02-07","objectID":"/markdown-study01/:1:1","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"加粗 用于强调带有较粗字体的文本片段 以下文本会被渲染为粗体 **渲染为粗体** __渲染为粗体__ 输出的HTML看起来像这样 \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2021-02-07","objectID":"/markdown-study01/:2:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"斜体 用于强调带有斜体的文本片段 以下文本片段被渲染成斜体 *渲染为斜体* _渲染为斜体_ 输出的HTML看起来像这样 \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2021-02-07","objectID":"/markdown-study01/:3:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"删除线 以下文本片段会被渲染成删除线 ~~这段文本带有删除线~~ 输出的HTML看起来像这样 \u003cdel\u003e这段文本带有删除线\u003c/del\u003e 这段文本带有删除线 ","date":"2021-02-07","objectID":"/markdown-study01/:4:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"组合 加粗，斜体和删除线可以组合使用 ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除和斜体*~~ ~~***加粗，斜体和删除线***~~ 输出的HTML看起来像这样 \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003cem\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗，斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e 加粗和斜体 删除线和加粗 删除和斜体 加粗，斜体和删除线 7 引用 用于在文档中引用其他来源的内容块 在要引用的任何文本之前添加\u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage 输出的HTML看起来像这样 \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套 \u003e **Fusion Drive** combines a hard drive with a flash storage \u003e\u003e 111 Fusion Drive combines a hard drive with a flash storage 111 8 列表 ","date":"2021-02-07","objectID":"/markdown-study01/:5:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"无序列表 一系列项的列表，其中项的顺序没有明显关系 你可以使用以下任何符号来表示无序列表中的项 * 一项内容 * 子内容 - 一项内容 + 一项内容 一项内容 子内容 一项内容 一项内容 ","date":"2021-02-07","objectID":"/markdown-study01/:6:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"有序列表 一系列项的列表，其中项的顺序确实很重要 1. a 2. b 3. c 输出的HTML看起来像这样 \u003col\u003e \u003cli\u003ea\u003c/li\u003e \u003cli\u003eb\u003c/li\u003e \u003cli\u003ec\u003c/li\u003e \u003c/ol\u003e a b c ","date":"2021-02-07","objectID":"/markdown-study01/:7:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"任务列表 任务列表使你可以创建带有复选框的列表，要创建列表，请在任务列表项之前添加破折号(-)和带有空格的方括号([ ])，要选择复选框，请在方括号之间添加x([x]) - [x] a - [ ] b - [ ] c Write the press release Update the website Contact the media 9 代码 ","date":"2021-02-07","objectID":"/markdown-study01/:8:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"行内代码 用\\包装行内代码段 在这个例子中, \\\u003csection\u003e\\\u003c/section\u003e 会被包裹成 **代码**. \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e 呈现的输出效果如下： 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. ","date":"2021-02-07","objectID":"/markdown-study01/:9:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"缩进代码 // Some comments line 1 of code line 2 of code line 3 of code 输出的HTML看起来像这样： \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e 呈现的输出效果如下： // Some comments line 1 of code line 2 of code line 3 of code ","date":"2021-02-07","objectID":"/markdown-study01/:10:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"围栏代码块 使用“围栏”```来生成一段带有语言属性的代码块 Sample text here... Sample text here... 10 表格 通过在每个单元格之间添加竖线作为分隔线，并在标题下添加一行破折号(也由竖线分隔)来创建表格，注意竖线不需要垂直对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中 | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 输出的HTML看起来像这样 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 链接 ","date":"2021-02-07","objectID":"/markdown-study01/:11:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 输出的HTML看起来像这样 \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e 呈现的输出效果如下(将鼠标悬停在链接上，没有提示) https://assemble.io contact@revolunet.com Assemble ","date":"2021-02-07","objectID":"/markdown-study01/:12:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 输出的HTML看起来像这样 \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e 呈现的输出效果如下(将鼠标悬停在链接上，会有一行提示) Upstage 12 脚注 脚注使你可以添加注释和参考，而不会使文档正文混乱，当你使用脚注时，会在添加脚注引用的位置出现带有链接的上标标号，读者可以单击链接以跳至页面底部的脚注内容 要创建脚注引用，请在方括号中添加插入符号和标识符 (1)，标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号。 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 (1：这是一段脚注)。你不一定要在文档末尾添加脚注. 可以将它们放在除列表，引用和表格等元素之外的任何位置。 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 13 图片 图片的语法与链接相似，但包含一个在前面的感叹号 ![Minion](https://octodex.github.com/images/minion.png) ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2021-02-07","objectID":"/markdown-study01/:13:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["生活"],"content":"第一篇blog","date":"2021-02-05","objectID":"/first_post/","tags":["我的"],"title":"First_post","uri":"/first_post/"},{"categories":["生活"],"content":"first post LoveIt主题中文文档 emoji表情 去露营啦! ⛺ 很快就回来. 真开心! 😂 blog前置参数注解 ","date":"2021-02-05","objectID":"/first_post/:0:0","tags":["我的"],"title":"First_post","uri":"/first_post/"},{"categories":null,"content":"aa ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]