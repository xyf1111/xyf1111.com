[{"categories":["学习"],"content":"Go Study 08-封装","date":"2021-02-16","objectID":"/go-study-08/","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"封装 名字一般使用CamelCase 首字母大写：public 首字母小写：private ","date":"2021-02-16","objectID":"/go-study-08/:1:0","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"包 每个目录一个包 main包包含可执行入口 为结构定义的方法必须放在同一个包内 可以是不同文件 ","date":"2021-02-16","objectID":"/go-study-08/:2:0","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"如何扩充系统类型或者别人的类型 定义别名 使用组合 ","date":"2021-02-16","objectID":"/go-study-08/:2:1","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"Go Study 07-面向对象，struct","date":"2021-02-16","objectID":"/go-study-07/","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"面向对象 go语言仅支持封装，不支持继承和多态 go语言没有class，只有struct ","date":"2021-02-16","objectID":"/go-study-07/:1:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"结构的创建 type treeNode struct { value int left, right *treeNode } //自定义工厂函数 func createNode(value int) *treeNode { //返回局部变量地址 return \u0026treeNode{value: value} } func main() { var root treeNode fmt.Println(root) root = treeNode{value: 3} root.left = \u0026treeNode{} root.right = \u0026treeNode{5, nil, nil} root.right.left = new(treeNode) root.left.right = createNode(2) } 不论地址还是结构本身，一律使用.来访问成员 使用自定义工厂函数(createNode) 注意返回了局部变量的地址 ","date":"2021-02-16","objectID":"/go-study-07/:2:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"为结构定义方法 func (node treeNode) print() { fmt.Println(node.value) } 显示定义和命名方法接受者 ","date":"2021-02-16","objectID":"/go-study-07/:3:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"使用指针作为方法接受者 func (node *treeNode) setValue(value int) { node.value = value } 只有使用指针才可以改变结构内容 nil指针也可以调用方法 ","date":"2021-02-16","objectID":"/go-study-07/:4:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"值接受者 vs 指针接受者 要改变内容必须使用指针接收者 结构过大也考虑使用指针接收者 一致性：如有指针接收者，最好都使用指针接收者 值接收者是go语言特有 值/指针接收者均可接收值/指针 ","date":"2021-02-16","objectID":"/go-study-07/:5:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"Go Study 06-rune字符串","date":"2021-02-16","objectID":"/go-study-06/","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"rune相当于go的char ","date":"2021-02-16","objectID":"/go-study-06/:1:0","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用range遍历pos，rune对 s := \"Yes我是你爸爸!\" for _, b := range []byte(s) { fmt.Printf(\"%X \", b) } fmt.Println() for i, ch := range s { fmt.Printf(\"(%d %X) \", i, ch) } ","date":"2021-02-16","objectID":"/go-study-06/:1:1","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用utf8.RuneCountInString获得字符数量 fmt.Println(\"Rune count:\", utf8.RuneCountInString(s)) ","date":"2021-02-16","objectID":"/go-study-06/:1:2","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用len获得字节长度 fmt.Println(len(s)) ","date":"2021-02-16","objectID":"/go-study-06/:1:3","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用[]byte获得字节 bytes := []byte(s) for len(bytes) \u003e 0 { ch, size := utf8.DecodeRune(bytes) bytes = bytes[size:] fmt.Printf(\"%c \", ch) } ","date":"2021-02-16","objectID":"/go-study-06/:1:4","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"其他字符串操作 ","date":"2021-02-16","objectID":"/go-study-06/:2:0","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Fields，Split，Join ","date":"2021-02-16","objectID":"/go-study-06/:2:1","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Contains，Index ","date":"2021-02-16","objectID":"/go-study-06/:2:2","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"ToLower，ToUpper ","date":"2021-02-16","objectID":"/go-study-06/:2:3","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Trim，TrimRight，TrimLeft","date":"2021-02-16","objectID":"/go-study-06/:2:4","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Go Study 05-leetcode例题","date":"2021-02-16","objectID":"/go-study-05/","tags":["golang"],"title":"Go Study 05","uri":"/go-study-05/"},{"categories":["学习"],"content":"寻找最长不含有重复字符的子串 abcabcbb -\u003e abc bbbbb -\u003e b pwwkew -\u003ewke func lenthofNonRepeatingSubStr(s string) int { lastOccurred := make(map[rune]int) start := 0 maxLength := 0 for i, ch := range []rune (s){ if lastI, ok := lastOccurred[ch]; ok \u0026\u0026 lastI \u003e= start { fmt.Println(lastI) fmt.Println(ok) start = lastI + 1 } if i-start+1 \u003e maxLength { maxLength = i-start+1 } lastOccurred[ch] = i } return maxLength } ","date":"2021-02-16","objectID":"/go-study-05/:1:0","tags":["golang"],"title":"Go Study 05","uri":"/go-study-05/"},{"categories":["学习"],"content":"Go Study 04-数组、切片和容器","date":"2021-02-15","objectID":"/go-study-04/","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组 var arr1 [5]int arr2 := [3]int{1,3,5} arr3 := [...]int{2,4,6,8,10} var grid [4][5]int 数量写在类型前 ","date":"2021-02-15","objectID":"/go-study-04/:1:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组的遍历 长度遍历 for i := 0; i \u003c len(arr3); i++ { fmt.Println(arr3[i]) } range只取index for i := range arr3 { fmt.Println(arr3[i]) } range取index和value maxi := -1 maxnum := -1 for i, v := range arr3{ if v \u003e maxnum { maxi = i maxnum = v } } fmt.Println(maxi, maxnum) range只取value sum := 0 for _, v := range arr3 { sum += v } 可以通过_省略变量 不仅range，任何地方都可以通过_省略变量 如果只要i，可写成 for i := range numbers ","date":"2021-02-15","objectID":"/go-study-04/:2:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"为什么要用range 意义明确，美观 ","date":"2021-02-15","objectID":"/go-study-04/:3:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组是值类型 [10]int 和[20]int 是不同类型 调用func f(arr [10]int) 会拷贝数组 在go语言中一般不直接使用数组 ","date":"2021-02-15","objectID":"/go-study-04/:4:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Slice(切片) arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s := arr[2:6] s的值为[2 3 4 5] arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s := arr[2:6] s[0] = 10 Slice 本身没有数据，是对底层array的一个view arr 的值变为[0 1 10 3 4 5 6 7] ","date":"2021-02-15","objectID":"/go-study-04/:5:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Reslice s := arr[2:6] s = s[:3] s = s[1:] s = arr[:] ","date":"2021-02-15","objectID":"/go-study-04/:6:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Slice 的实现 slice的实现\u0026ldquo;slice的实现\u0026rdquo; \"\rslice的实现\r ","date":"2021-02-15","objectID":"/go-study-04/:7:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Slice 的扩展 arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s1 := arr[2:6] s2 := arr[3:5] s1 的值为[2 3 4 5]，s2 的值为[5 6] slice 可以向后扩展，不可以向前扩展 s[i] 不可以超越 len(s)，向后扩展不可以超越底层数组cap(s) ","date":"2021-02-15","objectID":"/go-study-04/:8:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"向Slice 添加元素 添加元素时如果超越cap，系统就会重新分配更大的底层数组 由于值传递的关系，必须接受append的返回值 s = append(s, val) ","date":"2021-02-15","objectID":"/go-study-04/:9:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建Slice ","date":"2021-02-15","objectID":"/go-study-04/:10:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个前99个奇数 var s []int for i := 0; i \u003c 100; i++ { s = append(s, 2*i+1) } ","date":"2021-02-15","objectID":"/go-study-04/:10:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个确定的切片 s1 := []int{2, 4, 6, 8} ","date":"2021-02-15","objectID":"/go-study-04/:10:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个len为16的切片 s2 := make([]int, 16) ","date":"2021-02-15","objectID":"/go-study-04/:10:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个len为10，cap为32的切片 s3 := make([]int, 10, 32) ","date":"2021-02-15","objectID":"/go-study-04/:10:4","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"复制切片 copy(s2, s1) ","date":"2021-02-15","objectID":"/go-study-04/:11:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片的元素 ","date":"2021-02-15","objectID":"/go-study-04/:12:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片里的一个元素(删除s2的第四个元素) s2 = append(s2[:3], s2[4:]...) ","date":"2021-02-15","objectID":"/go-study-04/:12:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片第一个元素 s2 = s2[1:] ","date":"2021-02-15","objectID":"/go-study-04/:12:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片最后一个元素 s2 = s2[:len(s2)-1] ","date":"2021-02-15","objectID":"/go-study-04/:12:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map m := map[string]string { \"name\": \"cc\", \"course\": \"golang\", \"site\": \"im\", \"quality\": \"notbad\" } map[K]V, map[K1]map[K2]V ","date":"2021-02-15","objectID":"/go-study-04/:13:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map的操作 ","date":"2021-02-15","objectID":"/go-study-04/:14:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map的遍历 使用range遍历key，或者遍历key，value对 for k, v := range m { fmt.Println(k, v) } 不保证遍历顺序，如需顺序，需手动对key排序 使用len来获得元素的个数 ","date":"2021-02-15","objectID":"/go-study-04/:14:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建：make(map[string]int) //m2 == empty m2 := make(map[string]int) //m3 == nil var m3 map[string]int ","date":"2021-02-15","objectID":"/go-study-04/:14:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"获取元素：map[key] name := m[\"name\"] ","date":"2021-02-15","objectID":"/go-study-04/:14:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"key不存在时，获得Value类型的初始值 name1 := m[\"name1\"] ","date":"2021-02-15","objectID":"/go-study-04/:14:4","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"用value, ok := map[key]来判断是否存在key if name1, ok := m[\"name1\"]; ok { fmt.Println(name1) } else { fmt.Println(\"key does not exist\") } ","date":"2021-02-15","objectID":"/go-study-04/:14:5","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"使用delete来删除一个元素 delete(m, \"age\") ","date":"2021-02-15","objectID":"/go-study-04/:14:6","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map的key map使用哈希表，必须可以比较相等 除了slice，map，function的内建类型都可以作为key Struct类型不包含上述字段，也可以作为key ","date":"2021-02-15","objectID":"/go-study-04/:15:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Go Study 03-循环语句","date":"2021-02-15","objectID":"/go-study-03/","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"for for的条件里不需要括号 for的条件里可以省略初始条件，结束条件，递增表达式 sum := 0 for i := 1; i \u003c= 100; i++ { sum += i } 省略初始条件，相当于while func convertToBin(n int) string { result := \"\" for ; n \u003e 0; n /= 2 { lsp := n % 2 result = strconv.Itoa(lsp) + result } return result } 省略初始条件和递增条件，也相当于while func printFile(filename string) { file, err := os.Open(filename) if err != nil { panic(err) } scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } } 无限循环 func forever() { for { fmt.Println(\"abc\") } } ","date":"2021-02-15","objectID":"/go-study-03/:1:0","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"基本语法要点回顾 for, if后面的条件没有括号 if条件里也可以定义变量 没有while switch不需要break，也可以直接switch多个条件 ","date":"2021-02-15","objectID":"/go-study-03/:2:0","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"Go Study 02-条件语句","date":"2021-02-15","objectID":"/go-study-02/","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"if if的条件里不需要括号 func bounded(v int) int { if v \u003e 100 { return 100 } else if v \u003c 0 { return 0 } else { return v } } if的条件里可以赋值 if contents, err := ioutil.ReadFile(filename); err != nil { fmt.Println(err) } else { fmt.Printf(\"%s\\n\", contents) } if条件里赋值的变量作用域就在这个if语句里 ","date":"2021-02-15","objectID":"/go-study-02/:1:0","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"switch switch会自动break，除非使用fallthrough func eval(a, b int, op string) int { var result int switch op { case \"+\": result = a + b case \"-\": result = a - b case \"*\": result = a * b case \"/\": result = a / b default: panic(\"unsupported operator:\" + op) } return result } switch后可以没有表达式 func grade(score int) string { g := \"\" switch { case score \u003c 60: g = \"D\" case score \u003c 80: g = \"C\" case score \u003c 90: g = \"B\" case score \u003c= 100: g = \"A\" default: panic(fmt.Sprintf(\"Wrong score: %d\", score)) } return g } ","date":"2021-02-15","objectID":"/go-study-02/:2:0","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"Go Study 01-变量常量","date":"2021-02-15","objectID":"/go-study-01/","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"变量定义 ","date":"2021-02-15","objectID":"/go-study-01/:1:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"使用var关键字 var a,b,c bool var s1,s2 string = “hello”, “world” 可以放在函数内，或直接放在包内 使用var()集中定义变量 ","date":"2021-02-15","objectID":"/go-study-01/:1:1","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"让编译器自动决定类型 var a,b,i,s1,s2 = true, false, 3, “hello”, “world” ","date":"2021-02-15","objectID":"/go-study-01/:1:2","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"使用:=定义变量 a,b,i,s1,s2 := true, false, 3, “hello”, “world” 只能在函数内使用 ","date":"2021-02-15","objectID":"/go-study-01/:1:3","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"内建变量类型 bool, string (u)int, (u)int8, (u)int16, (u)int32, (u)int(64), uintptr(指针) byte, rune float32, float64, complex64, complex128 (complex是复数) ","date":"2021-02-15","objectID":"/go-study-01/:2:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"强制类型转换 类型转换是强制的 var a,b int = 3, 4 var int = math.Sqrt(aa + bb) (错误) var int = int(math.Sqrt(float64(aa + bb))) (正确) ","date":"2021-02-15","objectID":"/go-study-01/:3:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"常量定义 const filename = “abc.txt” const 数值可以作为各种类型使用 const a, b = 3, 4 var c int = int(math.Sqrt(aa + bb)) ","date":"2021-02-15","objectID":"/go-study-01/:4:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"使用常量定义枚举类型 普通枚举类型 const ( cpp = 1 java = 2 python = 3 golang = 4 ) 自增值枚举类型 const ( cpp = iota java python golang ) ","date":"2021-02-15","objectID":"/go-study-01/:5:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"变量定义要点回顾 变量类型写在变量名之后 编译器可推测变量类型 没有char，只有rune 原生支持复数类型 ","date":"2021-02-15","objectID":"/go-study-01/:6:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"Linux Network 02","date":"2021-02-14","objectID":"/linux-network-02/","tags":["Linux网络编程"],"title":"Linux Network 02","uri":"/linux-network-02/"},{"categories":["学习"],"content":"Socket(套接字)编程 ","date":"2021-02-14","objectID":"/linux-network-02/:1:0","tags":["Linux网络编程"],"title":"Linux Network 02","uri":"/linux-network-02/"},{"categories":["学习"],"content":"套接字概念 在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系 socket通信原理socket通信原理 \"\rsocket通信原理\r 在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区 ","date":"2021-02-14","objectID":"/linux-network-02/:1:1","tags":["Linux网络编程"],"title":"Linux Network 02","uri":"/linux-network-02/"},{"categories":["学习"],"content":"Linux Network 01","date":"2021-02-13","objectID":"/linux-network-01/","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"协议的概念 ","date":"2021-02-13","objectID":"/linux-network-01/:1:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"什么是协议？ 从应用的角度出发，协议可以理解为“规则”，是数据传输和数据解释的规则 ","date":"2021-02-13","objectID":"/linux-network-01/:1:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"典型协议 传输层 常见的协议有TCP/UDP协议 应用层 常见的协议有HTTP/FTP协议 网络层 常见的协议有IP/ICMP/IGMP协议 网络接口层 常见的协议有ARP/RARP协议 TCP传输控制协议是一种面向连接的、可靠地、基于字节流的传输层通信协议 UDP用户数据报协议是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务 HTTP超文本传输协议是互联网上应用最广泛的一种网络协议 FTP文件传输协议 IP协议是因特网互联协议 ICMP协议是Internet控制报文协议，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息 IGMP协议是Internet组管理协议，是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间 ARP协议是正向地址解析协议，通过已知IP寻找对应主机的MAC地址 RARP协议是反向地址转换协议，通过MAC地址确定IP地址 ","date":"2021-02-13","objectID":"/linux-network-01/:1:2","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"网络应用程序设计模式 ","date":"2021-02-13","objectID":"/linux-network-01/:2:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"C/S模式 传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信 ","date":"2021-02-13","objectID":"/linux-network-01/:2:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"B/S模式 浏览器(Brower)/服务器(server)模式。只需要在一端部署服务器，而另一端使用每台PC都默认配置的浏览器即可完成数据的传输 ","date":"2021-02-13","objectID":"/linux-network-01/:2:2","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"C/S优缺点 优点 1、协议选用灵活 2、数据可以提前缓存 缺点 1、对用户安全构成威胁 2、开发工作量较大 ","date":"2021-02-13","objectID":"/linux-network-01/:2:3","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"B/S优缺点 优点 1、不会安装第三方软件，安全性高 2、只需要开发服务端，工作量减小 3、可以跨平台 缺点 1、需要支持HTTP协议 2、不能进行数据缓存 ","date":"2021-02-13","objectID":"/linux-network-01/:2:4","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"分层模型 OSI参考模型 TCP/IP模型 应用层-- 表示层 |-\u003e 应用层 会话层-- 传输层 传输层 网络层 网络层 数据链路层-|-\u003e 网络接口层 物理层------ ","date":"2021-02-13","objectID":"/linux-network-01/:3:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"OSI七层模型 1、物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。他的主要作用是传输比特流 2、数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输 3、网络层：在位于不同地理位置的网络中的两个主机系统之间提供链接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层 4、传输层：定义了一些传输数据的协议和端口号(www端口80等)，如：TCP(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，UDP(用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的)。主要是将下层接受的数据进行分段和传输，达到目的地址后再进行重组，常常把这一层数据叫做段。 5、会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求(设备之间需要互相认识可以是IP也可以是MAC或者是主机名)。 6、表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用读取。如：PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码(ASCII)来表示相同字符，如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 7、应用层：是最靠近用户的OSI层，这一层为用户的应用程序(例如电子邮件、文件传输和终端仿真)提供网络服务 ","date":"2021-02-13","objectID":"/linux-network-01/:3:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"TCP/IP四层模型 TCP/IP网络协议栈分为应用层、传输层、网络层、链路层四层 其中应用层典型的是FTP协议，传输层典型的是TCP或UDP协议，网络层典型的是IP协议，链路层典型的是以太网帧协议 TCP/IP模型TCP/IP模型 \"\rTCP/IP模型\r ","date":"2021-02-13","objectID":"/linux-network-01/:3:2","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"通信过程 通信过程通信过程 \"\r通信过程\r ","date":"2021-02-13","objectID":"/linux-network-01/:4:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"协议格式 ","date":"2021-02-13","objectID":"/linux-network-01/:5:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"数据包封装 数据包封装TCP/IP数据包封装 \"\r数据包封装\r ","date":"2021-02-13","objectID":"/linux-network-01/:5:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"java02","date":"2021-02-10","objectID":"/java02/","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"标识符注意点 所有的标识符都应该以字母(A-Z或者a-z)，美元符($)或者下划线(_)开始 首字符之后可以是字母(A-Z或者a-z)，美元符($)，下划线(_)或数字的任何字符组合 不能使用关键字作为变量名或者方法名 标识符是大小写敏感的 合法标识符举例：age、$salary、_value、__1_value 非法标识符举例：123abc、-salary、#abc 可以使用中文命名，但是一般不建议这样去使用，也不建议使用拼音，很Low 数据类型 ","date":"2021-02-10","objectID":"/java02/:0:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"强类型语言 要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用 ","date":"2021-02-10","objectID":"/java02/:1:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"弱类型语言 ","date":"2021-02-10","objectID":"/java02/:2:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"java的数据类型分为两大类 基本类型(primitive type) 数值类型 整数类型 byte占一个字节范围：-128~127 short占两个字节范围：-32768~32767 int占四个字节范围：… long占八个字节范围：… 浮点类型 float占四个字节 double占八个字节 字符类型 char占两个字节 boolean类型：占一位其值只有true和false两个 引用类型(reference type) 类 接口 数组 什么是字节 位(bit)：是计算机内部数据储存的最小单位，11001100是一个八位二进制数 字节(byte)：是计算机数据处理的基本单位，习惯上用大写B来表示 1B(byte，字节) = 8bit(位) 字符：是指计算机中使用的字母、数字、字和符号 1bit表示1位 1Byte表示一个字节 1B=8b 1024B = 1KB 1024KB = 1M 1024M = 1G 类型转换 由于java是强类型语言，所以要进行有些运算的时候，需要用到类型转换 低-\u003e高 byte,short,char-\u003eint-\u003elong-\u003efloat-\u003edouble 运算中，不同的数据类型先转换成同一类型，然后进行运算 强制类型转换 (类型)变量名 高到低 自动类型转换 低到高 注意点： 1、不能对布尔值进行转换 2、不能把对象类型转换成不相关的类型 3、在把高容量转换成低容量的时候，强制转换 4、转换的时候可能存在内存溢出或者精度问题 变量 变量是什么？ 变量就是可以变化的量 java是一种强类型语言，每个变量都必须声明其类型。 java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域 注意事项： 每个变量都有类型，类型可以是基本类型，也可以是引用类型 变量名必须是合法的标识符 变量声明是一条完整的语句，因此每一个声明都必须以分号结束 变量的命名规范 所有变量、方法、类名：见名知意 类成员变量：首字母小写和驼峰原则：monthSalary 局部变量：首字母小写和驼峰原则 常量：大写字母和下划线：MAX_VALUE 类名：首字母大写和驼峰原则：Man，GoodMan 方法名：首字母小写和驼峰原则：run()，runRun() 常量 常量(Constant)：初始化(initialize)后不能再改变值！不会变动的值 所谓常量可以理解为一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变 final 常量名 = 值; 常量名一般使用大写字符 ","date":"2021-02-10","objectID":"/java02/:3:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"java01","date":"2021-02-09","objectID":"/java01/","tags":["java"],"title":"Java01","uri":"/java01/"},{"categories":["学习"],"content":"java是一门跨平台语言(jvm虚拟机) java特性和优势 简单性 面向对象 可移植性(write once, run anywhere) 高性能 分布式 动态性 多线程 安全性 健壮性 java三大版本 javaSE：标准版(桌面程序，控制台开发…) javaME：嵌入式开发(手机，小家电…) javaEE：E企业级开发(web端，服务器开发…) JDK、JRE、JVM JDK：Java Development Kit(java开发者工具) JRE：Java Runtime Environment(java运行时环境) JVM：Java Virtual Machine(java虚拟机) JDK\u003eJRE\u003eJVM","date":"2021-02-09","objectID":"/java01/:0:0","tags":["java"],"title":"Java01","uri":"/java01/"},{"categories":["学习"],"content":"dos常用命令","date":"2021-02-08","objectID":"/dos-code/","tags":["dos"],"title":"Dos Code","uri":"/dos-code/"},{"categories":["学习"],"content":"盘符切换 切换到C盘： c: 切换到E盘： e: 查看当前目录下的所有文件 dir 切换目录 cd change directory cd .. 清理屏幕 cls 退出终端 exit 查看电脑ip ipconfig 打开应用 calc mspaint notepad ping命令 ping 192.168.1.* 文件操作 创建一个文件夹：md 目录名 移除一个文件夹：rd 目录名 创建一个文件： cd\u003e 文件名 移除一个文件： del 文件名","date":"2021-02-08","objectID":"/dos-code/:0:0","tags":["dos"],"title":"Dos Code","uri":"/dos-code/"},{"categories":["学习"],"content":"markdown学习01","date":"2021-02-07","objectID":"/markdown-study01/","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"1 标题 ","date":"2021-02-07","objectID":"/markdown-study01/:0:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"h2 标题 ","date":"2021-02-07","objectID":"/markdown-study01/:1:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"h3 标题 h4 标题 h5 标题 h6 标题、 要添加自定义标题ID，请在与标题相同的行中将自定义ID放在花括号中 ###一个很棒的标题 {#custom-id} 2 注释 注释和HTML兼容的 3 水平线 HTML中的\u003chr\u003e标签是用来在段落元素之间创建一个“专题间隔”的 Markdown可以使用以下方式： -–：三个连续的破折号 ___：三个连续的下划线 ***：三个连续的星号 4 段落 HTML中将用\u003cp\u003e\u003c/p\u003e标签包裹 Markdown直接按照纯文本的方式书写段落 5 内联HTML元素 这是HTML 6 强调 ","date":"2021-02-07","objectID":"/markdown-study01/:1:1","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"加粗 用于强调带有较粗字体的文本片段 以下文本会被渲染为粗体 **渲染为粗体** __渲染为粗体__ 输出的HTML看起来像这样 \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2021-02-07","objectID":"/markdown-study01/:2:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"斜体 用于强调带有斜体的文本片段 以下文本片段被渲染成斜体 *渲染为斜体* _渲染为斜体_ 输出的HTML看起来像这样 \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2021-02-07","objectID":"/markdown-study01/:3:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"删除线 以下文本片段会被渲染成删除线 ~~这段文本带有删除线~~ 输出的HTML看起来像这样 \u003cdel\u003e这段文本带有删除线\u003c/del\u003e 这段文本带有删除线 ","date":"2021-02-07","objectID":"/markdown-study01/:4:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"组合 加粗，斜体和删除线可以组合使用 ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除和斜体*~~ ~~***加粗，斜体和删除线***~~ 输出的HTML看起来像这样 \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003cem\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗，斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e 加粗和斜体 删除线和加粗 删除和斜体 加粗，斜体和删除线 7 引用 用于在文档中引用其他来源的内容块 在要引用的任何文本之前添加\u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage 输出的HTML看起来像这样 \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套 \u003e **Fusion Drive** combines a hard drive with a flash storage \u003e\u003e 111 Fusion Drive combines a hard drive with a flash storage 111 8 列表 ","date":"2021-02-07","objectID":"/markdown-study01/:5:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"无序列表 一系列项的列表，其中项的顺序没有明显关系 你可以使用以下任何符号来表示无序列表中的项 * 一项内容 * 子内容 - 一项内容 + 一项内容 一项内容 子内容 一项内容 一项内容 ","date":"2021-02-07","objectID":"/markdown-study01/:6:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"有序列表 一系列项的列表，其中项的顺序确实很重要 1. a 2. b 3. c 输出的HTML看起来像这样 \u003col\u003e \u003cli\u003ea\u003c/li\u003e \u003cli\u003eb\u003c/li\u003e \u003cli\u003ec\u003c/li\u003e \u003c/ol\u003e a b c ","date":"2021-02-07","objectID":"/markdown-study01/:7:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"任务列表 任务列表使你可以创建带有复选框的列表，要创建列表，请在任务列表项之前添加破折号(-)和带有空格的方括号([ ])，要选择复选框，请在方括号之间添加x([x]) - [x] a - [ ] b - [ ] c Write the press release Update the website Contact the media 9 代码 ","date":"2021-02-07","objectID":"/markdown-study01/:8:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"行内代码 用\\包装行内代码段 在这个例子中, \\\u003csection\u003e\\\u003c/section\u003e 会被包裹成 **代码**. \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e 呈现的输出效果如下： 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. ","date":"2021-02-07","objectID":"/markdown-study01/:9:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"缩进代码 // Some comments line 1 of code line 2 of code line 3 of code 输出的HTML看起来像这样： \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e 呈现的输出效果如下： // Some comments line 1 of code line 2 of code line 3 of code ","date":"2021-02-07","objectID":"/markdown-study01/:10:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"围栏代码块 使用“围栏”```来生成一段带有语言属性的代码块 Sample text here... Sample text here... 10 表格 通过在每个单元格之间添加竖线作为分隔线，并在标题下添加一行破折号(也由竖线分隔)来创建表格，注意竖线不需要垂直对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中 | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 输出的HTML看起来像这样 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 链接 ","date":"2021-02-07","objectID":"/markdown-study01/:11:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 输出的HTML看起来像这样 \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e 呈现的输出效果如下(将鼠标悬停在链接上，没有提示) https://assemble.io contact@revolunet.com Assemble ","date":"2021-02-07","objectID":"/markdown-study01/:12:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 输出的HTML看起来像这样 \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e 呈现的输出效果如下(将鼠标悬停在链接上，会有一行提示) Upstage 12 脚注 脚注使你可以添加注释和参考，而不会使文档正文混乱，当你使用脚注时，会在添加脚注引用的位置出现带有链接的上标标号，读者可以单击链接以跳至页面底部的脚注内容 要创建脚注引用，请在方括号中添加插入符号和标识符 (1)，标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号。 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 (1：这是一段脚注)。你不一定要在文档末尾添加脚注. 可以将它们放在除列表，引用和表格等元素之外的任何位置。 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 13 图片 图片的语法与链接相似，但包含一个在前面的感叹号 ![Minion](https://octodex.github.com/images/minion.png) ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2021-02-07","objectID":"/markdown-study01/:13:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["生活"],"content":"第一篇blog","date":"2021-02-05","objectID":"/first_post/","tags":["我的"],"title":"First_post","uri":"/first_post/"},{"categories":["生活"],"content":"first post LoveIt主题中文文档 emoji表情 去露营啦! ⛺ 很快就回来. 真开心! 😂 blog前置参数注解 ","date":"2021-02-05","objectID":"/first_post/:0:0","tags":["我的"],"title":"First_post","uri":"/first_post/"},{"categories":null,"content":"aa ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]