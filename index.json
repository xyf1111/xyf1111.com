[{"categories":["学习"],"content":"redis学习01","date":"2021-03-11","objectID":"/redis-study-01/","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"NoSQL的四大分类 ","date":"2021-03-11","objectID":"/redis-study-01/:1:0","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"KV键值对 新浪：Redis 美团：Redis+Tair 阿里、百度：Redis+Memecache ","date":"2021-03-11","objectID":"/redis-study-01/:1:1","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"文档型数据库 MongoDB（一般必须掌握） MongoDB是一个基于分布式文件存储的数据库，C++编写，用来处理大量文档 MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，MongoDB是非关系型数据库中功能最丰富的，最像关系型数据库的 ConthDB（国外，不需了解） ","date":"2021-03-11","objectID":"/redis-study-01/:1:2","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"列存储数据库 HBase 分布式文件系统 ","date":"2021-03-11","objectID":"/redis-study-01/:1:3","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"图关系数据库 不是存放图形，是存放关系的 Neo4j、infoGrid ","date":"2021-03-11","objectID":"/redis-study-01/:1:4","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis概述 ","date":"2021-03-11","objectID":"/redis-study-01/:2:0","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis是什么 Redis（Remote Dictionary Server）远程字典服务 是一个开源的使用C语言编写、支持网络，可基于内存亦可持久化的日志型，Key-Value的数据库，提供多种语言的API redis会周期性的把更新的数据写进磁盘或者把修改操作写入追加的记录文件，并在此基础上实现master-slave（主从）同步 ","date":"2021-03-11","objectID":"/redis-study-01/:2:1","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis能干嘛 内存存储，持久化，内存中是断点即失的，所以说持久化很重要（rdb，aof） 效率高，可以用于高速缓存 发布订阅系统 地图信息分析 计时器，计数器 。。。 ","date":"2021-03-11","objectID":"/redis-study-01/:2:2","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis特性 多样的数据类型 持久化 集群 事务 。。。 ","date":"2021-03-11","objectID":"/redis-study-01/:2:3","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"测试Redis性能 ","date":"2021-03-11","objectID":"/redis-study-01/:3:0","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"使用benchmark性能测试 使用Redis-benchmark性能测试 ","date":"2021-03-11","objectID":"/redis-study-01/:3:1","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis基础知识 ","date":"2021-03-11","objectID":"/redis-study-01/:4:0","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis基本操作命令 Redis默认有16个数据库 默认使用第0个数据库 select index，切换数据库 DBSIZE，查看当前数据库大小 keys *，查看当前数据库所有的key flushdb，清除当前数据库 flushall，清除所有数据库 ","date":"2021-03-11","objectID":"/redis-study-01/:4:1","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis是单线程的 Redis是很快的。官方表示Redis是基于内存操作的，CPU并不是Redis的瓶颈Redis是根据机器的内存和网络带宽，可以使用单线程就使用单线程。 ","date":"2021-03-11","objectID":"/redis-study-01/:4:2","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"Redis为什么单线程还这么快 误区1：高性能的服务器一定是多线程的 误区2：多线程（CPU上下文切换）一定比单线程效率高 核心，Redis是将所有的数据全部存放在内存中，所以使用单线程去操作效率就是最高的。多线程（CPU上下文切换：耗时操作），对于内存系统来说，没有上下文切换效率就是最高的。多次读写都是在一个CPU上，在内存情况下，这个就是最优的方案。 ","date":"2021-03-11","objectID":"/redis-study-01/:4:3","tags":["redis"],"title":"Redis Study 01","uri":"/redis-study-01/"},{"categories":["学习"],"content":"redis面试01","date":"2021-03-11","objectID":"/redis-interview-01/","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"概述 ","date":"2021-03-11","objectID":"/redis-interview-01/:1:0","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"什么是Redis Redis是一个使用C语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。 Redis可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持5种数据类型：字符串，列表，集合，散列表，有序集合。 与传统数据库不同的是Redis的数据是存在内存中的，所以读写速度非常快，因此Redis被广泛引用与缓存方向，每秒可以处理11万写操作，8万读操作，是已知性能最快的Key-Value DB。另外，Redis也经常用来做分布式锁。除此之外，Redis支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案。 ","date":"2021-03-11","objectID":"/redis-interview-01/:1:1","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"Redis有哪些优缺点 优点 读写性能优异，Redis能写的速度是11w次/秒，写的速度是8w次/秒 支持数据持久化，支持RDB和AOF两种持久化方式 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性操作 数据结构丰富，除了支持String类型的Value外还支持hash、set、zset、list等数据结构 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离 缺点 数据库容量容易受到物理内存限制，不能作为海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis不具备自动容错和回复功能，主机从机宕机都会导致前端部分读写请求失败，需要等待机器重启或手动切换前端的IP才能回复 主机宕机，宕机前有部分数据未及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。 Redis较难支持在线扩容，在集群容量到达上限时在线扩容会变得很复杂，为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费 ","date":"2021-03-11","objectID":"/redis-interview-01/:1:2","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"为什么要用Redis 高性能： 假如用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将用户访问的数据缓存在缓存中，这样下次再访问这些数据会直接从缓存中获取。操作缓存就是直接操作内存，所以速度相当快，如果数据库中的对应数据改变的之后，同步改变缓存中的对应数据即可。 高并发： 直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。 ","date":"2021-03-11","objectID":"/redis-interview-01/:1:3","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"为什么要用Redis而不用map/guava做缓存 缓存分为本地缓存和分布式缓存。以Java为例，使用自带的map或guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每一个实例需要各自保存一份缓存，缓存不具备一致性。 使用Redis或Memcache之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。确定需要保持redis或memcache服务的高可用，整个程序架构上较为复杂。 ","date":"2021-03-11","objectID":"/redis-interview-01/:1:4","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"Redis为什么这么快 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。 使用多路I/O复用模型，非阻塞IO。 使用底层模型不同，他们之间底层的实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定时间去移动和请求。 ","date":"2021-03-11","objectID":"/redis-interview-01/:1:5","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"数据类型 ","date":"2021-03-11","objectID":"/redis-interview-01/:2:0","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"Redis有哪些数据类型 Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求 ","date":"2021-03-11","objectID":"/redis-interview-01/:2:1","tags":["redis"],"title":"Redis Interview 01","uri":"/redis-interview-01/"},{"categories":["学习"],"content":"mysql面试05","date":"2021-03-11","objectID":"/mysql-interview-05/","tags":["mysql"],"title":"Mysql Interview 05","uri":"/mysql-interview-05/"},{"categories":["学习"],"content":"mysql面试04","date":"2021-03-10","objectID":"/mysql-interview-04/","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"MySQL锁 ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:0","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"MVCC总结 MVCC（多版本并发控制）指的就是在使用READ COMMITTED，REPEATABLE READ这两种隔离级别的事务在执行普通的select操作时访问记录的版本链的过程。可以使不同事务的读-写，写-读操作并发执行，从而提升系统性能。READ COMMITTED、REPEATABLE READ这两个隔离级别一个很大的不同就是：生成ReadView的时机不同，READ COMMITTED是每一次进行普通SELECT操作前都会生成一次ReadView。而REPEATABLE READ只会在第一次进行普通SELECT的时候偶生成ReadView。之后的查询重复使用这个ReadView。 ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:1","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"MySQL锁的介绍 按照锁的粒度来说，MySQL主要包含三种锁：全局锁，表级锁，行级锁 全局锁，锁的是整个database，由MySQL的Sql layer层实现 表级锁，锁的是整张表，由MySQL的Sql layer层实现 行级锁，锁的是某行数据，也可能锁的是行之间的间隙，由存储引擎实现 按照锁的功能来分，可以分为共享锁和排他锁 共享锁：也称S锁，加了S锁，允许其他事务再加S锁，但是不允许其他事务加X锁。加锁方式select … lock in share mode 排他锁：也称X锁，加了X锁，不允许其他事务再加X锁或S锁。加锁方式：select … for update(delete|insert) ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:2","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"不同粒度锁的比较 表级锁：开销小，加锁快。不会出现死锁，锁定粒度大，发生锁冲突概率最高，并发度最低。 这些存储引擎通过总是一次性同时获取所有需要锁以及总是按相同顺序获取表锁避免死锁 表级锁主要适合以查询为主，并发数量少，只有少量按索引条件更新数据的应用，如WEB应用 行级锁：开销大，加锁慢。会出现死锁，锁定粒度最小，发生锁冲突概率最低，并发度也最高 最大程度支持并发，同时也带来了最大的锁开销 在InnoDB中，除单个SQL组成的事务外，锁是逐步获取的，这就决定了在InnoDB发生死锁是可能的 行级锁只是在存储引擎层实现，而MySQL服务层没有实现。行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理系统 ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:3","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"InnoDB锁模式 InnoDB实现了以下两种锁 共享锁（S）：允许一个事务去读行，阻止其他事务获得相同数据集的排他锁 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，这两种锁都是表锁 意向共享锁（IS）：事务打算个数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁 锁与锁之间如果相容，MySQL会给予锁，不相容则会阻塞。 ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:4","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"InnoDB加锁方式 意向锁是InnoDB自动加的，不需用户干预 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加共享锁或排他锁 对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显式给记录集加共享锁或排他锁： 共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。其他session仍然可以查询记录，并也可以对该记录加SHARE MODE的共享锁。但如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE。其他session可以查询该记录。但是不能对该记录加共享锁或排他锁，而是等待获得锁。 隐式锁定 InnoDB在事务执行过程中，使用两阶段锁协议： 随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自行加锁； 锁只有在执行commit或rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。 显示锁定 select … lock in share mode //共享锁 in share mode子句在作用就是将查找到的数据加上一个share锁，这个就是表示其他的事务只能进行简单的select操作，并不能够进行DML操作。 select … lock in share mode使用场景：为了确保自己查到的数据没有被其他事务正在修改，也就是确保查到的数据是最新的数据，并且不允许其他事务来修改数据。但是自己不一定能修改数据，因为有可能其他事务也对这些数据使用了in share mode的方式上了S锁 select … for update //排他锁 在执行这个select查询语句的时候，会将相应的索引访问条目进行上排他锁（X锁），也就是说这个语句对应的锁就相当于update带来的效果 select … for update 的使用场景：为了让自己查到的数据确保是最新的数据，并且查到后的数据只允许自己来修改的时候，需要用到for update子句 性能影响 select … for update语句，相当于一个UPDATE语句。在业务繁忙的情况下，如果事务没有及时的commit或rollback可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。 select … lock in share mode语句是给一个查找语句上一个共享锁（S）的功能，它允许其他事务也对该事务上S锁，但是不能够允许对数据进行修改。如果不及时的commit或rollback也可能造成大量的事务等待。 InnoDB行锁实现方式 InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL和Oracle完全不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只用通过索引条件检索数据，InnoDB才使用行锁，否则InnoDB将使用表锁。 不论是主键索引，唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁 只有在执行计划中真正使用了索引，才能使用行锁：即使在条件中使用了索引字段，但是否使用索引来检索数据是有MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，MySQL就不会使用索引，这种情况下InnoDB将使用表锁，而不是使用行锁。因此在分析锁冲突的时候可以检查SQL的执行计划（可以通过explain检查SQL的执行计划），已确认是否真正使用了索引。 ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:5","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"乐观锁和悲观锁 悲观锁是指在数据处理过程中是数据处于锁定状态。在MySQL中使用悲观锁，必须关闭MySQL自动提交，set autocommit = 0，MySQL默认使用自动提交模式，即使你执行一个更新操作，MySQL会自动将结果提交。 select … for update 是MySQL提供实现悲观锁的方式。执行后该数据将被锁定，直到获得该锁的事务提交或回滚后，锁才能释放。其他要执行该数据的事务才能执行。 乐观锁相对于悲观锁来说，一般来说是不会造成冲突，所以只有在数据提交更新的时候，才会正式对数据的冲突与否进行检测。如果发现冲突了，则让返回错误信息，让用户决定如何去做。 利用数据版本号（version）机制是乐观锁最常用的一种实现方式，一般通过为数据库添加一个version字段，当读取数据的时候，将version字段的数据一同读出，数据每更新一次，对此version值+1。当提交更新的时候，判断数据库对应的当前的版本信息是否与第一次去出来的版本信息相等，相等则予以更新，不相等认为是过期的数据，返回更新失败。 ","date":"2021-03-10","objectID":"/mysql-interview-04/:1:6","tags":["mysql"],"title":"Mysql Interview 04","uri":"/mysql-interview-04/"},{"categories":["学习"],"content":"mysql面试03","date":"2021-03-09","objectID":"/mysql-interview-03/","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"MySQL索引 ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:0","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"MySQL目前主要有以下几种索引类型 普通索引 最基本的索引，没有任何限制，有以下几种创建方式： 直接创建索引 CREATE INDEX index_name ON table(column(length)) 修改表结构的方式添加索引 ALTER TABLE table_name ADD INDEX index_name ON (column(length)) 创建表的时候同时创建索引 CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` char(255) CHARACTER NOT NULL, `content` TEXT CHARACTER NULL, `time` int(10) NULL DEFAULT NULL, PRIMARY KEY (`id`), INDEX index (title(length)) ) 删除索引 DROP INDEX index_name ON table 唯一索引 与前面的普通索引类似。不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一，有以下几种创建方式 创建唯一索引 CREATE UNIQUE INDEX index_name ON table(column(length)) 修改表结构 ALTER TABLE table_name ADD UNIQUE index_name ON table(column(length)) 创建表的时候直接指定 CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` char(255) CHATACTER NOT NULL, `content` text CHARACTER NULL, `time` int(10) NULL DEFAULT NULL, UNIQUE indexName (title(length)) ) 主键索引 是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值，一般建表的时候同时创建主键索引 CREATE TABLE `table` ( `id` int(10) NOT NULL AUTO_INCREMENT, `title` char(255) NOT NULL, PRIMARY KEY (`id`) ) 组合索引 多个字段上创建索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用，使用组合索引遵循最左前缀集合 ALTER TABLE `table` ADD INDEX city_name_age(city, name, age) 全文索引 主要用来查找文本中的关键字，而不是直接与索引中的值进行比较。fulltext（全文索引）跟其他索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where+like。它可以在create table，alter table，create index使用。不过目前只用char，varchar，text列上可以创建全文索引。值得一提的是，在数据量比较大的时候，先将数据放入一个没有全文索引的表中，然后再用CREATE index创建fulltext（全文索引），要比先为一张表建立fulltext全文索引然后再将数据写入快得多。 创建表的时候添加全文索引 CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` char(255) CHARACTER NOT NULL, `content` text CHARACTER NULL, `time` int(10) NULL DEFAULT NULL, PRIMARY KEY (`id`), FULLTEXT (content) ) 修改表结构添加全文索引 ALTER TABLE table ADD FULLTEXT index_content(content) 直接创建索引 CREATE FULLTEXT INDEX index_content ON table(content) ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:1","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"缺点 虽然索引大大提高了查询速度，同时会降低表的更新速度，如对表进行delete，update，insert。因为更新表时，不仅要保存数据，还要保存一下索引文件。 建立索引会建立占用磁盘空间的索引文件。一般这个问题不太严重，但如果在一个大表上创建多种组合索引，索引文件会增长很快。 索引只是提高效率的一个因素，如果有大数据量的表，就需要花时间研究建立优秀索引，或优化查询语句。 ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:2","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"注意事项 索引不会包含有null值的列。只要列中包含null值豆浆不会被包含在索引中，复合索引中只要有一列含有null值，那么这一列对于索引就是无效的。所以在设计数据库的时候尽量不要让字段的默认值为null。 使用短索引 对串列进行索引，如果可能就指定一个前缀长度。例如：一个char(255)的列，如果在前10个或20个字符内，多数值是唯一的，那么就不需要对整列进行索引。短索引不仅可以提高查询速度还可以节省磁盘空间和I/O操作。 索引列排序 查询只用一个索引，因此如果where已经使用了索引，那么order by就不会在使用索引。因此数据库默认排序符合可以符合要求的情况下不要使用排序操作。尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。 like语句操作 一般情况下不推荐使用like，如果非使用不可，如何使用也是一个问题，like“%aaa%”不会使用索引而like“aaa%”可以使用索引。 不要在列上进行运算 这将导致索引失效而进行全表扫描，例如 SELECT * FROM table_name WHERE YEAR(column_name) \u003c 2017 不使用not in和\u003c\u003e操作 ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:3","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"mysql索引类型normal，unique，fulltext的区别是什么 normal：表示普通索引 unique：表示唯一的，不允许出现重复的索引，如果该字段信息不会出现重复。例如使用身份证号作为索引，可以设置为unique fulltext：表示全文搜索的索引，fulltext用于搜索很长一片文章的时候，效果最好。如果就一两行字，使用普通的index也可以。 总结，索引的类别由建立索引的字段内容特性来决定，通常normal最常见。 ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:4","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"实际操作中，应选取表中哪些字段作为索引 建立索引上有7大原则： 选择唯一性索引 为经常需要排序、分组和联合操作的字段建立索引 为常作为查询条件的字段建立索引 限制索引数目 尽量使用数据量小的索引 尽量使用前缀来索引 删除不再使用或很少使用的索引 ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:5","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"聚集索引和非聚集索引区别 聚集索引一个表只有一个，非聚集索引一个表可以有多个 聚集索引存储记录在物理上是连续存在的，而非聚集索引在逻辑上是连续的，物理存储并不连续 ","date":"2021-03-09","objectID":"/mysql-interview-03/:1:6","tags":["mysql"],"title":"Mysql Interview 03","uri":"/mysql-interview-03/"},{"categories":["学习"],"content":"mysql面试02","date":"2021-03-09","objectID":"/mysql-interview-02/","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"事务的四大特性（ACID）原子性，一致性，隔离性，持久性？ ","date":"2021-03-09","objectID":"/mysql-interview-02/:1:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"原子性 根据定义，原子性是指一个事务是一个不可分割的工作单位，其中操作要么都做，要么都不做。不存在中间状态。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:1:1","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"一致性 根据定义一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:1:2","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"隔离性 根据定义，隔离性是指多个事务并发执行时，事务内部操作和其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:1:3","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"持久性 根据定义，持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来其他操作或故障不应该对其有任何影响。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:1:4","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"数据库隔离级别，每个级别会引发什么问题，mysql默认是什么级别的 ","date":"2021-03-09","objectID":"/mysql-interview-02/:2:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"脏读 脏读是指在一个事务中读到另一个未提交事务的数据。 当一个事务正在多次修改某个数据而这个事务中多次修改都尚未提交，此时另一个并发事务来访问该数据，就会造成两个事务得到的数据不一致。 举个例子：A在一个转账事务中，转了100给B，此时，B读到了这个转账数据，然后做了一些操作（发货给A或其他操作），可这个时候A的事务并没有提交，如果A回滚了事务，就会发生数据问题。这就是脏读。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:2:1","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"不可重复读 不可重复读是指对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据。这是由于在查询间隔，被另一个事务修改并提交了。 例如：事务T1读取某一数据，而事务T2马上修改数据并提交给数据库，事务T1再次读取就得到了不同的结果，发生了不可重复读。 不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，不可重复读则是读取了前一事务提交的数据 ","date":"2021-03-09","objectID":"/mysql-interview-02/:2:2","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"幻读 幻读是指事务非独立执行时发生的一种现象。 例如：事务T1对一个表中的所有的行的某一数据做了从1修改为2的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项还是1并且提交给了数据库。而事务T1如果再次查看刚刚修改的数据，会发现还有一行未修改，其实这行是T2添加的，就好像产生了幻觉。这就是幻读。 幻读和不可重复读的区别，幻读和不可重复读都是读取另一个以提交的事务（这点就和脏读不同），不同的是，不可重复读查询的都是同一个数据项，而幻读是针对一批数据整体（比如数据个数） ","date":"2021-03-09","objectID":"/mysql-interview-02/:2:3","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MySQL提供的四种隔离模式 Serializable（串行化）：可以避免脏读，不可重复读和幻读的发生。 Repeatable read（可重复读）：可以避免脏读，不可重复读的发生。 Read committed（读已提交）：可避免脏读的发生。 Read uncommitted（读未提交）：最低级别，都无法避免。 以上四种模式最高是Serializable级别，最低是Read uncommitted级别。级别越高效率越低。像是Serializable这样的级别就是以锁表的方式使得其他事务只能在锁外等待。MySQL数据库默认的级别为Read committed ","date":"2021-03-09","objectID":"/mysql-interview-02/:2:4","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别 ","date":"2021-03-09","objectID":"/mysql-interview-02/:3:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"InnoDB 支持事务，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大优势。如果需要频繁的更新，删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback） ","date":"2021-03-09","objectID":"/mysql-interview-02/:3:1","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MyISAM 插入数据快，空间和内存使用比较低。如果表主要是用于插入新数据和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性和并发性要求比较低，也可以使用。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:3:2","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MEMORY 所有数据都在内存中，数据的处理快，但是安全性不高，如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMORY。其对表的大小有所要求，不能建立太大的表。所以这类数据库只使用在相对较小的数据库表。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:3:3","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MySQL的MyISAM和InnoDB两种存储引擎在事务、锁级别，各自的使用场景 ","date":"2021-03-09","objectID":"/mysql-interview-02/:4:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MyISAM特点 不支持行锁（MyISAM只有表锁），读取时对需要读到的所有表进行加锁，写入时则对表加排它锁 不支持事务 不支持外键 不支持崩溃后安全修复 在表有读取查询时，支持往表中插入新数据 支持BLOG和TEXT的前500个字符索引，支持全文索引 支持延时更新索引，极大的提升写入性能 对于不会进行修改的表，支持压缩表，极大的减少对磁盘空间的占用 ","date":"2021-03-09","objectID":"/mysql-interview-02/:4:1","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"InnoDB特点 支持行锁，采用MVCC来支持高并发，有可能死锁 支持事务 支持外键 支持崩溃后的安全修复 不支持全文索引 ","date":"2021-03-09","objectID":"/mysql-interview-02/:4:2","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"各自的使用场景 MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询时，那么MyISAM是更好的选择。 InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。 但是实际场景中，针对具体问题具体分析，一般遵循以下几个问题？ 数据库是否有外键 是否需要事务支持 是否需要全文索引 数据库经常使用什么查询模式？在写多读少的应用中还是InnoDB插入性能更稳定，在并发情况下也基本，如果是对读取速度要求比较快的应用还是选MyISAM 数据库的数据大小？大尺寸倾向与InnoDB，因为有事务日志，故障修复 ","date":"2021-03-09","objectID":"/mysql-interview-02/:4:3","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"SQL查询语句（where，join，limit，group by，having）执行先后顺序 一个查询语句同时出现以上关键词时执行顺序是： 执行where xxx对全表数据做筛选，返回第一个结果集 针对第一个结果集使用group by分组，返回第二个结果集 针对第二个结果集中的每一组数据执行select xxx，有几组就执行几次，返回第三个结果集 针对第三个结果集执行having xxx进行筛选，返回第四个结果集 针对第四个结果集排序 总结一个顺序：我（W）哥（G）是（SH）偶（O）像（W-\u003eG-\u003eS-\u003eH-\u003eO） ","date":"2021-03-09","objectID":"/mysql-interview-02/:5:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"什么是临时表，临时表什么时候删除 ","date":"2021-03-09","objectID":"/mysql-interview-02/:6:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"什么是临时表 MySQL用于存储一些中间结果集的表，临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:6:1","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"为什么会产生临时表 一般是由于复杂的SQL导致临时表被大量创建 ","date":"2021-03-09","objectID":"/mysql-interview-02/:6:2","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"临时表的分类 临时表分为两种，一种是内存临时表，一种是磁盘临时表。内存临时表采用的是MEMORY存储引擎，磁盘临时表采用的是MyISAM存储引擎（磁盘临时表也可以使用InnoDB存储引擎，通过参数来控制使用那种存储引擎，从MySQL5.7.6版本后默认为InnoDB存储引擎，之前版本一直默认的是MyISAM存储引擎） ","date":"2021-03-09","objectID":"/mysql-interview-02/:6:3","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"下面操作会使用到临时表 union查询 对于视图操作，比如使用一些TEMPTABLE算法，union或aggregation 子查询 join包括not in，exist等 查询产生的派生表 复杂的group by或order by insert，select同一个表，mysql会产生一个临时表缓存select行 多个表更新 GROUP_CONCAT()或COUNT(DISTINCT) ","date":"2021-03-09","objectID":"/mysql-interview-02/:6:4","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MySQL以下操作会阻止内存临时表的建立，直接使用磁盘临时表 表含有BLOG或TEXT列 使用union或union all时，select子句有大于512字节的列 Show columns或desc表时，有LOB或TEXT GROUP BY或DISTINCY子句中包含列大于512字节的列 ","date":"2021-03-09","objectID":"/mysql-interview-02/:6:5","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"MySQL B+Tree索引和Hash索引的区别 ","date":"2021-03-09","objectID":"/mysql-interview-02/:7:0","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"区别 由于Hash索引结构的特殊性，其检索效率特别高，索引的检索可以一次定位，不想B-Tree索引需要从根节点到枝节点，最后才能访问到叶节点这样多次访问，所以Hash索引的查询效率是要远高于B-Tree索引 ","date":"2021-03-09","objectID":"/mysql-interview-02/:7:1","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"为何采用B-Tree而不采用Hash 任何事物都有两面性，Hash索引也一样，虽然Hash索引效率高，但是Hash索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些 Hash索引仅仅能满足于“=”，“in”和“\u003c=\u003e”查询，不能使用范围查询。 由于Hash索引比较的是Hash运算之后的Hash值，所以只能使用等值过滤，不能用于基于范围的过滤，因为经过相应的Hash算法处理后的Hash值的大小关系，并不能保证和Hash运算前完全一样 Hash索引无法用来避免数据的排序操作。 由于Hash索引中存放是经过Hash计算之后的Hash值，而且Hash值的大小关系还不一定和Hash运算之前的键值完全一样，所以数据库无法通过索引的数据来避免任何排序运算 Hash索引不能利用部分索引键查询 对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用。 Hash索引在任何时候都不能避免表扫描 Hash索引是将索引键通过Hash运算后，将Hash运算结果和所对应的指针信息存放在一个Hash表中由于不同的索引键中存在相同的Hash值，所以即使满足某个Hash键值数据的记录条数也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。 Hash索引遇到大量Hash值相等的情况后性能就不一定比B-Tree高 对于选择性较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样会浪费多次表数据访问，造成整体性能低下。 ","date":"2021-03-09","objectID":"/mysql-interview-02/:7:2","tags":["mysql"],"title":"Mysql Interview 02","uri":"/mysql-interview-02/"},{"categories":["学习"],"content":"mysql面试01","date":"2021-03-08","objectID":"/mysql-interview-01/","tags":["mysql"],"title":"Mysql Interview 01","uri":"/mysql-interview-01/"},{"categories":["学习"],"content":"drop、delete和truncate分别在什么场景下使用？对比一下区别 ","date":"2021-03-08","objectID":"/mysql-interview-01/:1:0","tags":["mysql"],"title":"Mysql Interview 01","uri":"/mysql-interview-01/"},{"categories":["学习"],"content":"drop table 属于DDL 不可回滚 不可带where 表内容结构删除 删除速度快 ","date":"2021-03-08","objectID":"/mysql-interview-01/:1:1","tags":["mysql"],"title":"Mysql Interview 01","uri":"/mysql-interview-01/"},{"categories":["学习"],"content":"truncate table 属于DDL 不可回滚 不可带where 表内容删除 速度快 ","date":"2021-03-08","objectID":"/mysql-interview-01/:1:2","tags":["mysql"],"title":"Mysql Interview 01","uri":"/mysql-interview-01/"},{"categories":["学习"],"content":"delete from 属于DML 可回滚 可带where 表结构在，表内容看具体where 删除速度慢 ","date":"2021-03-08","objectID":"/mysql-interview-01/:1:3","tags":["mysql"],"title":"Mysql Interview 01","uri":"/mysql-interview-01/"},{"categories":["学习"],"content":"使用场景 不再需要一张表的时候，使用drop 想删除部分数据行时候，使用delete，并且带上where子句 想保留表结构而删除所有数据时，使用truncate ","date":"2021-03-08","objectID":"/mysql-interview-01/:1:4","tags":["mysql"],"title":"Mysql Interview 01","uri":"/mysql-interview-01/"},{"categories":["学习"],"content":"mysql优化01","date":"2021-03-08","objectID":"/mysql-optimize-01/","tags":["mysql"],"title":"Mysql Optimize 01","uri":"/mysql-optimize-01/"},{"categories":["学习"],"content":"优化的方面 表设计 范式 存储引擎 字段类型 功能 索引 缓存 分区 sql语句 合理的sql 经验 架构 主从复制 负载均衡 读写分离 ","date":"2021-03-08","objectID":"/mysql-optimize-01/:1:0","tags":["mysql"],"title":"Mysql Optimize 01","uri":"/mysql-optimize-01/"},{"categories":["生活"],"content":"简历","date":"2021-03-07","objectID":"/resume/","tags":["简历"],"title":"Resume","uri":"/resume/"},{"categories":["生活"],"content":"陈进煌 ","date":"2021-03-07","objectID":"/resume/:1:0","tags":["简历"],"title":"Resume","uri":"/resume/"},{"categories":["生活"],"content":"个人信息 性别：男 年龄：24 手机号：18759882615 邮箱：2219316464@qq.com 专业：计算机科学与技术 应聘岗位：Golang开发工程师 ","date":"2021-03-07","objectID":"/resume/:2:0","tags":["简历"],"title":"Resume","uri":"/resume/"},{"categories":["生活"],"content":"工作及教育经历 厦门美城行动科技有限公司 2019-08~至今 软件研发部-后端开发 厦门青叶软件股份有限公司 2019-03~2019-07 软件研发部-后端开发 厦门通元微智能科技有限公司 2018-03~2018~11 软件研发部-软件测试 三明学院 2014-09~2018-07 计算机科学与技术 ","date":"2021-03-07","objectID":"/resume/:3:0","tags":["简历"],"title":"Resume","uri":"/resume/"},{"categories":["生活"],"content":"专业技能 掌握Golang，了解Java，C++，C等编程语言 掌握基础数据结构和算法的基本原理 等等 ","date":"2021-03-07","objectID":"/resume/:4:0","tags":["简历"],"title":"Resume","uri":"/resume/"},{"categories":["生活"],"content":"项目经历 厦门美城行动管理系统 后端开发 2019-08~至今 项目介绍：这个项目是公司的后台管理系统。该系统主要是对公司对应的小程序和app提供数据的统计展示和管理等。系统后端是采用beego框架，数据库使用mysql，部分功能使用到redis进行缓存。系统前端采用react框架，大部分使用antdesign的UI组件。 我的职责： 根据实际业务需求，与产品经理确定具体功能及展现方式。 依据具体功能进行数据表的设计。 实现具体功能编写管理系统前端展示代码，与产品进行确认。 根据前端界面确定后台的接口，进行后台代码数据操作代码的编写。 若小程序，app有该功能相关的，为其提供相应的接口。 提交Git，交付测试进行测试。 根据测试提交的bug对代码进行调试修改。 主要实现功能： 考试模块 这个功能实现功能如下： 1、题库管理，在题库中对试卷题目，答案等进行数据操作。 2、试卷管理，编辑试卷名称等具体信息，从题库中筛选题目，从用户列表中筛选用户参与该试卷考试。 3、分数排行榜，对试卷分数进行统计，排行及数据展示。 功能难点： 1、用户小程序上提交试卷后展示考试成绩 2、试卷修改时，用户提交过的试卷内容不变 难点解决： 1、使用redis对答案数据进行缓存，用户提交后根据试卷id获取对应缓存数据，进行对比，统计分数并返回。 2、将用户提交的试卷数据序列化进行保存，展示时再反序列化。 ","date":"2021-03-07","objectID":"/resume/:5:0","tags":["简历"],"title":"Resume","uri":"/resume/"},{"categories":["实例"],"content":"Go Instance 12-排序","date":"2021-03-03","objectID":"/go-instance-12/","tags":["golang"],"title":"Go Instance 12","uri":"/go-instance-12/"},{"categories":["实例"],"content":"sort自带排序 Go 的 sort 包实现了内置和用户自定义数据类型的排序功能 package main import ( \"fmt\" \"sort\" ) func main() { //排序方法是正对内置数据类型的；这里是一个字符串的例子。 // 注意排序是原地更新的，所以他会改变给定的序列并且不返回一个新值。 strs := []string{\"c\", \"b\", \"d\", \"a\"} sort.Strings(strs) fmt.Println(strs) //一个 int 排序的例子。 ints := []int{4,2,3,1} sort.Ints(ints) fmt.Println(ints) //我们也可以使用 sort 来检查一个序列是不是已经是排好序的。 sorted := sort.IntsAreSorted(ints) fmt.Println(sorted) } ","date":"2021-03-03","objectID":"/go-instance-12/:1:0","tags":["golang"],"title":"Go Instance 12","uri":"/go-instance-12/"},{"categories":["实例"],"content":"Go Instance 11-Go协程状态","date":"2021-02-28","objectID":"/go-instance-11/","tags":["golang"],"title":"Go Instance 11","uri":"/go-instance-11/"},{"categories":["实例"],"content":"Go协程状态 在前面的例子中，我们用互斥锁进行了明确的锁定来让共享的state 跨多个 Go 协程同步访问。另一个选择是使用内置的 Go协程和通道的的同步特性来达到同样的效果。这个基于通道的方法和 Go 通过通信以及 每个 Go 协程间通过通讯来共享内存，确保每块数据有单独的 Go 协程所有的思路是一致的。 package main import ( \"fmt\" \"math/rand\" \"sync/atomic\" \"time\" ) //在这个例子中，state将被一个单独的协程拥有 //这就能保证数据在并行读取时不会混乱，为了对state进行读取或写入 //其他Go协程将发送一条数据到拥有的Go协程中，然后接受对应的回复 //结构体readOp和writeOp封装这些状态，并且是拥有Go协程响应的一个方式 type readOp struct { key int resp chan int } type writeOp struct { key int value int resp chan bool } func main() { //计算执行操作的次数 var ops int64 = 0 //reads和writes通道分别将被其他Go协程用来发布读和写请求 reads := make(chan *readOp) writes := make(chan *writeOp) //这个就是拥有state的协程。这个协程的state是私有的 //这个Go协程反复响应到达的请求 //先响应到达的请求，然后返回一个值到响应通道resp表示操作成功 go func() { var state = make(map[int]int) for { select { case read := \u003c- reads: read.resp \u003c- state[read.key] case write := \u003c- writes: state[write.key] = write.value write.resp \u003c- true } } }() //启动100个协程通过reads通道发起对state所有者Go协程的读取请求 //每个读取请求需要构建一个readOp，发送它到reads通道中，并通过给定的resp接收结果 for i := 0; i \u003c 100; i++ { go func() { for { read := \u0026 readOp{ key: rand.Intn(5), resp: make(chan int), } reads \u003c- read \u003c- read.resp atomic.AddInt64(\u0026ops, 1) } }() } //用相同的方法启动10个写操作 for i := 0; i \u003c 10; i++ { go func() { for { write := \u0026writeOp{ key: rand.Intn(5), value: rand.Intn(100), resp: make(chan bool), } writes \u003c- write \u003c- write.resp atomic.AddInt64(\u0026ops, 1) } }() } //让Go协程先跑1秒 time.Sleep(time.Second) //最后获取并显示ops值 opsfinal := atomic.LoadInt64(\u0026ops) fmt.Println(opsfinal) } ","date":"2021-02-28","objectID":"/go-instance-11/:1:0","tags":["golang"],"title":"Go Instance 11","uri":"/go-instance-11/"},{"categories":["实例"],"content":"Go Instance 10-原子计数器，互斥锁","date":"2021-02-28","objectID":"/go-instance-10/","tags":["golang"],"title":"Go Instance 10","uri":"/go-instance-10/"},{"categories":["实例"],"content":"原子计数器 Go中最主要的状态管理方法是通过通道之间的通信完成的。在工作池的例子中有遇到，但是还是有一些其他方式来管理状态。如何使用sync/atomic包在多个Go协程中进行原子计数 package main import ( \"fmt\" \"runtime\" \"sync/atomic\" \"time\" ) //原子计数器 func main() { //使用一个无符号整型(永远是正整数)来代表这个计数器 var ops uint64 = 0 //为了模拟并发更新，启动50个协程，对计数器每个1毫秒进行一次加一操作 for i := 0; i \u003c 50; i++ { go func() { for { //使用AddUint64来让计数器自动增加，使用\u0026语法来抛出ops内存地址 atomic.AddUint64(\u0026ops, 1) //允许其他Go协程执行 runtime.Gosched() } }() } //等待1秒,让Go协程有时间运行 time.Sleep(time.Second) //在计数器还在被其他Go协程更新时,安全的使用 //通过LoadUint将当前值拷贝到opsfinal //LoadUint64 需要的是内存地址 opsfinal := atomic.LoadUint64(\u0026ops) fmt.Println(opsfinal) } ","date":"2021-02-28","objectID":"/go-instance-10/:1:0","tags":["golang"],"title":"Go Instance 10","uri":"/go-instance-10/"},{"categories":["实例"],"content":"互斥锁 相较于简单的原子计数器，对于更复杂的情况，可以使用一个互斥锁在Go协程里安全的访问数据 package main import ( \"fmt\" \"math/rand\" \"runtime\" \"sync\" \"sync/atomic\" \"time\" ) func main() { //在这个例子中state是一个map var state = make(map[int]int) //这里的mutex将同步对mutex的访问 var mutex = \u0026sync.Mutex{} //为了比较基于互斥锁的处理方式和其他方式，ops将记录对state的操作次数 var ops int64 = 0 //运行100Go协程同时读取state for i := 0; i \u003c 100; i++ { go func() { total := 0 for { //每次循环读取，使用一个键进行访问 //Lock()这个mutex来确保对state的独占访问，读取选定键的值 //Unlock()这个state并使ops+1 key := rand.Intn(5) //fmt.Println(\"key:\", key) mutex.Lock() total += state[key] mutex.Unlock() atomic.AddInt64(\u0026ops, 1) //为了确保这个Go协程不会在调度中饿死 //每次操作后明确使用runtime.Gosched()进行释放 //这个释放一般是自动处理的，例如每个通道操作后或者time.Sleep的阻塞调用后相似 //但在这个例子中需要手动处理 runtime.Gosched() } }() } //运行10个Go协程来模拟写操作，使用和读取相同模式 for i := 0; i \u003c 10; i++ { go func() { for { key := rand.Intn(5) value := rand.Intn(100) mutex.Lock() state[key] = value mutex.Unlock() atomic.AddInt64(\u0026ops, 1) runtime.Gosched() } }() } //让这10个Go协程对state和mutex的操作运行1秒 time.Sleep(time.Second) //获取并输出最终操作数 opsFinal := atomic.LoadInt64(\u0026ops) fmt.Println(\"ops:\", opsFinal) //对state使用一个最终锁，显示是如何结束的 mutex.Lock() fmt.Println(state) mutex.Unlock() } ","date":"2021-02-28","objectID":"/go-instance-10/:2:0","tags":["golang"],"title":"Go Instance 10","uri":"/go-instance-10/"},{"categories":["实例"],"content":"Go Instance 09-速率限制","date":"2021-02-27","objectID":"/go-instance-09/","tags":["golang"],"title":"Go Instance 09","uri":"/go-instance-09/"},{"categories":["实例"],"content":"速率限制 速率限制(英) 是一个重要的控制服务资源利用和质量的途径。Go 通过 Go 协程、通道和打点器优美的支持了速率限制。 package main import ( \"fmt\" \"time\" ) func main() { //基本速率限制 //如果想限制接收请求处理，可以将这些请求发送到一个相同通道 requests := make(chan int, 5) for i := 1; i \u003c= 5; i++ { requests \u003c- i } close(requests) //这个tick通道将每200毫秒接收一个值，这个是速率限制任务中的管理器 tick := time.Tick(time.Millisecond * 200) //通过在每次请求前阻塞tick通道的一个接收，限制每隔200毫秒接收一个值 for row := range requests { \u003c-tick fmt.Println(\"request:\", row, time.Now()) } //有时候想临时进行速率限制，并且不影响整体速率控制可以使用通道缓冲来实现 //burstyLimter通道用来进行3次临时的脉冲型速率限制 burstyLimter := make(chan time.Time, 3) //将需要临时改变值传入 for i := 0; i \u003c 3; i++ { burstyLimter \u003c- time.Now() } //每个200毫秒添加一个新值到通道内，直到达到3个限制 go func() { for t := range time.Tick(time.Millisecond * 200) { burstyLimter \u003c- t } }() //现在模拟5个接入请求 //刚开始3个受临时的脉冲影响 burstyRequests := make(chan int, 5) for i := 0; i \u003c 5; i++ { burstyRequests \u003c- i } close(burstyRequests) for row := range burstyRequests { \u003c- burstyLimter fmt.Println(\"request2: \", row, time.Now()) } } 运行程序，将看到第一批请求意料之中的大约每 200ms 处理一次。第二批请求，我们直接连续处理了 3 次，这是由于这个“脉冲”速率控制，然后大约每 200ms 处理其余的 2 个。 ","date":"2021-02-27","objectID":"/go-instance-09/:1:0","tags":["golang"],"title":"Go Instance 09","uri":"/go-instance-09/"},{"categories":["实例"],"content":"Go Instance 08-模拟工作池","date":"2021-02-26","objectID":"/go-instance-08/","tags":["golang"],"title":"Go Instance 08","uri":"/go-instance-08/"},{"categories":["实例"],"content":"工作池 在这个例子中，将看到如何使用GO协程和通道实现一个工作池 package main import ( \"fmt\" \"time\" ) //这是将要在多个并发实例中支持的任务 //这些执行者将从jobs通道接收任务，并通过results发送对应结果 //让每个任务睡1秒，模拟耗时任务 func worker(i int, jobs \u003c-chan int, results chan\u003c- int) { for j := range jobs{ fmt.Printf(\"worker %d processing job %d \\n\", i, j ) time.Sleep(time.Second) results \u003c- j } } func main() { //使用worker工作池并收集结果，需要两个通道 jobs := make(chan int, 100) results := make(chan int, 100) //这里启动三个worker，初始是阻塞的，因为还没有任务 for i := 1; i \u003c= 3; i++ { go worker(i, jobs, results) } //发送9个任务，然后close表示这些就是所有任务了 for i := 1; i \u003c= 9; i++ { jobs \u003c- i } close(jobs) //收集所有任务的返回值 for i := 1; i \u003c= 9; i++ { \u003c-results } } 执行这个程序，显示9个任务被多个worker执行。整个程序处理所有任务仅执行了3秒，因为是3个worker并行的 ","date":"2021-02-26","objectID":"/go-instance-08/:1:0","tags":["golang"],"title":"Go Instance 08","uri":"/go-instance-08/"},{"categories":["实例"],"content":"Go Instance 07-Go定时器和打点器","date":"2021-02-25","objectID":"/go-instance-07/","tags":["golang"],"title":"Go Instance 07","uri":"/go-instance-07/"},{"categories":["实例"],"content":"定时器 当需要在后面一个时刻运行Go代码，或者在某段时间内重复运行。Go内置的定时器和打点器让这些很容易实现 package main import ( \"fmt\" \"time\" ) func main() { //定时器表示在未来某一时刻的独立事件 //提供定时器需要的时间，定时器将提供一个用于通知的通道 //这里设置定时器将等待2秒 timer1 := time.NewTimer(time.Second * 2) //\u003c-timer1.C 直到这个定时器的通道C明确的发送了定时器失效的值之前，一直阻塞 \u003c-timer1.C fmt.Println(\"Timer 1 expired\") //如果需要的仅仅是等待，可以使用Sleep //定时器有用的原因之一是可以在定时器失效前取消定时器 timer2 := time.NewTimer(time.Second * 2) go func() { \u003c- timer2.C fmt.Println(\"Timer 2 expired\") }() stop := timer2.Stop() if stop { fmt.Println(\"Timer 2 stop\") } } 第一个定时器将在程序开始后2秒失效，第二个在其还没失效前就被停止了 ","date":"2021-02-25","objectID":"/go-instance-07/:1:0","tags":["golang"],"title":"Go Instance 07","uri":"/go-instance-07/"},{"categories":["实例"],"content":"打点器 定时器是当你想要在未来某一时刻执行一次时使用，打点器是当你想要在固定的时间间隔重复执行准备的。这是一个打点器的例子，它将定时执行，直到我们将它停止 package main import ( \"fmt\" \"time\" ) func main() { //打点器和定时器的机制有点相似：一个通道用来发送数据。 // 这里我们在这个通道上使用内置的 range 来迭代值每隔500ms 发送一次的值。 ticker := time.NewTicker(time.Millisecond * 500) go func() { for t := range ticker.C { fmt.Println(\"Tick at \", t) } }() //打点器可以和定时器一样被停止。一旦一个打点停止了，将不能再从它的通道中接收到值。 // 我们将在运行后 1600ms停止这个打点器。 time.Sleep(time.Millisecond * 1000) ticker.Stop() fmt.Println(\"Ticker stopped\") } ","date":"2021-02-25","objectID":"/go-instance-07/:2:0","tags":["golang"],"title":"Go Instance 07","uri":"/go-instance-07/"},{"categories":["生活"],"content":"学习进度","date":"2021-02-25","objectID":"/learning-process/","tags":["我的"],"title":"Learning Process","uri":"/learning-process/"},{"categories":["生活"],"content":"狂神说java java零基础学习视频通俗易懂(p27) ","date":"2021-02-25","objectID":"/learning-process/:1:0","tags":["我的"],"title":"Learning Process","uri":"/learning-process/"},{"categories":["生活"],"content":"Tears-Tearing Google资深工程师带你通关golang/go语言(p43) ","date":"2021-02-25","objectID":"/learning-process/:2:0","tags":["我的"],"title":"Learning Process","uri":"/learning-process/"},{"categories":["生活"],"content":"崔永华csdn博客 单元测试案例 学习go语言必备案例(4) ","date":"2021-02-25","objectID":"/learning-process/:3:0","tags":["我的"],"title":"Learning Process","uri":"/learning-process/"},{"categories":["实例"],"content":"Go Instance 06-defer+recover解决panic","date":"2021-02-23","objectID":"/go-instance-06/","tags":["golang"],"title":"Go Instance 06","uri":"/go-instance-06/"},{"categories":["实例"],"content":"defer+recover解决panic导致程序崩溃 ","date":"2021-02-23","objectID":"/go-instance-06/:1:0","tags":["golang"],"title":"Go Instance 06","uri":"/go-instance-06/"},{"categories":["实例"],"content":"案例1 如果我们起了一个协程，但这个协程出现了panic，但我们没有捕获这个协程，就会造成程序的崩溃，这时可以在goroutine中使用recover来捕获panic，进行处理，这样主线程不会受到影响 package main import ( \"fmt\" \"time\" ) func sayhello() { for i := 0; i \u003c 10; i++ { fmt.Println(\"hello\") time.Sleep(time.Second) } } func test() { //使用defer+recover defer func() { //捕获test抛出的panic if err := recover(); err != nil { fmt.Println(\"test 发生错误：\", err) } }() var myMap map[int]string myMap[0] = \"golang\" } func main() { go sayhello() go test() for i := 0; i \u003c 10; i++ { fmt.Println(\"main() ok=\", i) time.Sleep(time.Second) } } ","date":"2021-02-23","objectID":"/go-instance-06/:1:1","tags":["golang"],"title":"Go Instance 06","uri":"/go-instance-06/"},{"categories":["实例"],"content":"Go Instance 05-select解决通道堵塞","date":"2021-02-23","objectID":"/go-instance-05/","tags":["golang"],"title":"Go Instance 05","uri":"/go-instance-05/"},{"categories":["实例"],"content":"使用select解决从管道取数据堵塞问题 使用select解决从管道取数据堵塞的问题，语法如下： select语法\u0026ldquo;select语法\u0026rdquo; \"\rselect语法\r package main import ( \"fmt\" \"time\" ) func main() { //定义一个管道，可以放10个int类型数据 intChan := make(chan int, 10) for i := 0; i \u003c 10; i++ { intChan \u003c- i } //定义一个管道，可以放5个string类型数据 stringChan := make(chan string, 5) for i := 0; i \u003c 5; i++ { stringChan \u003c- \"hello\" + fmt.Sprintf(\"%d\", i) } //传统的方法遍历管道时，如果不关闭会阻塞而导致deadlock //实际开发中，不好确定什么时候关闭通道 //这时可以使用select方式解决 //label for { select { //管道不关闭不会deadlock，会自动到下一个case匹配 case v := \u003c-intChan: fmt.Printf(\"从intChan读取的数据%d\\n\", v) time.Sleep(time.Second) case v := \u003c-stringChan: fmt.Printf(\"从stringChan读取的数据%v\\n\", v) time.Sleep(time.Second) default: fmt.Printf(\"取不到数据\\n\") time.Sleep(time.Second) return //break label } } } ","date":"2021-02-23","objectID":"/go-instance-05/:1:0","tags":["golang"],"title":"Go Instance 05","uri":"/go-instance-05/"},{"categories":["实例"],"content":"Go Instance 04-goroutine和channel","date":"2021-02-23","objectID":"/go-instance-04/","tags":["golang"],"title":"Go Instance 04","uri":"/go-instance-04/"},{"categories":["实例"],"content":"goroutine和channel ","date":"2021-02-23","objectID":"/go-instance-04/:1:0","tags":["golang"],"title":"Go Instance 04","uri":"/go-instance-04/"},{"categories":["实例"],"content":"goroutine和channel协同工作 具体要求 开启一个writeData协程，向管道intChan中写入50个整数 开启一个readData协程，从管道intChan中读取writeData写入的数据 注意writeData和readData操作的是同一个管道 主线程需要等待writeData和readData协程都完成工作才能退出管道 思路分析 思路分析\u0026ldquo;思路分析\u0026rdquo; \"\r思路分析\r package main import \"fmt\" func writeData(intChan chan int) { for i := 1; i \u003c= 50; i++ { intChan \u003c-i fmt.Println(\"write:\", i) } close(intChan) } func readData(intChan chan int, exitChan chan bool) { for { n, ok := \u003c-intChan if !ok { break } fmt.Println(\"read:\", n) } exitChan \u003c- true close(exitChan) } func main() { intChan := make(chan int, 50) exitChan := make(chan bool, 1) go writeData(intChan) go readData(intChan, exitChan) for { _, ok := \u003c-exitChan if !ok { break } } } 读和写频率不一样也没有问题 package main import ( \"fmt\" \"time\" ) func writeData(intChan chan int) { for i := 0; i \u003c 50; i++ { intChan \u003c- i fmt.Println(\"write:\", i) } close(intChan) } func readData(intChan chan int, exitChan chan bool) { for { v, ok := \u003c-intChan if !ok { break } time.Sleep(time.Second) fmt.Println(\"read:\", v) } exitChan \u003c- true close(exitChan) } func main() { intChan := make(chan int, 10) exitChan := make(chan bool, 1) go writeData(intChan) go readData(intChan, exitChan) for { if _, ok := \u003c-exitChan; !ok{ break } } } 注意：如果只向管道写入数据而没有读取，就会造成堵塞而deadlock ","date":"2021-02-23","objectID":"/go-instance-04/:1:1","tags":["golang"],"title":"Go Instance 04","uri":"/go-instance-04/"},{"categories":["学习"],"content":"Go Study 15-channel","date":"2021-02-22","objectID":"/go-study-15/","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"channel ","date":"2021-02-22","objectID":"/go-study-15/:1:0","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"channel ","date":"2021-02-22","objectID":"/go-study-15/:1:1","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"buffered channel(带缓冲区的channel) ","date":"2021-02-22","objectID":"/go-study-15/:1:2","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"range(关闭channel) ","date":"2021-02-22","objectID":"/go-study-15/:1:3","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"理论基础Communication Sequential Process(CSP) ","date":"2021-02-22","objectID":"/go-study-15/:1:4","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-22","objectID":"/go-study-15/:2:0","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"channel(通道) 通道是连接多个Go协程的管道，可以从一个Go协程将值发送到通道，然后在别的Go协程中接收 package main import ( \"fmt\" ) func channel1() { //使用make(chan val-type)创建一个新的通道 //通道类型就是传递值的类型 message := make(chan string) //使用 channel \u003c- 语法发送一个新的值到通道中 go func() { message \u003c- \"ping\" }() fmt.Println(message) //使用 \u003c- channel 语法从通道中获取一个值 msg := \u003c- message fmt.Println(msg) } func main() { channel1() } 运行程序时，通过通道，消息“ping”成功的从一个Go协程传到另一个。默认发送和接收操作是阻塞的，直到发送方和接收方都准备完毕。这个特性允许不使用任何其他的同步操作，可以在程序结尾等待消息“ping” ","date":"2021-02-22","objectID":"/go-study-15/:2:1","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"通道缓冲 默认通道是无缓冲的，这意味着只有在对应的接收(\u003c-chan)通道准备好接收时才允许发送(chan\u003c-)。可缓冲通道允许在没有接收方的情况下，缓存限定数量的值 package main import ( \"fmt\" ) func channel2() { //这里make了一个通道，最多允许缓存2个值 message := make(chan string, 2) //因为这个通道有缓冲区，即使没有一个对应的并发接收方，也可以继续发送 message \u003c- \"buffered\" message \u003c- \"channel\" //接收时，也可以接收两个值 fmt.Println(\u003c-message) fmt.Println(\u003c-message) } func main() { channel2() } ","date":"2021-02-22","objectID":"/go-study-15/:2:2","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"通道同步 可以使用通道来同步Go协程间的执行状态。这里使用阻塞的接收方式来等待一个Go协程的运行结束 package main import ( \"fmt\" \"time\" ) func channel3() { //创建一个缓存为1的bool类型通道 done := make(chan bool, 1) //运行一个worker Go协程，并给予用于通知的通道 go worker(done) //程序将在接收到通道中worker发出的通知前一直阻塞 \u003c-done } //这是一个我们将要在 Go 协程中运行的函数。 // done 通道将被用于通知其他 Go 协程这个函数已经工作完毕 func worker(done chan bool) { fmt.Println(\"working...\") time.Sleep(time.Second) fmt.Println(\"done\") //发送一个值来通知完工啦。 done \u003c- true } func main() { channel3() } 如果将done \u003c- true这行代码从程序中移除，程序甚至会在worker还没开始运行就结束 ","date":"2021-02-22","objectID":"/go-study-15/:2:3","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"通道方向 当使用通道作为函数参数时，可以指定通道是不是只用来接收或发送值。这个特性提升了程序的类型安全性 package main import ( \"fmt\" ) func channel4() { pings := make(chan string, 1) pongs := make(chan string, 1) ping(pings, \"message\") pong(pings, pongs) fmt.Println(\u003c-pongs) } //ping函数定义一个只允许发送数据的通道 //尝试使用这个函数来接收数据会得到一个编译时错误 func ping(pings chan\u003c- string, str string) { pings \u003c- str } //pong函数允许通道pings接收函数，通道pongs发送函数 func pong(pings \u003c-chan string, pongs chan\u003c- string) { msg := \u003c-pings pongs \u003c- msg } func main() { channel4() } ","date":"2021-02-22","objectID":"/go-study-15/:2:4","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"通道选择器 Go的通道选择器可以同时等待多个通道操作。Go协程和通道以及选择器的结合是Go的一个强大特性 package main import ( \"fmt\" \"time\" ) func main() { //创建2个通道，从这两个选择 c1 := make(chan string, 1) c2 := make(chan string, 1) //c1通道在1秒后接收值，这个模拟Go协程中阻塞的RPC操作 go func() { time.Sleep(time.Second) c1 \u003c- \"one\" }() //c2通道在2秒后接收值 go func() { time.Sleep(time.Second * 2) c2 \u003c- \"two\" }() //使用select关键字来同时等待这两个值，并打印各自的值 for i :=0; i \u003c 2; i++ { select { case msg := \u003c-c1: fmt.Println(msg) case msg := \u003c-c2: fmt.Println(msg) } } } 注意两个协程并发运行，程序总共仅运行2秒左右 ","date":"2021-02-22","objectID":"/go-study-15/:2:5","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"超时处理 超时对于一个连接外部资源，或者其他一些需要花费执行时间操作的程序而言是很重要的。得益于通道和select，在Go中实现超时操作是简洁而优雅的 package main import ( \"fmt\" \"time\" ) func main() { //在这个例子中，执行一个外部调用，在2秒后通过通道c1返回执行结果 c1 := make(chan string, 1) go func() { time.Sleep(time.Second * 2) c1 \u003c- \"result 1\" }() //使用select实现超时操作 //result := \u003c-c1等待结果，\u003c-Time.After等待超时1秒后发送的值 //由于select默认处理第一个已准备好的接收操作，如果这个操作超过允许的1秒的话，将会执行超时case select { case result := \u003c- c1: fmt.Println(result) case \u003c-time.After(time.Second * 1): fmt.Println(\"result1 超时\") } //执行一个外部调用，2秒后通过通道c2返回执行结果 c2 := make(chan string, 1) go func() { time.Sleep(time.Second * 2) c2 \u003c- \"result 2\" }() //将超时延长至3秒，如果操作小于3秒将执行result输出case select { case result := \u003c-c2: fmt.Println(result) case \u003c-time.After(time.Second * 3): fmt.Println(\"result2超时\") } } 运行程序，首先显示运行超时的操作，然后是成功接收的。使用select超时方式需要使用通道传递结果。这对于一般情况是个好方式，因为其他重要的Go特性是基于通道和select的 ","date":"2021-02-22","objectID":"/go-study-15/:2:6","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"非阻塞式通道操作 常规的通过通道发送和接收数据是阻塞的。然而，可以使用带default子句select来实现非阻塞的发送、接收，甚至是非阻塞的多路select package main import \"fmt\" //这是一个非阻塞接收的例子 func main() { message := make(chan string, 1) signal := make(chan string, 1) //如果message有值存在，select将值传到msg中 //如果不存在直接执行default select { case msg := \u003c-message: fmt.Println(\"received message:\", msg) default: fmt.Println(\"no message receives\") } //这个非阻塞方法，如果msg成功向message传值，执行case //否则执行default msg := \"hi\" select { case message \u003c- msg: fmt.Println(\"sent message:\", msg) default: fmt.Println(\"no message sent\") } signal \u003c- \"world\" //可以在default前使用多个case子句实现一个多路的非阻塞的选择器 //这里尝试在message和signal上同时使用非阻塞的接收操作 //如果case1和case2都满足，只执行case1 select { case msg := \u003c-message: fmt.Println(\"receives message:\", msg) case sign := \u003c-signal: fmt.Println(\"receives signal:\", sign) default: fmt.Println(\"no activity\") } } ","date":"2021-02-22","objectID":"/go-study-15/:2:7","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"通道的关闭 关闭一个通道意味着不能再向这个通道发送值了。这个特性可以用来给这个通道接收方传达工作已经完成的消息 package main import \"fmt\" func main() { //在这个例子中，将使用一个jobs通道来传递main()中Go协程任务执行的结果信息到一个工作Go协程中 //当没有多余任务给这个工作Go协程时，可以close这个jobs通道 job := make(chan int, 5) done := make(chan bool, 1) //这是工作Go协程，使用j, more := \u003c-job循环从job接收数据 //在接收的这个特殊的二值形式的值中，如果job已经关闭，并且通道中的所有值都已经接收完毕 //那么more的值将是false。当完成所有任务时，将使用这个特性通过done通道去进行通知 go func() { for { j, more := \u003c-job if more { fmt.Println(\"received job:\", j) } else { fmt.Println(\"received all jobs\") done \u003c- true return } } }() //这里使用job发送3个任务到工作函数中，然后关闭job for i := 1; i \u003c= 3; i++ { job \u003c- i fmt.Println(\"sent job:\", i) } close(job) fmt.Println(\"sent all job\") //使用通道同步方法等待任务结束 \u003c-done } ","date":"2021-02-22","objectID":"/go-study-15/:2:8","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["学习"],"content":"通道遍历 可以使用range语法来遍历从通道中取得的值。一个非空通道是可以关闭的，但是通道中的值仍然可以被接收到 package main import \"fmt\" func main() { //遍历在queue通道中的两个值 queue := make(chan string, 2) queue \u003c- \"one\" queue \u003c- \"two\" close(queue) //这个range迭代从queue中得到的每个值 //因为close了通道，这个通道会在接收完第二个值后结束 //如果没有close，那么这个循环将继续阻塞执行，等待接收第三个值 for elem := range queue { fmt.Println(elem) } } ","date":"2021-02-22","objectID":"/go-study-15/:2:9","tags":["golang"],"title":"Go Study 15","uri":"/go-study-15/"},{"categories":["实例"],"content":"Go Instance 03-字符操作","date":"2021-02-22","objectID":"/go-instance-03/","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"字符操作 ","date":"2021-02-22","objectID":"/go-instance-03/:1:0","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"案例1 统计一个文本文件的字符个数 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) //定义一个结构体保存统计结果 type charCount struct { //英文个数 chCount int //空格个数 spaceCount int //数字个数 numCount int //其他个数 otherCount int } func main() { /** 思路：打开一个文件，创建一个Reader 每读取一行，统计字符保存到结构体中 */ file, err := os.Open(\"fileOperations/abc.txt\") if err != nil { fmt.Println(\"file open err:\", err) } reader := bufio.NewReader(file) fileC := charCount{} //循环读取file内容 for { s, err := reader.ReadString('\\n') //为了兼容中文转化为rune for _, r := range []rune(s) { switch { case r \u003e= 'a' \u0026\u0026 r \u003c= 'z': fallthrough case r \u003e= 'A' \u0026\u0026 r \u003c= 'Z': fileC.chCount++ case r \u003e '0' \u0026\u0026 r \u003c '9': fileC.numCount++ case r == ' ' || r == '\\t': fileC.spaceCount++ default: fileC.otherCount++ } } if err == io.EOF { break } } fmt.Printf(\"file has chcount: %d, numcount: %d, spaceCount: %d, otherCount: %d\", fileC.chCount, fileC.numCount, fileC.spaceCount, fileC.otherCount) } ","date":"2021-02-22","objectID":"/go-instance-03/:1:1","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"将数据序列化成json字符串 ","date":"2021-02-22","objectID":"/go-instance-03/:2:0","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"将数据(结构体，Map，Slice，基础数据类型)序列化成json字符串 json序列化是指将有key-value结构的数据类型(比如：结构体，Map，Slice)序列化成json字符串的操作 package main import ( \"encoding/json\" \"fmt\" ) type Hero struct { Name string `json:\"hero_name\"` Age int `json:\"hero_age\"` Sex string } //结构体序列化 func changeStruct() { hero := Hero{ Name: \"小陈\", Age: 18, Sex: \"男\", } //将结构体序列化 bytes, err := json.Marshal(hero) if err != nil{ fmt.Println(\"json marshal fail:\", err) } fmt.Printf(\"结构体序列化后的字段：%v\\n\", string(bytes)) } //Map序列化 func changeMap() { map1 := make(map[string]interface{}) map1[\"name\"] = \"张无忌\" map1[\"age\"] = 22 map1[\"address\"] = \"冰火岛\" //将map序列化 bytes, err := json.Marshal(map1) if err != nil { fmt.Println(\"json marshal fail:\", err) } fmt.Printf(\"Map序列化后的字段：%v\\n\", string(bytes)) } //Slice序列化 func changeSlice() { var slice []map[string]interface{} m1 := make(map[string]interface{}) m1[\"name\"] = \"张无忌\" m1[\"age\"] = 25 m1[\"address\"] = \"冰火岛\" slice = append(slice, m1) m2 := make(map[string]interface{}) m2[\"name\"] = \"张三丰\" m2[\"age\"] = \"88\" m2[\"address\"] = []string{\"武当山\", \"夏威夷\"} slice = append(slice, m2) //slice序列化 bytes, err := json.Marshal(slice) if err != nil { fmt.Println(\"json marshal fail:\", err) } fmt.Printf(\"Slice序列化后的字段：%v\\n\", string(bytes)) } //基本类型序列化(对基础类型序列化意义不大) func changeFloat() { var f float64 = 3.14 //对float序列化 bytes, err := json.Marshal(f) if err != nil { fmt.Println(\"json marshal fail:\", err) } fmt.Println(\"Float序列化后的字段：\", string(bytes)) } func main() { changeStruct() changeMap() changeSlice() changeFloat() } ","date":"2021-02-22","objectID":"/go-instance-03/:2:1","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"将json字符串反序列化成对应数据 ","date":"2021-02-22","objectID":"/go-instance-03/:3:0","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"将json字符串 反序列化成对应数据（比如：结构体，map，切片） package main import ( \"encoding/json\" \"fmt\" ) type Hero struct { Name string `json:\"hero_name\"` Age int `json:\"hero_age\"` Sex string } //将json字符串反序列化为结构体 func unmarshalStruct() { str := \"{\\\"hero_name\\\":\\\"小陈\\\",\\\"hero_age\\\":18,\\\"Sex\\\":\\\"男\\\"}\" var hero Hero err := json.Unmarshal([]byte(str), \u0026hero) if err != nil { fmt.Println(\"json unmarshal fail:\", err) } fmt.Printf(\"json反序列化为结构体：%v\\n\", hero) } //将json字符串反序列化为Map func unmarshalMap() { str := \"{\\\"name\\\": \\\"张无忌\\\",\\\"age\\\": 22,\\\"address\\\": \\\"冰火岛\\\"}\" //定义一个map，反序列化的时候不需要make，因为unmarshal封装了make var map1 map[string]interface{} err := json.Unmarshal([]byte(str), \u0026map1) if err != nil { fmt.Println(\"json unmarshal fail:\", err) } fmt.Printf(\"json反序列化为Map：%v\\n\",map1) } //将json字符串反序列化为Slice func unmarshalSlice() { str := \"[{\\\"address\\\":\\\"冰火岛\\\",\\\"age\\\":25,\\\"name\\\":\\\"张无忌\\\"},{\\\"address\\\":[\\\"武当山\\\",\\\"夏威夷\\\"],\\\"age\\\":\\\"88\\\",\\\"name\\\":\\\"张三丰\\\"}]\" //定义一个slice，反序列化的时候不需要make，因为unmarshal封装了make var slice []map[string]interface{} err := json.Unmarshal([]byte(str), \u0026slice) if err != nil { fmt.Println(\"json unmarshal fail:\", err) } fmt.Printf(\"json反序列化为Slice：%v\\n\", slice) } func main() { unmarshalStruct() unmarshalMap() unmarshalSlice() } ","date":"2021-02-22","objectID":"/go-instance-03/:3:1","tags":["golang"],"title":"Go Instance 03","uri":"/go-instance-03/"},{"categories":["实例"],"content":"Go Instance 02-文件操作","date":"2021-02-22","objectID":"/go-instance-02/","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"读取文件 ","date":"2021-02-22","objectID":"/go-instance-02/:1:0","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例1 读取文件的内容并显示在终端(带缓冲区的方式) package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) //读取文件的内容并显示在终端(带缓冲区的方式) func main() { //打开文件 file, err := os.Open(\"fileOperations/abc.txt\") if err != nil { fmt.Println(\"文件打开失败\") } //函数退出时关闭文件 defer file.Close() //输出文件 fmt.Printf(\"file=%v \\n\", \u0026file) //创建一个*Reader，带缓冲的，默认缓冲区大小为4096 reader := bufio.NewReader(file) //循环读取文件内容 for { //读到一个换行结束 s, err := reader.ReadString('\\n') //输出文件内容 fmt.Print(s) //io.EOF表示文件末尾 if err == io.EOF { fmt.Println() break } } fmt.Println(\"文件读取结束\") } ","date":"2021-02-22","objectID":"/go-instance-02/:1:1","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例2 对于文件不太大的情况，可以使用ioutil一次将整个文件读到内存里 package main import ( \"fmt\" \"io/ioutil\" ) //对于文件不太大的情况，可以使用ioutil一次将整个文件读到内存里 func main() { //打开文件 file, err := ioutil.ReadFile(\"fileOperations/abc.txt\") if err != nil { fmt.Println(\"open file err:\", err) } //把读取到的文件显示在终端 //不需要显式的Open和Close文件，因为这两个操作已经被封装在ioutilFile函数内部 fmt.Printf(\"file is %v\\n\", file) fmt.Printf(\"file is %v\\n\", string(file)) } ","date":"2021-02-22","objectID":"/go-instance-02/:1:2","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"写入文件 ","date":"2021-02-22","objectID":"/go-instance-02/:2:0","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例1 创建一个新文件写入5句hello package main import ( \"bufio\" \"fmt\" \"os\" ) //创建一个新文件写入5句hello func main() { //打开文件，可写可创建 file, err := os.OpenFile(\"fileOperations/write.txt\", os.O_WRONLY|os.O_CREATE, 0666) if err != nil{ fmt.Printf(\"open file err: %v\\n\", err) } //函数退出关闭文件 defer file.Close() //写入文件，使用带缓存的*writer writer := bufio.NewWriter(file) for i := 0; i \u003c 5; i++ { writer.WriteString(\"hello\\n\") } //Flush将缓存的文件真正写入到文件中 writer.Flush() fmt.Println(\"文件写入成功\") } ","date":"2021-02-22","objectID":"/go-instance-02/:2:1","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例2 打开已有文件追加内容 package main import ( \"bufio\" \"fmt\" \"os\" ) //打开已有文件追加内容 func main() { //打开文件，文件可写可以追加 file, err := os.OpenFile(\"fileOperations/write.txt\", os.O_APPEND|os.O_WRONLY, 0666) if err != nil { fmt.Println(\"file is err\", err) } //函数最后关闭文件 defer file.Close() //写入文件，使用带缓存的*writer writer := bufio.NewWriter(file) for i := 0; i \u003c 5; i++ { writer.WriteString(\"abc \\r\\n\") } //Flush将缓存文件真正写入到文件中 writer.Flush() } ","date":"2021-02-22","objectID":"/go-instance-02/:2:2","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例3 打开一个存在的文件读取内容并追加内容 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) //打开一个存在的文件读取内容并追加内容 func main() { //打开文件，可读可写可追加 file, err := os.OpenFile(\"fileOperations/write.txt\", os.O_APPEND|os.O_RDWR, 0666) if err != nil { fmt.Println(\"file open err:\", err) } //函数结束关闭文件 defer file.Close() //读取文件 reader := bufio.NewReader(file) for{ s, err := reader.ReadString('\\n') fmt.Print(s) if err == io.EOF { break } } //写入文件 writer := bufio.NewWriter(file) for i := 0; i \u003c 5; i++ { writer.WriteString(\"hello world\\n\") } writer.Flush() } ","date":"2021-02-22","objectID":"/go-instance-02/:2:3","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例4 将一个文件内容复制到另一个文件中 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) //将一个文件内容复制到另一个文件中 func main() { os.OpenFile(\"fileOperations/writecopy.txt\", os.O_CREATE|os.O_WRONLY, 0666) file, err := ioutil.ReadFile(\"fileOperations/write.txt\") if err != nil { fmt.Println(\"file1 open err:\", err) } err = ioutil.WriteFile(\"fileOperations/writecopy.txt\", file, 0666) if err != nil { fmt.Println(\"file2 copy err\", err) } } ","date":"2021-02-22","objectID":"/go-instance-02/:2:4","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"拷贝文件 ","date":"2021-02-22","objectID":"/go-instance-02/:3:0","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["实例"],"content":"案例1 将一个图片拷贝到另一个文件下 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) //编写一个函数，传入两个文件路径 func copyFile(dstFile string, srcFile string) (written int64, err error) { //打开srcFile read, err := os.OpenFile(srcFile, os.O_RDONLY, 0) if err != nil { fmt.Println(\"srcFile open err:\", err) } defer read.Close() //通过srcFile找到 reader reader := bufio.NewReader(read) //打开dstFile write, err := os.OpenFile(dstFile, os.O_WRONLY|os.O_CREATE, 0666) if err != nil { fmt.Println(\"dstFile open err:\", err) } defer write.Close() //通过dstFile找到writer writer := bufio.NewWriter(write) return io.Copy(writer, reader) } func main() { //将srcFile文件拷贝到dstFile文件 srcFile := \"F:/hugo-blog/cc/static/go7.jpg\" dstFile := \"D:/bgird.jpg\" //调用copyFile完成拷贝 written, err := copyFile(dstFile, srcFile) if err != nil { fmt.Println(\"copy file err:\", err) } else { fmt.Println(\"copy file success, written:\", written) } } ","date":"2021-02-22","objectID":"/go-instance-02/:3:1","tags":["golang"],"title":"Go Instance 02","uri":"/go-instance-02/"},{"categories":["学习"],"content":"Go Study 14-goroutine","date":"2021-02-21","objectID":"/go-study-14/","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"goroutine ","date":"2021-02-21","objectID":"/go-study-14/:1:0","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"协程Coroutine 轻量级“线程” 非抢占式多任务处理，由协程主动交出控制权 编译器/解释器/虚拟机层面的多任务 多个协程可能在一个或多个线程上运行 coroutine\u0026ldquo;coroutine\u0026rdquo; \"\rcoroutine\r ","date":"2021-02-21","objectID":"/go-study-14/:1:1","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"goroutine的定义 任何函数只需加上go就能送给调度器运行 不需要在定义时区分是否是异步函数 调度器会在合适的点进行切换 使用-race来检测数据访问冲突 goroutine\u0026ldquo;goroutine\u0026rdquo; \"\rgoroutine\r ","date":"2021-02-21","objectID":"/go-study-14/:1:2","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"goroutine可能的切换点 I/O，select channel 等待锁 函数调用(有时) runtime.Gosched() 以上只是参考，不能保证切换，不能保证在其他地方不切换 ","date":"2021-02-21","objectID":"/go-study-14/:1:3","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-21","objectID":"/go-study-14/:2:0","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"协程 Go协程在执行上来说是轻量级的线程 package main import \"fmt\" func f(s string) { for i := 0; i \u003c 3; i++ { fmt.Println(s) } } //Go协程在执行上来说是轻量级的线程 func main() { //使用一般方式运行f函数 f(\"direct\") //使用go f(s)在一个Go协程中调用这个函数 //这个新的Go协程会并行的执行这个函数的调用 go f(\"gorouting\") //为匿名函数启动一个Go协程 go func(msg string) { for i := 0; i \u003c 10; i++ { fmt.Println(msg) } }(\"going\") //现在这两个Go协程在独立的Go协程中异步运行，所以需要等他们结束 //Scanln代码，我们在程序退出前按下任意键结束 var in string fmt.Scanln(\u0026in) fmt.Println(\"done\") } 当运行这个程序时，将先看见阻塞式调用，然后是两个go协程交替输出，这种交替输出表示Go运行时是以异步方式运行协程的 ","date":"2021-02-21","objectID":"/go-study-14/:2:1","tags":["golang"],"title":"Go Study 14","uri":"/go-study-14/"},{"categories":["学习"],"content":"Go Study 13-测试","date":"2021-02-21","objectID":"/go-study-13/","tags":["golang"],"title":"Go Study 13","uri":"/go-study-13/"},{"categories":["学习"],"content":"测试 testing.T的应用 运行测试 ","date":"2021-02-21","objectID":"/go-study-13/:1:0","tags":["golang"],"title":"Go Study 13","uri":"/go-study-13/"},{"categories":["学习"],"content":"代码覆盖率 使用IDE查看代码覆盖 使用go test获取代码覆盖报告 使用go tool cover查看代码覆盖报告 ","date":"2021-02-21","objectID":"/go-study-13/:1:1","tags":["golang"],"title":"Go Study 13","uri":"/go-study-13/"},{"categories":["学习"],"content":"性能测试 testing.B的使用 ","date":"2021-02-21","objectID":"/go-study-13/:1:2","tags":["golang"],"title":"Go Study 13","uri":"/go-study-13/"},{"categories":["学习"],"content":"使用pprof进行性能调优 终端进入项目目录下 go test -bench . -cpuprofile cpu.out生成cpu.out go tool pprof cpu.out查看cpu.out 在交互式命令行输入web进行查看 ","date":"2021-02-21","objectID":"/go-study-13/:1:3","tags":["golang"],"title":"Go Study 13","uri":"/go-study-13/"},{"categories":["学习"],"content":"案例","date":"2021-02-21","objectID":"/go-study-13/:2:0","tags":["golang"],"title":"Go Study 13","uri":"/go-study-13/"},{"categories":["面试"],"content":"Go Interview 01-new与make的区别","date":"2021-02-20","objectID":"/go-interview-01/","tags":["golang"],"title":"Go Interview 01","uri":"/go-interview-01/"},{"categories":["面试"],"content":"new和make的定义 func new(Type) *Type func make(t Type, size ...IntegerType) Type 其中Type代表一个数据类型 ","date":"2021-02-20","objectID":"/go-interview-01/:1:0","tags":["golang"],"title":"Go Interview 01","uri":"/go-interview-01/"},{"categories":["面试"],"content":"二者的区别 ","date":"2021-02-20","objectID":"/go-interview-01/:2:0","tags":["golang"],"title":"Go Interview 01","uri":"/go-interview-01/"},{"categories":["面试"],"content":"返回值 从定义中可以看出，new返回的是指向Type的指针，make直接返回的是Type类型值 ","date":"2021-02-20","objectID":"/go-interview-01/:2:1","tags":["golang"],"title":"Go Interview 01","uri":"/go-interview-01/"},{"categories":["面试"],"content":"入参 new只有一个Type参数，Type可以是任意数据类型。make可以有多个参数，但是只能是slice，map或者chan中的一种。对于不同类型，size参数说明如下： 对于slice,第一个size表示长度，第二个size表示容量，且容量不能小于长度。如果省略第二个size，默认容量等于长度。 对于map，会根据size大小分配资源，以足够存储size个元素。如果省略size，会默认分配一个小的起始size 对于chan，size表示缓冲区容量。如果省略size，channel为无缓冲channel ","date":"2021-02-20","objectID":"/go-interview-01/:2:2","tags":["golang"],"title":"Go Interview 01","uri":"/go-interview-01/"},{"categories":["面试"],"content":"分配类型 new：用来分配内存，主要用来分配值类型 make：用来分配内存，主要用来分配引用类型 ","date":"2021-02-20","objectID":"/go-interview-01/:2:3","tags":["golang"],"title":"Go Interview 01","uri":"/go-interview-01/"},{"categories":["实例"],"content":"Go Instance 01-豆瓣爬虫","date":"2021-02-19","objectID":"/go-instance-01/","tags":["golang"],"title":"Go Instance 01","uri":"/go-instance-01/"},{"categories":["实例"],"content":"使用Go爬取豆瓣电影排行榜 package main import ( \"encoding/json\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"regexp\" \"strings\" ) func main() { data, err := GetHtml(\"https://movie.douban.com/chart\") if err != nil { fmt.Println(\"获取源代码失败:\", err) return } //创建文件 file, err := os.Create(\"movie.json\") if err != nil { fmt.Println(\"创建文件失败:\", err) return } encoder := json.NewEncoder(file) encoder.SetIndent(\" \", \" \") encoder.Encode(GetItem(data)) } func GetHtml(url string) ([]byte, error) { var clent http.Client req, err := http.NewRequest(\"GET\", url, nil) if err != nil { fmt.Println(\"创建请求失败:\", err) return nil, err } //添加请求头，才能访问到需要的网页源码 req.Header.Add(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36 Edg/85.0.564.51\") resp, err := clent.Do(req) if err != nil { fmt.Println(\"请求失败:\", err) return nil, err } data, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(\"读取失败:\", err) return nil, err } defer resp.Body.Close() return data, nil } type Item struct { Link string `json:\"link\"` Name string `json:\"name\"` Info string `json:\"info\"` Rate string `json:\"rate\"` RateNum string `json:\"rate_num\"` } func GetItem(data []byte) []Item { //正则匹配需要的内容 pattern := regexp.MustCompile(`(?s)\u003cdiv.*?class=\"pl2\".*?\u003e.*?\u003ca href=\"(.*?)\".*?\u003e(.*?)/.*?\u003cspan.*?\u003c/span\u003e.*?\u003cp class=\"pl\"\u003e(.*?)\u003c/p\u003e.*?\u003cdiv.*?\u003e.*?\u003cspan class=\"rating_nums\"\u003e(.*?)\u003c/span\u003e.*?\u003cspan class=\"pl\"\u003e\\((.*?)\\)\u003c/span\u003e.*?\u003c/div\u003e`) //查找网页中所有的匹配项 items := pattern.FindAllSubmatch(data, -1) var res []Item for _, item := range items { res = append(res, Item{ Link: string(item[1]), Name: strings.TrimSpace(string(item[2])), Info: string(item[3]), Rate: string(item[4]), RateNum: string(item[5]), }) } return res } ","date":"2021-02-19","objectID":"/go-instance-01/:1:0","tags":["golang"],"title":"Go Instance 01","uri":"/go-instance-01/"},{"categories":["学习"],"content":"Go Study 12-资源管理与出错处理","date":"2021-02-18","objectID":"/go-study-12/","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"defer调用 确保调用在函数结束时发生 多defer相当于栈(先进后出) 参数在defer语句时计算 ","date":"2021-02-18","objectID":"/go-study-12/:1:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"何时使用defer调用 Open/Close Lock/Unlock PrintHeader/PrintFooter ","date":"2021-02-18","objectID":"/go-study-12/:2:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"错误处理二 如何实现统一的错误处理逻辑 ","date":"2021-02-18","objectID":"/go-study-12/:3:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"panic 停止当前函数运行 一直向上返回，执行每一层的defer 如果没有遇见recover，程序退出 ","date":"2021-02-18","objectID":"/go-study-12/:4:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"recover 仅在defer调用中使用 获取panic的值 如果无法处理，可重新panic ","date":"2021-02-18","objectID":"/go-study-12/:5:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"error vs panic 意料之中的：使用error。如：文件打不开 意料之外的：使用panic。如：数组越界 ","date":"2021-02-18","objectID":"/go-study-12/:6:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"错误处理综合实例 defer + panic + recover Type Assertion 函数式编程的应用 ","date":"2021-02-18","objectID":"/go-study-12/:7:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-18","objectID":"/go-study-12/:8:0","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"错误处理 Go语言使用一个独立的明确的返回值来传递错误信息。这与使用异常的Java和Ruby以及在C语言中常见到的超重的单返回值/错误值相比，Go语言的处理方式能清楚知道那个函数返回了错误，并能像调用那些没有出错函数一样调用 package main import ( \"errors\" \"fmt\" ) //按照惯例，错误通常是最后一个返回值并且是error类型，一个内建的接口 func f1(arg int) (int, error) { if arg == 42 { //error.New 构造一个使用给定错误信息的基本error值 return -1, errors.New(\"can't work with 42\") } //返回错误值为nil，代表没有错误 return arg+3, nil } //通过实现Error方法来自定义error是可以的 //这里使用自定义错误类型来表示上面的参数错误 type argError struct { arg int prob string } func (e *argError) Error() string { return fmt.Sprintf(\"%d-%s\", e.arg, e.prob) } func f2(arg int) (int, error) { if arg == 42 { //这个例子中，使用\u0026argError语法来建立一个新的结构体 //提供arg和prob两个字段的值 return -1, \u0026argError{arg, \"can't work with it\"} } return arg+3, nil } func main() { //下面两个循环测试了各个返回错误的函数 //注意在if行内的错误检查代码，在Go中是一个普遍的用法 for _, i := range []int{7, 42}{ if r, e := f1(i); e != nil { fmt.Println(\"f1 failed: \", e) } else { fmt.Println(\"f1 worked: \", r) } } for _, i := range []int{7, 42} { if r, e := f2(i); e != nil { fmt.Println(\"f2 failed: \", e) } else { fmt.Println(\"f2 worked: \", r) } } //如果想在程序中使用一个自定义错误类型中的数据 //需要通过类型断言来得到这个错误类型的实例 _, e := f2(42) if ae, ok := e.(*argError); ok { fmt.Println(ae.arg) fmt.Println(ae.prob) } } ","date":"2021-02-18","objectID":"/go-study-12/:8:1","tags":["golang"],"title":"Go Study 12","uri":"/go-study-12/"},{"categories":["学习"],"content":"Go Study 11-函数与闭包","date":"2021-02-18","objectID":"/go-study-11/","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"函数与闭包 ","date":"2021-02-18","objectID":"/go-study-11/:1:0","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"函数式编程 vs 函数指针 函数式一等公民：参数，变量，返回值都可以是函数 高阶函数 函数 -\u003e 闭包 ","date":"2021-02-18","objectID":"/go-study-11/:1:1","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"“正统”函数式编程 不可变性：不能有状态，只有常量和函数 函数只能有一个参数 ","date":"2021-02-18","objectID":"/go-study-11/:1:2","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"go 语言闭包的应用 更为自然，不需要修饰如何访问自由变量 没有Lambda表达式，但是有匿名函数 闭包与函数\u0026ldquo;闭包与函数\u0026rdquo; \"\r闭包与函数\r ","date":"2021-02-18","objectID":"/go-study-11/:1:3","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-18","objectID":"/go-study-11/:2:0","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"基本函数 函数是Go的中心 package main import \"fmt\" //这里是一个函数，接受两个int，并以int返回它们的和 func plus(a, b int) int { //Go需要明确的返回值 return a+b } func main() { //通过name(args)来调用一个函数 result := plus(1, 2) fmt.Println(result) } ","date":"2021-02-18","objectID":"/go-study-11/:2:1","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"多返回值函数 Go内建多返回值支持。这个特性在Go语言中经常被用到，例如用来同时返回一个函数的结果和错误信息 package main import \"fmt\" //(int, int)在这个函数中标志着这个函数返回2个int func vals() (int, int) { return 3, 7 } func main() { //通过多赋值操作来使用两个不同的返回值 a, b := vals() fmt.Println(a) fmt.Println(b) //如果想返回一部分值，可以使用空白定义符_ _, c := vals() fmt.Println(c) } ","date":"2021-02-18","objectID":"/go-study-11/:2:2","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"可变参数函数 可变参数函数。可以用任意数量的参数调用。例如，fmt.Println是一个常见的变参函数 package main import \"fmt\" //这个函数使用任意数目的int作为参数 func sum(nums ...int) { fmt.Print(nums, \" \") total := 0 for _, num := range nums { total += num } fmt.Println(total) } func main() { //变参函数使用常规的调用方法，除了参数比较特殊 sum(1, 2) sum(1, 2, 3) //如果slice已经有多个值，想作为变参使用，可以这样调用func(slice...) nums := []int{1, 2, 3, 4, 5} sum(nums...) } ","date":"2021-02-18","objectID":"/go-study-11/:2:3","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"闭包 Go支持通过闭包来使用匿名函数。匿名函数在你想定义一个不需要命名的内联函数时很实用 package main import \"fmt\" //这个intSeq函数返回另一个在intSeq函数体内定义的匿名函数 //这个函数的返回使用闭包的方式 隐藏 变量 i func intSeq() func() int { i := 0 return func() int { i += 1 return i } } func main() { //调用nextInt函数，将返回值(也是一个函数)赋给nextInt //这个函数的值包含了自己的值i，在每次调用nextInt都会更新i nextInt := intSeq() //多次调用闭包，查看效果 fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) //更换函数，确定每个函数的i是独立的 nextInts := intSeq() fmt.Println(nextInts()) } ","date":"2021-02-18","objectID":"/go-study-11/:2:4","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"递归函数 Go支持递归，这是一个经典的阶乘案例 package main import \"fmt\" //fact函数在到达fact(0)前一直在调用自身 func fact(n int) int { if n == 0 { return 1 } return n * fact(n-1) } func main() { fmt.Println(fact(5)) } ","date":"2021-02-18","objectID":"/go-study-11/:2:5","tags":["golang"],"title":"Go Study 11","uri":"/go-study-11/"},{"categories":["学习"],"content":"Go Study 10-接口","date":"2021-02-17","objectID":"/go-study-10/","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"接口 接口由使用者定义 ","date":"2021-02-17","objectID":"/go-study-10/:1:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"duck typing “像鸭子走路，像鸭子叫(长得像鸭子)，那么就是鸭子” 描述事物的外部行为而非内部结构 严格来说go属于结构化类型系统，类似duck typing ","date":"2021-02-17","objectID":"/go-study-10/:2:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"接口变量里有什么 接口变量1\u0026ldquo;接口变量1\u0026rdquo; \"\r接口变量1\r 接口变量2\u0026ldquo;接口变量2\u0026rdquo; \"\r接口变量2\r 接口变量自带指针 接口变量同样采用值传递，几乎不需要使用接口的指针 指针接收者实现只能以指针方式使用；值接收者都可以 ","date":"2021-02-17","objectID":"/go-study-10/:3:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"查看接口变量 表示任何变量：interface{} Type Assertion Type Switch ","date":"2021-02-17","objectID":"/go-study-10/:4:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"特殊接口 Stringer Reader/Writer ","date":"2021-02-17","objectID":"/go-study-10/:5:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-17","objectID":"/go-study-10/:6:0","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"接口 接口：Go语言中组织和命名相关的方法集合的机制。接口是方法特征的命名集合 package main import ( \"fmt\" \"math\" ) //这里是一个几何体的基本接口 type geometry interface { area() float64 perim() float64 } //这个例子中，将让rect和circle实现这个接口 type rect struct { width float64 height float64 } type circle struct { radius float64 } //在Go中实现接口，需要实现这个接口的所有方法 //rect实现接口 func (r rect) area() float64 { return r.width * r.height } func (r rect) perim() float64 { return 2*r.width + 2*r.height } //circle实现接口 func (c circle) area() float64 { return math.Pi * c.radius * c.radius } func (c circle) perim() float64 { return math.Pi * c.radius * 2 } //如果有一个变量是接口类型，可以调用这个被命名接口的方法 //这里有一个通用的measure函数，利用特性，可以用在任何geometry(几何学)上 func measure(g geometry) { fmt.Println(g) fmt.Println(g.area()) fmt.Println(g.perim()) } func main() { r := rect{width: 3, height: 4} c := circle{radius: 5} //结构体类型circle和rect都实现了geometry接口 //所以可以使用他们的实例作为measure的参数 measure(r) measure(c) } ","date":"2021-02-17","objectID":"/go-study-10/:6:1","tags":["golang"],"title":"Go Study 10","uri":"/go-study-10/"},{"categories":["学习"],"content":"Go Study 09-GOPATH","date":"2021-02-17","objectID":"/go-study-09/","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"GOPATH环境变量 默认在~/go(unix，linux)，%USERPOFILE%\\go(windows) 官方推荐：所有项目和第三方库都放在同一个GOPATH下 也可以将每个项目放在不同的GOPATH ","date":"2021-02-17","objectID":"/go-study-09/:1:0","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"go get 获取第三方库 go get + 包(github可以，golang不行) 使用gopm来获取无法下载的包 go get -v github.com/gpmgo/gopm ","date":"2021-02-17","objectID":"/go-study-09/:2:0","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"GOPATH下目录结构 go build来编译 go install 产生pkg文件和可执行文件 go run 直接编译运行 ","date":"2021-02-17","objectID":"/go-study-09/:3:0","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"GOPATH下目录结构 src git repository 1 git repository 2 pkg git repository 1 git repository 2 bin 执行文件1,2,3… ","date":"2021-02-17","objectID":"/go-study-09/:4:0","tags":["golang"],"title":"Go Study 09","uri":"/go-study-09/"},{"categories":["学习"],"content":"Go Study 08-封装","date":"2021-02-16","objectID":"/go-study-08/","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"封装 名字一般使用CamelCase 首字母大写：public 首字母小写：private ","date":"2021-02-16","objectID":"/go-study-08/:1:0","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"包 每个目录一个包 main包包含可执行入口 为结构定义的方法必须放在同一个包内 可以是不同文件 ","date":"2021-02-16","objectID":"/go-study-08/:2:0","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"如何扩充系统类型或者别人的类型 定义别名 使用组合 ","date":"2021-02-16","objectID":"/go-study-08/:2:1","tags":["golang"],"title":"Go Study 08","uri":"/go-study-08/"},{"categories":["学习"],"content":"Go Study 07-面向对象，struct","date":"2021-02-16","objectID":"/go-study-07/","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"面向对象 go语言仅支持封装，不支持继承和多态 go语言没有class，只有struct ","date":"2021-02-16","objectID":"/go-study-07/:1:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"结构的创建 type treeNode struct { value int left, right *treeNode } //自定义工厂函数 func createNode(value int) *treeNode { //返回局部变量地址 return \u0026treeNode{value: value} } func main() { var root treeNode fmt.Println(root) root = treeNode{value: 3} root.left = \u0026treeNode{} root.right = \u0026treeNode{5, nil, nil} root.right.left = new(treeNode) root.left.right = createNode(2) } 不论地址还是结构本身，一律使用.来访问成员 使用自定义工厂函数(createNode) 注意返回了局部变量的地址 ","date":"2021-02-16","objectID":"/go-study-07/:2:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"为结构定义方法 func (node treeNode) print() { fmt.Println(node.value) } 显示定义和命名方法接受者 ","date":"2021-02-16","objectID":"/go-study-07/:3:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"使用指针作为方法接受者 func (node *treeNode) setValue(value int) { node.value = value } 只有使用指针才可以改变结构内容 nil指针也可以调用方法 ","date":"2021-02-16","objectID":"/go-study-07/:4:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"值接受者 vs 指针接受者 要改变内容必须使用指针接收者 结构过大也考虑使用指针接收者(因为值接收者使用时会拷贝一份，结构过大拷贝代价也大) 一致性：如有指针接收者，最好都使用指针接收者 很简单的不可变对象使用值接收者可以减轻GC负担(太多的指针会增加垃圾服务器GC的负担) 值接收者是go语言特有 值/指针接收者均可接收值/指针 ","date":"2021-02-16","objectID":"/go-study-07/:5:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-16","objectID":"/go-study-07/:6:0","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"结构体 Go的结构体是各个字段 字段类型的集合 package main import \"fmt\" type person struct { name string age int } func main() { //使用这个语法创建一个新的结构体函数 fmt.Println(person{\"Bob\", 20}) //可以在初始化一个结构体元素时指定字段名 fmt.Println(person{name:\"Alice\", age:18}) //省略的字段将被初始化为零值 fmt.Println(person{name:\"Fred\"}) //\u0026前缀生成一个结构体指针 fmt.Println(\u0026person{name:\"Ann\", age:40}) //使用点来访问结构体字段 s := person{name:\"Sean\", age:50} fmt.Println(s.name) fmt.Println(s.age) //也可以对结构体指针引用，指针会被自动解引用 sp := \u0026s fmt.Println(sp.age) //结构体是可变的 sp.age = 51 fmt.Println(s.age) s.age = 52 fmt.Println(s.age) } ","date":"2021-02-16","objectID":"/go-study-07/:6:1","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"方法 Go支持在结构体类型中定义方法 package main import \"fmt\" type rect struct { wight int height int } //area方法有一个接收器类型rect来计算矩形面积 func (r rect) area() int { return r.height * r.wight } //可以为值或指针类型的接收器定义方法，这是个值类型接收器 //计算矩形周长 func (r rect) perim() int { return 2*r.wight + 2*r.height } //指针类型接收器可以改变实际值 func (r *rect) changeH(val int) { r.height = val } //值类型接收器改变拷贝值 func (r rect) changeW(val int) { r.wight = val } func main() { r := rect{10, 5} //调用上面为结构体定义的方法 fmt.Println(r.area()) fmt.Println(r.perim()) r.changeH(20) r.changeW(15) fmt.Println(r) //Go自动处理方法调用时值和指针之间的转换 //可以使用指针来调用方法避免在方法调用时产生一个拷贝或让方法能够改变接收的数据 rp := \u0026r rp.changeH(25) rp.changeW(30) fmt.Println(rp.area()) fmt.Println(rp.perim()) } ","date":"2021-02-16","objectID":"/go-study-07/:6:2","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"值和指针 Go支持指针，允许在程序中通过引用传递值或数据结构 package main import \"fmt\" //通过两个不同的函数来比较值和指针类型的不同 //zeroVal有一个int型参数，所以使用值传递 //zeroVal将从调用它的函数中获得一个ival形参的拷贝 func zeroVal(ival int) { ival = 0 } //zeroPtr和上面不同是*int，意味着它使用的是指针 //函数体内的*iptr接着解引用这个指针，从它内存地址得到这个地址当前值 //对一个解引用指针进行赋值会改变这个指针引用的真实地址的值 func zeroPtr(iptr *int) { *iptr = 0 } func main() { i := 1 fmt.Println(\"initial: \", i) zeroVal(i) fmt.Println(\"zeroVal: \", i) //通过\u0026i语法来获取i的内存地址 zeroPtr(\u0026i) //指针也是可以被打印的 fmt.Println(\"zeroPtr: \", i) fmt.Println(\"point: \", \u0026i) } ","date":"2021-02-16","objectID":"/go-study-07/:6:3","tags":["golang"],"title":"Go Study 07","uri":"/go-study-07/"},{"categories":["学习"],"content":"Go Study 06-rune字符串","date":"2021-02-16","objectID":"/go-study-06/","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"rune相当于go的char ","date":"2021-02-16","objectID":"/go-study-06/:1:0","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用range遍历pos，rune对 s := \"Yes我是你爸爸!\" for _, b := range []byte(s) { fmt.Printf(\"%X \", b) } fmt.Println() for i, ch := range s { fmt.Printf(\"(%d %X) \", i, ch) } ","date":"2021-02-16","objectID":"/go-study-06/:1:1","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用utf8.RuneCountInString获得字符数量 fmt.Println(\"Rune count:\", utf8.RuneCountInString(s)) ","date":"2021-02-16","objectID":"/go-study-06/:1:2","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用len获得字节长度 fmt.Println(len(s)) ","date":"2021-02-16","objectID":"/go-study-06/:1:3","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"使用[]byte获得字节 bytes := []byte(s) for len(bytes) \u003e 0 { ch, size := utf8.DecodeRune(bytes) bytes = bytes[size:] fmt.Printf(\"%c \", ch) } ","date":"2021-02-16","objectID":"/go-study-06/:1:4","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"其他字符串操作 ","date":"2021-02-16","objectID":"/go-study-06/:2:0","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Fields，Split，Join ","date":"2021-02-16","objectID":"/go-study-06/:2:1","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Contains，Index ","date":"2021-02-16","objectID":"/go-study-06/:2:2","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"ToLower，ToUpper ","date":"2021-02-16","objectID":"/go-study-06/:2:3","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Trim，TrimRight，TrimLeft","date":"2021-02-16","objectID":"/go-study-06/:2:4","tags":["golang"],"title":"Go Study 06","uri":"/go-study-06/"},{"categories":["学习"],"content":"Go Study 05-leetcode例题","date":"2021-02-16","objectID":"/go-study-05/","tags":["golang"],"title":"Go Study 05","uri":"/go-study-05/"},{"categories":["学习"],"content":"寻找最长不含有重复字符的子串 abcabcbb -\u003e abc bbbbb -\u003e b pwwkew -\u003ewke func lenthofNonRepeatingSubStr(s string) int { lastOccurred := make(map[rune]int) start := 0 maxLength := 0 for i, ch := range []rune (s){ if lastI, ok := lastOccurred[ch]; ok \u0026\u0026 lastI \u003e= start { fmt.Println(lastI) fmt.Println(ok) start = lastI + 1 } if i-start+1 \u003e maxLength { maxLength = i-start+1 } lastOccurred[ch] = i } return maxLength } ","date":"2021-02-16","objectID":"/go-study-05/:1:0","tags":["golang"],"title":"Go Study 05","uri":"/go-study-05/"},{"categories":["学习"],"content":"Go Study 04-数组、切片和容器","date":"2021-02-15","objectID":"/go-study-04/","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组 var arr1 [5]int arr2 := [3]int{1,3,5} arr3 := [...]int{2,4,6,8,10} var grid [4][5]int 数量写在类型前 ","date":"2021-02-15","objectID":"/go-study-04/:1:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组的遍历 长度遍历 for i := 0; i \u003c len(arr3); i++ { fmt.Println(arr3[i]) } range只取index for i := range arr3 { fmt.Println(arr3[i]) } range取index和value maxi := -1 maxnum := -1 for i, v := range arr3{ if v \u003e maxnum { maxi = i maxnum = v } } fmt.Println(maxi, maxnum) range只取value sum := 0 for _, v := range arr3 { sum += v } 可以通过_省略变量 不仅range，任何地方都可以通过_省略变量 如果只要i，可写成 for i := range numbers ","date":"2021-02-15","objectID":"/go-study-04/:2:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"为什么要用range 意义明确，美观 ","date":"2021-02-15","objectID":"/go-study-04/:3:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组是值类型 [10]int 和[20]int 是不同类型 调用func f(arr [10]int) 会拷贝数组 在go语言中一般不直接使用数组 ","date":"2021-02-15","objectID":"/go-study-04/:4:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Slice(切片) arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s := arr[2:6] s的值为[2 3 4 5] arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s := arr[2:6] s[0] = 10 Slice 本身没有数据，是对底层array的一个view arr 的值变为[0 1 10 3 4 5 6 7] ","date":"2021-02-15","objectID":"/go-study-04/:5:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Reslice s := arr[2:6] s = s[:3] s = s[1:] s = arr[:] ","date":"2021-02-15","objectID":"/go-study-04/:6:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Slice 的实现 slice的实现\u0026ldquo;slice的实现\u0026rdquo; \"\rslice的实现\r ","date":"2021-02-15","objectID":"/go-study-04/:7:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Slice 的扩展 arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7} s1 := arr[2:6] s2 := arr[3:5] s1 的值为[2 3 4 5]，s2 的值为[5 6] slice 可以向后扩展，不可以向前扩展 s[i] 不可以超越 len(s)，向后扩展不可以超越底层数组cap(s) ","date":"2021-02-15","objectID":"/go-study-04/:8:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"向Slice 添加元素 添加元素时如果超越cap，系统就会重新分配更大的底层数组 由于值传递的关系，必须接受append的返回值 s = append(s, val) ","date":"2021-02-15","objectID":"/go-study-04/:9:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建Slice ","date":"2021-02-15","objectID":"/go-study-04/:10:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个前99个奇数 var s []int for i := 0; i \u003c 100; i++ { s = append(s, 2*i+1) } ","date":"2021-02-15","objectID":"/go-study-04/:10:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个确定的切片 s1 := []int{2, 4, 6, 8} ","date":"2021-02-15","objectID":"/go-study-04/:10:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个len为16的切片 s2 := make([]int, 16) ","date":"2021-02-15","objectID":"/go-study-04/:10:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建一个len为10，cap为32的切片 s3 := make([]int, 10, 32) ","date":"2021-02-15","objectID":"/go-study-04/:10:4","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"复制切片 copy(s2, s1) ","date":"2021-02-15","objectID":"/go-study-04/:11:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片的元素 ","date":"2021-02-15","objectID":"/go-study-04/:12:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片里的一个元素(删除s2的第四个元素) s2 = append(s2[:3], s2[4:]...) ","date":"2021-02-15","objectID":"/go-study-04/:12:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片第一个元素 s2 = s2[1:] ","date":"2021-02-15","objectID":"/go-study-04/:12:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"删除切片最后一个元素 s2 = s2[:len(s2)-1] ","date":"2021-02-15","objectID":"/go-study-04/:12:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map m := map[string]string { \"name\": \"cc\", \"course\": \"golang\", \"site\": \"im\", \"quality\": \"notbad\" } map[K]V, map[K1]map[K2]V ","date":"2021-02-15","objectID":"/go-study-04/:13:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map的操作 ","date":"2021-02-15","objectID":"/go-study-04/:14:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map的遍历 使用range遍历key，或者遍历key，value对 for k, v := range m { fmt.Println(k, v) } 不保证遍历顺序，如需顺序，需手动对key排序 使用len来获得元素的个数 ","date":"2021-02-15","objectID":"/go-study-04/:14:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"创建：make(map[string]int) //m2 == empty m2 := make(map[string]int) //m3 == nil var m3 map[string]int ","date":"2021-02-15","objectID":"/go-study-04/:14:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"获取元素：map[key] name := m[\"name\"] ","date":"2021-02-15","objectID":"/go-study-04/:14:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"key不存在时，获得Value类型的初始值 name1 := m[\"name1\"] ","date":"2021-02-15","objectID":"/go-study-04/:14:4","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"用value, ok := map[key]来判断是否存在key if name1, ok := m[\"name1\"]; ok { fmt.Println(name1) } else { fmt.Println(\"key does not exist\") } ","date":"2021-02-15","objectID":"/go-study-04/:14:5","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"使用delete来删除一个元素 delete(m, \"age\") ","date":"2021-02-15","objectID":"/go-study-04/:14:6","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Map的key map使用哈希表，必须可以比较相等 除了slice，map，function的内建类型都可以作为key Struct类型不包含上述字段，也可以作为key ","date":"2021-02-15","objectID":"/go-study-04/:15:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-15","objectID":"/go-study-04/:16:0","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"数组 在Go中数组是一个固定长度的数列。在Go中相对于数组而言，slice使用更多 func arraySample() { //创建了一个数组a来存放刚好5个int。元素类型和长度是数组类型的一部分 //数组默认是零值 var a [5]int fmt.Println(a) //使用array[index] = value语法来设置数组指定位置的值 //使用array[index]来得到值 a[4] = 100 fmt.Println(a) fmt.Println(a[4]) //使用内置函数len返回数组的长度 fmt.Println(\"len: \", len(a)) //使用这个语法一行内初始化一个数组 b := [5]int{1, 2, 3, 4, 5} fmt.Println(\"dcl: \", b) //数组的存储类型是单一的，但是可以组合这些数据来构造多维的数据结构 var twoD [2][3]int for i := 0; i \u003c 2; i++ { for j := 0; j \u003c 3; j++ { twoD[i][j] = i + j } } fmt.Println(\"2d: \", twoD) } ","date":"2021-02-15","objectID":"/go-study-04/:16:1","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"切片 Slice是Go中一个关键的数据类型，是一个比数组更加强大的序列接口 func sliceSample() { //slice的类型仅由它所包含的元素决定(不像数组还需要元素个数) //创建一个长度非零的空slice，需要使用内建的方法 make //创建一个长度为3的string类型slice(初始化为零值) s := make([]string, 3) fmt.Println(\"emp: \", s) //通过slice[index] = value来设置值 //slice[index]来获取值 s[0] = \"a\" s[1] = \"b\" s[2] = \"c\" fmt.Println(s) fmt.Println(s[2]) //通过len来获取slice长度 fmt.Println(\"len: \", len(s)) //作为基本操作的补充，slice支持比数组更多的操作 //其中一个是内建的append，它返回一个包含一个或多个新值的slice //slice底层是由指针数组和len以及cap组成的，append不会改变slice地址 s = append(s, \"d\") s = append(s, \"e\", \"f\") fmt.Println(\"append: \", s) //slice可以被copy //这里新建一个空的和s相同长度的slice c，并将s复制给c c := make([]string, len(s)) copy(c, s) fmt.Println(\"copy c: \",c) //slice支持通过slice[low:high]语法进行切片处理 l := s[2:5] fmt.Println(\"切片之后2-5slice: \", l) //这个slice从s[0]到(包含)s[5] l = s[:5] fmt.Println(\"从s[0]到s[5]: \", l) //这个slice从s[2]到s最后一个值 l = s[2:] fmt.Println(\"从s[2]到slice最后一个值: \", l) //在一行代码中声明并初始化一个slice变量 t := []string{\"g\", \"h\", \"i\"} fmt.Println(\"dcl: \", t) //slice可以组成多维数据结构 twoD := make([][]int, 3) for i := 0; i \u003c 3; i++ { innerlen := 4 twoD[i] = make([]int, innerlen) for j := 0; j \u003c innerlen; j++ { twoD[i][j] = i + j } } fmt.Println(\"2d: \", twoD) } ","date":"2021-02-15","objectID":"/go-study-04/:16:2","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"关联数组 map是Go内置关联数据类型(在其他语言成为哈希或字典) func mapsSample() { //要创建一个空的map，需要使用内建的map1 := make(map[key-type]value-type) m := make(map[string]int) fmt.Println(m) //使用经典的map1[key] = value语法来设置键值对 m[\"k1\"] = 1 m[\"k2\"] = 2 fmt.Println(\"map: \", m) //使用map1[key]来获取一个键的值 v1 := m[\"k1\"] fmt.Println(v1) //当对一个map调用内建len，返回的是键值对数目 fmt.Println(\"len: \", len(m)) //内建的delete可以从一个map中移除键值对 delete(m, \"k2\") fmt.Println(\"delete\", m) //从一个map中取值时，可选第二个返回值是这个键是否存在于map中 //这个可以用来消除键不存在或键有零值产生的歧义 _, prs := m[\"k2\"] fmt.Println(\"prs: \", prs) //一行申明和初始化一个map n := map[string]int{\"foo\": 1, \"bar\": 2, \"zhang\": 3} fmt.Println(n) } ","date":"2021-02-15","objectID":"/go-study-04/:16:3","tags":["golang"],"title":"Go Study 04","uri":"/go-study-04/"},{"categories":["学习"],"content":"Go Study 03-循环语句","date":"2021-02-15","objectID":"/go-study-03/","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"for for的条件里不需要括号 for的条件里可以省略初始条件，结束条件，递增表达式 sum := 0 for i := 1; i \u003c= 100; i++ { sum += i } 省略初始条件，相当于while func convertToBin(n int) string { result := \"\" for ; n \u003e 0; n /= 2 { lsp := n % 2 result = strconv.Itoa(lsp) + result } return result } 省略初始条件和递增条件，也相当于while func printFile(filename string) { file, err := os.Open(filename) if err != nil { panic(err) } // 逐行读取file的内容 scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } } 无限循环 func forever() { for { fmt.Println(\"abc\") } } ","date":"2021-02-15","objectID":"/go-study-03/:1:0","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"基本语法要点回顾 for, if后面的条件没有括号 if条件里也可以定义变量 没有while switch不需要break，也可以直接switch多个条件 ","date":"2021-02-15","objectID":"/go-study-03/:2:0","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"案例 func sample() { //1.最常用的方式，带单个循环条件 i := 1 for i \u003c= 3 { fmt.Println(i) i += 1 } //2.经典的初始化/条件/后续形式for循环 for j := 7; j \u003c= 9; j++ { fmt.Println(j) } //3.不带条件的for循环将一直执行，直到循环体内使用了break或者return来跳出循环 for { fmt.Println(\"loop\") break } } ","date":"2021-02-15","objectID":"/go-study-03/:3:0","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"Range遍历 range迭代各种各样的数据结构 func loopSample2() { //这里使用range来统计一个slice的元素个数，数组也采用这种方式 nums := []int{2,4,5,3} sum := 0 for _, num := range nums { sum += num } fmt.Println(\"sum: \", sum) //range在数组和slice中同样提供了每项的索引和值 //不需要索引时可以使用_来忽略她 for i, num := range nums { if num == 3 { fmt.Println(\"index: \", i) } } //range在map中迭代键值对 kvs := map[string]string{ \"name\": \"cc\", \"age\": \"18\", } for k, v := range kvs { fmt.Printf(\"%v -\u003e %v\\n\", k, v) } //range在字符串中迭代Unicode编码 for i, v := range \"go\" { fmt.Println(i, v) } } ","date":"2021-02-15","objectID":"/go-study-03/:3:1","tags":["golang"],"title":"Go Study 03","uri":"/go-study-03/"},{"categories":["学习"],"content":"Go Study 02-条件语句","date":"2021-02-15","objectID":"/go-study-02/","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"if if的条件里不需要括号 func bounded(v int) int { if v \u003e 100 { return 100 } else if v \u003c 0 { return 0 } else { return v } } if的条件里可以赋值 if contents, err := ioutil.ReadFile(filename); err != nil { fmt.Println(err) } else { fmt.Printf(\"%s\\n\", contents) } if条件里赋值的变量作用域就在这个if语句里 ","date":"2021-02-15","objectID":"/go-study-02/:1:0","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"switch switch会自动break，除非使用fallthrough func eval(a, b int, op string) int { var result int switch op { case \"+\": result = a + b case \"-\": result = a - b case \"*\": result = a * b case \"/\": result = a / b default: panic(\"unsupported operator:\" + op) } return result } switch后可以没有表达式 func grade(score int) string { g := \"\" switch { case score \u003c 60: g = \"D\" case score \u003c 80: g = \"C\" case score \u003c 90: g = \"B\" case score \u003c= 100: g = \"A\" default: panic(fmt.Sprintf(\"Wrong score: %d\", score)) } return g } ","date":"2021-02-15","objectID":"/go-study-02/:2:0","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-15","objectID":"/go-study-02/:3:0","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"if/else分支 if和else分支结构在Go中当然是直接了当的了 func branchSample1() { if 7 % 2 == 0 { //7是偶数 fmt.Println(\"7 is even\") } else { //7是奇数 fmt.Println(\"7 is odd\") } //也可以不要else，只用if if 8 % 4 == 0 { fmt.Println(\"8 is divisible by 4\") } //在条件语句之前可以有一个语句，任何在这里声明的变量都可以在所有的条件分支中使用 if num := 9; num \u003c 0 { fmt.Println(num, \"is negative\") } else if num \u003c 10 { fmt.Println(num, \"has 1 digit\") } else { fmt.Println(num, \"has multiple digit\") } } ","date":"2021-02-15","objectID":"/go-study-02/:3:1","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"switch分支 func branchSample2() { //一个基本的switch i := 2 switch i { case 1: fmt.Println(\"one\") case 2: fmt.Println(\"two\") case 3: fmt.Println(\"three\") } //在一个case语句中可以使用逗号分割多个表达式 //使用了可选的default分支 switch time.Now().Weekday() { case time.Saturday, time.Sunday: fmt.Println(\"It's the weekend\") default: fmt.Println(\"It's a weekday\") } //不带表达式的switch是实现if/else的另一种方式 //这里展示了case表达式是如何使用非常量的 t := time.Now() switch { case t.Hour() \u003c 12: fmt.Println(\"it's before noon\") default: fmt.Println(\"it's after noon\") } } ","date":"2021-02-15","objectID":"/go-study-02/:3:2","tags":["golang"],"title":"Go Study 02","uri":"/go-study-02/"},{"categories":["学习"],"content":"Go Study 01-变量常量","date":"2021-02-15","objectID":"/go-study-01/","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"变量定义 ","date":"2021-02-15","objectID":"/go-study-01/:1:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"使用var关键字 var a,b,c bool var s1,s2 string = “hello”, “world” 可以放在函数内，或直接放在包内 使用var()集中定义变量 ","date":"2021-02-15","objectID":"/go-study-01/:1:1","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"让编译器自动决定类型 var a,b,i,s1,s2 = true, false, 3, “hello”, “world” ","date":"2021-02-15","objectID":"/go-study-01/:1:2","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"使用:=定义变量 a,b,i,s1,s2 := true, false, 3, “hello”, “world” 只能在函数内使用 ","date":"2021-02-15","objectID":"/go-study-01/:1:3","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"内建变量类型 bool, string (u)int, (u)int8, (u)int16, (u)int32, (u)int(64), uintptr(指针) byte, rune float32, float64, complex64, complex128 (complex是复数) ","date":"2021-02-15","objectID":"/go-study-01/:2:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"强制类型转换 类型转换是强制的 var a,b int = 3, 4 var int = math.Sqrt(aa + bb) (错误) var int = int(math.Sqrt(float64(aa + bb))) (正确) ","date":"2021-02-15","objectID":"/go-study-01/:3:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"常量定义 const filename = “abc.txt” const 数值可以作为各种类型使用 const a, b = 3, 4 var c int = int(math.Sqrt(aa + bb)) ","date":"2021-02-15","objectID":"/go-study-01/:4:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"使用常量定义枚举类型 普通枚举类型 const ( cpp = 1 java = 2 python = 3 golang = 4 ) 自增值枚举类型 const ( cpp = iota java python golang ) ","date":"2021-02-15","objectID":"/go-study-01/:5:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"变量定义要点回顾 变量类型写在变量名之后 编译器可推测变量类型 没有char，只有rune 原生支持复数类型 ","date":"2021-02-15","objectID":"/go-study-01/:6:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"案例 ","date":"2021-02-15","objectID":"/go-study-01/:7:0","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"值 Go拥有各值类型，包括字符串，整型，浮点型，布尔型等 func value() { //字符串通过+连接 fmt.Println(\"go\" + \"lang\") //浮点数和整数 fmt.Println(\"1+1=\", 1+1) fmt.Println(\"7.0/3.0=\", 7.0/3.0) //布尔型和逻辑运算符 fmt.Println(true \u0026\u0026 false) fmt.Println(true || false) fmt.Println(!true) } ","date":"2021-02-15","objectID":"/go-study-01/:7:1","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"变量 在Go中，变量被显式声明，并被编译器所用来检查函数调用时的类型正确性 func varible() { //声明一个变量 var a string = \"initial\" fmt.Println(a) //声明多个变量 var b, c int = 1, 2 fmt.Println(b, c) //Go 将自动推断已经初始化的变量类型 var d = true fmt.Printf(\"%T %v\\n\", d, d) //声明变量且没有给出对应初始值，变量会被初始化为零值 var e int fmt.Println(e) //:=语句是申明并初始化变量的简写 f := \"short\" fmt.Println(f) } ","date":"2021-02-15","objectID":"/go-study-01/:7:2","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"常量 Go支持字符、字符串、布尔和数值常量 func constant() { //const用于声明一个常量 const s = \"constant\" fmt.Println(\"s=\", s) //const语句可以出现在任何var语句可以出现的地方 const n = 500000000 fmt.Println(n) //常数表达式可以执行任意精度的运算 const d = 3e20 / n fmt.Println(\"d = 3e20/n : \", d) //数值型常量是没有确定的类型，直到他们被给定一个类型，比如说一次显示的类型转化 fmt.Println(\"int64(d) = \", int64(d)) //当上下文需要的时候，一个数可以被给定一个类型，比如变量赋值或函数调用 //举个栗子，这里的math.Sin()需要一个float64参数 fmt.Println(\"math.Sin(n) = \", math.Sin(n)) } ","date":"2021-02-15","objectID":"/go-study-01/:7:3","tags":["golang"],"title":"Go Study 01","uri":"/go-study-01/"},{"categories":["学习"],"content":"Linux Network 02","date":"2021-02-14","objectID":"/linux-network-02/","tags":["Linux网络编程"],"title":"Linux Network 02","uri":"/linux-network-02/"},{"categories":["学习"],"content":"Socket(套接字)编程 ","date":"2021-02-14","objectID":"/linux-network-02/:1:0","tags":["Linux网络编程"],"title":"Linux Network 02","uri":"/linux-network-02/"},{"categories":["学习"],"content":"套接字概念 在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系 socket通信原理socket通信原理 \"\rsocket通信原理\r 在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区 ","date":"2021-02-14","objectID":"/linux-network-02/:1:1","tags":["Linux网络编程"],"title":"Linux Network 02","uri":"/linux-network-02/"},{"categories":["学习"],"content":"Linux Network 01","date":"2021-02-13","objectID":"/linux-network-01/","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"协议的概念 ","date":"2021-02-13","objectID":"/linux-network-01/:1:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"什么是协议？ 从应用的角度出发，协议可以理解为“规则”，是数据传输和数据解释的规则 ","date":"2021-02-13","objectID":"/linux-network-01/:1:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"典型协议 传输层 常见的协议有TCP/UDP协议 应用层 常见的协议有HTTP/FTP协议 网络层 常见的协议有IP/ICMP/IGMP协议 网络接口层 常见的协议有ARP/RARP协议 TCP传输控制协议是一种面向连接的、可靠地、基于字节流的传输层通信协议 UDP用户数据报协议是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务 HTTP超文本传输协议是互联网上应用最广泛的一种网络协议 FTP文件传输协议 IP协议是因特网互联协议 ICMP协议是Internet控制报文协议，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息 IGMP协议是Internet组管理协议，是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间 ARP协议是正向地址解析协议，通过已知IP寻找对应主机的MAC地址 RARP协议是反向地址转换协议，通过MAC地址确定IP地址 ","date":"2021-02-13","objectID":"/linux-network-01/:1:2","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"网络应用程序设计模式 ","date":"2021-02-13","objectID":"/linux-network-01/:2:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"C/S模式 传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信 ","date":"2021-02-13","objectID":"/linux-network-01/:2:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"B/S模式 浏览器(Brower)/服务器(server)模式。只需要在一端部署服务器，而另一端使用每台PC都默认配置的浏览器即可完成数据的传输 ","date":"2021-02-13","objectID":"/linux-network-01/:2:2","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"C/S优缺点 优点 1、协议选用灵活 2、数据可以提前缓存 缺点 1、对用户安全构成威胁 2、开发工作量较大 ","date":"2021-02-13","objectID":"/linux-network-01/:2:3","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"B/S优缺点 优点 1、不会安装第三方软件，安全性高 2、只需要开发服务端，工作量减小 3、可以跨平台 缺点 1、需要支持HTTP协议 2、不能进行数据缓存 ","date":"2021-02-13","objectID":"/linux-network-01/:2:4","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"分层模型 OSI参考模型 TCP/IP模型 应用层-- 表示层 |-\u003e 应用层 会话层-- 传输层 传输层 网络层 网络层 数据链路层-|-\u003e 网络接口层 物理层------ ","date":"2021-02-13","objectID":"/linux-network-01/:3:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"OSI七层模型 1、物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。他的主要作用是传输比特流 2、数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输 3、网络层：在位于不同地理位置的网络中的两个主机系统之间提供链接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层 4、传输层：定义了一些传输数据的协议和端口号(www端口80等)，如：TCP(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，UDP(用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的)。主要是将下层接受的数据进行分段和传输，达到目的地址后再进行重组，常常把这一层数据叫做段。 5、会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求(设备之间需要互相认识可以是IP也可以是MAC或者是主机名)。 6、表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用读取。如：PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码(ASCII)来表示相同字符，如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 7、应用层：是最靠近用户的OSI层，这一层为用户的应用程序(例如电子邮件、文件传输和终端仿真)提供网络服务 ","date":"2021-02-13","objectID":"/linux-network-01/:3:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"TCP/IP四层模型 TCP/IP网络协议栈分为应用层、传输层、网络层、链路层四层 其中应用层典型的是FTP协议，传输层典型的是TCP或UDP协议，网络层典型的是IP协议，链路层典型的是以太网帧协议 TCP/IP模型TCP/IP模型 \"\rTCP/IP模型\r ","date":"2021-02-13","objectID":"/linux-network-01/:3:2","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"通信过程 通信过程通信过程 \"\r通信过程\r ","date":"2021-02-13","objectID":"/linux-network-01/:4:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"协议格式 ","date":"2021-02-13","objectID":"/linux-network-01/:5:0","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"数据包封装 数据包封装TCP/IP数据包封装 \"\r数据包封装\r ","date":"2021-02-13","objectID":"/linux-network-01/:5:1","tags":["Linux网络编程"],"title":"Linux Network 01","uri":"/linux-network-01/"},{"categories":["学习"],"content":"java02","date":"2021-02-10","objectID":"/java02/","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"标识符注意点 所有的标识符都应该以字母(A-Z或者a-z)，美元符($)或者下划线(_)开始 首字符之后可以是字母(A-Z或者a-z)，美元符($)，下划线(_)或数字的任何字符组合 不能使用关键字作为变量名或者方法名 标识符是大小写敏感的 合法标识符举例：age、$salary、_value、__1_value 非法标识符举例：123abc、-salary、#abc 可以使用中文命名，但是一般不建议这样去使用，也不建议使用拼音，很Low 数据类型 ","date":"2021-02-10","objectID":"/java02/:0:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"强类型语言 要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用 ","date":"2021-02-10","objectID":"/java02/:1:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"弱类型语言 ","date":"2021-02-10","objectID":"/java02/:2:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"java的数据类型分为两大类 基本类型(primitive type) 数值类型 整数类型 byte占一个字节范围：-128~127 short占两个字节范围：-32768~32767 int占四个字节范围：… long占八个字节范围：… 浮点类型 float占四个字节 double占八个字节 字符类型 char占两个字节 boolean类型：占一位其值只有true和false两个 引用类型(reference type) 类 接口 数组 什么是字节 位(bit)：是计算机内部数据储存的最小单位，11001100是一个八位二进制数 字节(byte)：是计算机数据处理的基本单位，习惯上用大写B来表示 1B(byte，字节) = 8bit(位) 字符：是指计算机中使用的字母、数字、字和符号 1bit表示1位 1Byte表示一个字节 1B=8b 1024B = 1KB 1024KB = 1M 1024M = 1G 类型转换 由于java是强类型语言，所以要进行有些运算的时候，需要用到类型转换 低-\u003e高 byte,short,char-\u003eint-\u003elong-\u003efloat-\u003edouble 运算中，不同的数据类型先转换成同一类型，然后进行运算 强制类型转换 (类型)变量名 高到低 自动类型转换 低到高 注意点： 1、不能对布尔值进行转换 2、不能把对象类型转换成不相关的类型 3、在把高容量转换成低容量的时候，强制转换 4、转换的时候可能存在内存溢出或者精度问题 变量 变量是什么？ 变量就是可以变化的量 java是一种强类型语言，每个变量都必须声明其类型。 java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域 注意事项： 每个变量都有类型，类型可以是基本类型，也可以是引用类型 变量名必须是合法的标识符 变量声明是一条完整的语句，因此每一个声明都必须以分号结束 变量的命名规范 所有变量、方法、类名：见名知意 类成员变量：首字母小写和驼峰原则：monthSalary 局部变量：首字母小写和驼峰原则 常量：大写字母和下划线：MAX_VALUE 类名：首字母大写和驼峰原则：Man，GoodMan 方法名：首字母小写和驼峰原则：run()，runRun() 常量 常量(Constant)：初始化(initialize)后不能再改变值！不会变动的值 所谓常量可以理解为一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变 final 常量名 = 值; 常量名一般使用大写字符 ","date":"2021-02-10","objectID":"/java02/:3:0","tags":["java"],"title":"Java02","uri":"/java02/"},{"categories":["学习"],"content":"java01","date":"2021-02-09","objectID":"/java01/","tags":["java"],"title":"Java01","uri":"/java01/"},{"categories":["学习"],"content":"java是一门跨平台语言(jvm虚拟机) java特性和优势 简单性 面向对象 可移植性(write once, run anywhere) 高性能 分布式 动态性 多线程 安全性 健壮性 java三大版本 javaSE：标准版(桌面程序，控制台开发…) javaME：嵌入式开发(手机，小家电…) javaEE：E企业级开发(web端，服务器开发…) JDK、JRE、JVM JDK：Java Development Kit(java开发者工具) JRE：Java Runtime Environment(java运行时环境) JVM：Java Virtual Machine(java虚拟机) JDK\u003eJRE\u003eJVM","date":"2021-02-09","objectID":"/java01/:0:0","tags":["java"],"title":"Java01","uri":"/java01/"},{"categories":["学习"],"content":"dos常用命令","date":"2021-02-08","objectID":"/dos-code/","tags":["dos"],"title":"Dos Code","uri":"/dos-code/"},{"categories":["学习"],"content":"盘符切换 切换到C盘： c: 切换到E盘： e: 查看当前目录下的所有文件 dir 切换目录 cd change directory cd .. 清理屏幕 cls 退出终端 exit 查看电脑ip ipconfig 打开应用 calc mspaint notepad ping命令 ping 192.168.1.* 文件操作 创建一个文件夹：md 目录名 移除一个文件夹：rd 目录名 创建一个文件： cd\u003e 文件名 移除一个文件： del 文件名","date":"2021-02-08","objectID":"/dos-code/:0:0","tags":["dos"],"title":"Dos Code","uri":"/dos-code/"},{"categories":["学习"],"content":"markdown学习01","date":"2021-02-07","objectID":"/markdown-study01/","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"1 标题 ","date":"2021-02-07","objectID":"/markdown-study01/:0:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"h2 标题 ","date":"2021-02-07","objectID":"/markdown-study01/:1:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"h3 标题 h4 标题 h5 标题 h6 标题、 要添加自定义标题ID，请在与标题相同的行中将自定义ID放在花括号中 ###一个很棒的标题 {#custom-id} 2 注释 注释和HTML兼容的 3 水平线 HTML中的\u003chr\u003e标签是用来在段落元素之间创建一个“专题间隔”的 Markdown可以使用以下方式： -–：三个连续的破折号 ___：三个连续的下划线 ***：三个连续的星号 4 段落 HTML中将用\u003cp\u003e\u003c/p\u003e标签包裹 Markdown直接按照纯文本的方式书写段落 5 内联HTML元素 这是HTML 6 强调 ","date":"2021-02-07","objectID":"/markdown-study01/:1:1","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"加粗 用于强调带有较粗字体的文本片段 以下文本会被渲染为粗体 **渲染为粗体** __渲染为粗体__ 输出的HTML看起来像这样 \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2021-02-07","objectID":"/markdown-study01/:2:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"斜体 用于强调带有斜体的文本片段 以下文本片段被渲染成斜体 *渲染为斜体* _渲染为斜体_ 输出的HTML看起来像这样 \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2021-02-07","objectID":"/markdown-study01/:3:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"删除线 以下文本片段会被渲染成删除线 ~~这段文本带有删除线~~ 输出的HTML看起来像这样 \u003cdel\u003e这段文本带有删除线\u003c/del\u003e 这段文本带有删除线 ","date":"2021-02-07","objectID":"/markdown-study01/:4:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"组合 加粗，斜体和删除线可以组合使用 ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除和斜体*~~ ~~***加粗，斜体和删除线***~~ 输出的HTML看起来像这样 \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003cem\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗，斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e 加粗和斜体 删除线和加粗 删除和斜体 加粗，斜体和删除线 7 引用 用于在文档中引用其他来源的内容块 在要引用的任何文本之前添加\u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage 输出的HTML看起来像这样 \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套 \u003e **Fusion Drive** combines a hard drive with a flash storage \u003e\u003e 111 Fusion Drive combines a hard drive with a flash storage 111 8 列表 ","date":"2021-02-07","objectID":"/markdown-study01/:5:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"无序列表 一系列项的列表，其中项的顺序没有明显关系 你可以使用以下任何符号来表示无序列表中的项 * 一项内容 * 子内容 - 一项内容 + 一项内容 一项内容 子内容 一项内容 一项内容 ","date":"2021-02-07","objectID":"/markdown-study01/:6:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"有序列表 一系列项的列表，其中项的顺序确实很重要 1. a 2. b 3. c 输出的HTML看起来像这样 \u003col\u003e \u003cli\u003ea\u003c/li\u003e \u003cli\u003eb\u003c/li\u003e \u003cli\u003ec\u003c/li\u003e \u003c/ol\u003e a b c ","date":"2021-02-07","objectID":"/markdown-study01/:7:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"任务列表 任务列表使你可以创建带有复选框的列表，要创建列表，请在任务列表项之前添加破折号(-)和带有空格的方括号([ ])，要选择复选框，请在方括号之间添加x([x]) - [x] a - [ ] b - [ ] c Write the press release Update the website Contact the media 9 代码 ","date":"2021-02-07","objectID":"/markdown-study01/:8:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"行内代码 用\\包装行内代码段 在这个例子中, \\\u003csection\u003e\\\u003c/section\u003e 会被包裹成 **代码**. \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e 呈现的输出效果如下： 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. ","date":"2021-02-07","objectID":"/markdown-study01/:9:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"缩进代码 // Some comments line 1 of code line 2 of code line 3 of code 输出的HTML看起来像这样： \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e 呈现的输出效果如下： // Some comments line 1 of code line 2 of code line 3 of code ","date":"2021-02-07","objectID":"/markdown-study01/:10:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"围栏代码块 使用“围栏”```来生成一段带有语言属性的代码块 Sample text here... Sample text here... 10 表格 通过在每个单元格之间添加竖线作为分隔线，并在标题下添加一行破折号(也由竖线分隔)来创建表格，注意竖线不需要垂直对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中 | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 输出的HTML看起来像这样 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 链接 ","date":"2021-02-07","objectID":"/markdown-study01/:11:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 输出的HTML看起来像这样 \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e 呈现的输出效果如下(将鼠标悬停在链接上，没有提示) https://assemble.io contact@revolunet.com Assemble ","date":"2021-02-07","objectID":"/markdown-study01/:12:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["学习"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 输出的HTML看起来像这样 \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e 呈现的输出效果如下(将鼠标悬停在链接上，会有一行提示) Upstage 12 脚注 脚注使你可以添加注释和参考，而不会使文档正文混乱，当你使用脚注时，会在添加脚注引用的位置出现带有链接的上标标号，读者可以单击链接以跳至页面底部的脚注内容 要创建脚注引用，请在方括号中添加插入符号和标识符 (1)，标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号。 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 (1：这是一段脚注)。你不一定要在文档末尾添加脚注. 可以将它们放在除列表，引用和表格等元素之外的任何位置。 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 13 图片 图片的语法与链接相似，但包含一个在前面的感叹号 ![Minion](https://octodex.github.com/images/minion.png) ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2021-02-07","objectID":"/markdown-study01/:13:0","tags":["markdown"],"title":"Markdown Study01","uri":"/markdown-study01/"},{"categories":["生活"],"content":"第一篇blog","date":"2021-02-05","objectID":"/first_post/","tags":["我的"],"title":"First_post","uri":"/first_post/"},{"categories":["生活"],"content":"first post LoveIt主题中文文档 emoji表情 去露营啦! ⛺ 很快就回来. 真开心! 😂 blog前置参数注解 ","date":"2021-02-05","objectID":"/first_post/:0:0","tags":["我的"],"title":"First_post","uri":"/first_post/"},{"categories":null,"content":"aa ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]