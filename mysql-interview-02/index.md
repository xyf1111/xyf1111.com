# Mysql Interview 02

<!--more-->
## 事务的四大特性（ACID）原子性，一致性，隔离性，持久性？
### 原子性
根据定义，原子性是指一个事务是一个不可分割的工作单位，其中操作要么都做，要么都不做。不存在中间状态。
### 一致性
根据定义一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。
### 隔离性 
根据定义，隔离性是指多个事务并发执行时，事务内部操作和其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
### 持久性
根据定义，持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来其他操作或故障不应该对其有任何影响。
## 数据库隔离级别，每个级别会引发什么问题，mysql默认是什么级别的
### 脏读
脏读是指在一个事务中读到另一个未提交事务的数据。

当一个事务正在多次修改某个数据而这个事务中多次修改都尚未提交，此时另一个并发事务来访问该数据，就会造成两个事务得到的数据不一致。

举个例子：A在一个转账事务中，转了100给B，此时，B读到了这个转账数据，然后做了一些操作（发货给A或其他操作），可这个时候A的事务并没有提交，如果A回滚了事务，就会发生数据问题。这就是脏读。
### 不可重复读
不可重复读是指对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据。这是由于在查询间隔，被另一个事务修改并提交了。

例如：事务T1读取某一数据，而事务T2马上修改数据并提交给数据库，事务T1再次读取就得到了不同的结果，发生了不可重复读。

不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，不可重复读则是读取了前一事务提交的数据
### 幻读
幻读是指事务非独立执行时发生的一种现象。

例如：事务T1对一个表中的所有的行的某一数据做了从1修改为2的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项还是1并且提交给了数据库。而事务T1如果再次查看刚刚修改的数据，会发现还有一行未修改，其实这行是T2添加的，就好像产生了幻觉。这就是幻读。

幻读和不可重复读的区别，幻读和不可重复读都是读取另一个以提交的事务（这点就和脏读不同），不同的是，不可重复读查询的都是同一个数据项，而幻读是针对一批数据整体（比如数据个数）
### MySQL提供的四种隔离模式
1. Serializable（串行化）：可以避免脏读，不可重复读和幻读的发生。
2. Repeatable read（可重复读）：可以避免脏读，不可重复读的发生。
3. Read committed（读已提交）：可避免脏读的发生。
4. Read uncommitted（读未提交）：最低级别，都无法避免。

以上四种模式最高是Serializable级别，最低是Read uncommitted级别。级别越高效率越低。像是Serializable这样的级别就是以锁表的方式使得其他事务只能在锁外等待。MySQL数据库默认的级别为Read committed
## MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别
### InnoDB
支持事务，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大优势。如果需要频繁的更新，删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）
### MyISAM
插入数据快，空间和内存使用比较低。如果表主要是用于插入新数据和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性和并发性要求比较低，也可以使用。
### MEMORY
所有数据都在内存中，数据的处理快，但是安全性不高，如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMORY。其对表的大小有所要求，不能建立太大的表。所以这类数据库只使用在相对较小的数据库表。
## MySQL的MyISAM和InnoDB两种存储引擎在事务、锁级别，各自的使用场景
### MyISAM特点
- 不支持行锁（MyISAM只有表锁），读取时对需要读到的所有表进行加锁，写入时则对表加排它锁
- 不支持事务
- 不支持外键
- 不支持崩溃后安全修复
- 在表有读取查询时，支持往表中插入新数据
- 支持BLOG和TEXT的前500个字符索引，支持全文索引
- 支持延时更新索引，极大的提升写入性能
- 对于不会进行修改的表，支持压缩表，极大的减少对磁盘空间的占用
### InnoDB特点
- 支持行锁，采用MVCC来支持高并发，有可能死锁
- 支持事务
- 支持外键
- 支持崩溃后的安全修复
- 不支持全文索引
### 各自的使用场景
MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询时，那么MyISAM是更好的选择。

InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。

但是实际场景中，针对具体问题具体分析，一般遵循以下几个问题？
- 数据库是否有外键
- 是否需要事务支持
- 是否需要全文索引
- 数据库经常使用什么查询模式？在写多读少的应用中还是InnoDB插入性能更稳定，在并发情况下也基本，如果是对读取速度要求比较快的应用还是选MyISAM
- 数据库的数据大小？大尺寸倾向与InnoDB，因为有事务日志，故障修复
## SQL查询语句（where，join，limit，group by，having）执行先后顺序
一个查询语句同时出现以上关键词时执行顺序是：
1. 执行where xxx对全表数据做筛选，返回第一个结果集
2. 针对第一个结果集使用group by分组，返回第二个结果集
3. 针对第二个结果集中的每一组数据执行select xxx，有几组就执行几次，返回第三个结果集
4. 针对第三个结果集执行having xxx进行筛选，返回第四个结果集
5. 针对第四个结果集排序
总结一个顺序：我（W）哥（G）是（SH）偶（O）像（W->G->S->H->O）
## 什么是临时表，临时表什么时候删除
### 什么是临时表
MySQL用于存储一些中间结果集的表，临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。
### 为什么会产生临时表
一般是由于复杂的SQL导致临时表被大量创建
### 临时表的分类
临时表分为两种，一种是内存临时表，一种是磁盘临时表。内存临时表采用的是MEMORY存储引擎，磁盘临时表采用的是MyISAM存储引擎（磁盘临时表也可以使用InnoDB存储引擎，通过参数来控制使用那种存储引擎，从MySQL5.7.6版本后默认为InnoDB存储引擎，之前版本一直默认的是MyISAM存储引擎）
### 下面操作会使用到临时表
- union查询
- 对于视图操作，比如使用一些TEMPTABLE算法，union或aggregation
- 子查询
- join包括not in，exist等
- 查询产生的派生表
- 复杂的group by或order by
- insert，select同一个表，mysql会产生一个临时表缓存select行
- 多个表更新
- GROUP_CONCAT()或COUNT(DISTINCT)
### MySQL以下操作会阻止内存临时表的建立，直接使用磁盘临时表
- 表含有BLOG或TEXT列
- 使用union或union all时，select子句有大于512字节的列
- Show columns或desc表时，有LOB或TEXT
- GROUP BY或DISTINCY子句中包含列大于512字节的列
## MySQL B+Tree索引和Hash索引的区别
### 区别
由于Hash索引结构的特殊性，其检索效率特别高，索引的检索可以一次定位，不想B-Tree索引需要从根节点到枝节点，最后才能访问到叶节点这样多次访问，所以Hash索引的查询效率是要远高于B-Tree索引
### 为何采用B-Tree而不采用Hash
任何事物都有两面性，Hash索引也一样，虽然Hash索引效率高，但是Hash索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些
1. Hash索引仅仅能满足于“=”，“in”和“<=>”查询，不能使用范围查询。
- 由于Hash索引比较的是Hash运算之后的Hash值，所以只能使用等值过滤，不能用于基于范围的过滤，因为经过相应的Hash算法处理后的Hash值的大小关系，并不能保证和Hash运算前完全一样
2. Hash索引无法用来避免数据的排序操作。
- 由于Hash索引中存放是经过Hash计算之后的Hash值，而且Hash值的大小关系还不一定和Hash运算之前的键值完全一样，所以数据库无法通过索引的数据来避免任何排序运算
3. Hash索引不能利用部分索引键查询
- 对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用。
4. Hash索引在任何时候都不能避免表扫描
- Hash索引是将索引键通过Hash运算后，将Hash运算结果和所对应的指针信息存放在一个Hash表中由于不同的索引键中存在相同的Hash值，所以即使满足某个Hash键值数据的记录条数也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。
5. Hash索引遇到大量Hash值相等的情况后性能就不一定比B-Tree高

对于选择性较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样会浪费多次表数据访问，造成整体性能低下。
