# Mysql Interview 04

<!--more-->
## MySQL锁
### MVCC总结
MVCC（多版本并发控制）指的就是在使用READ COMMITTED，REPEATABLE READ这两种隔离级别的事务在执行普通的select操作时访问记录的版本链的过程。可以使不同事务的读-写，写-读操作并发执行，从而提升系统性能。READ COMMITTED、REPEATABLE READ这两个隔离级别一个很大的不同就是：生成ReadView的时机不同，READ COMMITTED是每一次进行普通SELECT操作前都会生成一次ReadView。而REPEATABLE READ只会在第一次进行普通SELECT的时候生成ReadView。之后的查询重复使用这个ReadView。
### MySQL锁的介绍
1. 按照锁的粒度来说，MySQL主要包含三种锁：全局锁，表级锁，行级锁
- 全局锁，锁的是整个database，由MySQL的Sql layer层实现
- 表级锁，锁的是整张表，由MySQL的Sql layer层实现
- 行级锁，锁的是某行数据，也可能锁的是行之间的间隙，由存储引擎实现
2. 按照锁的功能来分，可以分为共享锁和排他锁
- 共享锁：也称S锁，加了S锁，允许其他事务再加S锁，但是不允许其他事务加X锁。加锁方式select ... lock in share mode
- 排他锁：也称X锁，加了X锁，不允许其他事务再加X锁或S锁。加锁方式：select ... for update(delete|insert)
### 不同粒度锁的比较
- 表级锁：开销小，加锁快。不会出现死锁，锁定粒度大，发生锁冲突概率最高，并发度最低。
    - 这些存储引擎通过总是一次性同时获取所有需要锁以及总是按相同顺序获取表锁避免死锁
    - 表级锁主要适合以查询为主，并发数量少，只有少量按索引条件更新数据的应用，如WEB应用
- 行级锁：开销大，加锁慢。会出现死锁，锁定粒度最小，发生锁冲突概率最低，并发度也最高
    - 最大程度支持并发，同时也带来了最大的锁开销
    - 在InnoDB中，除单个SQL组成的事务外，锁是逐步获取的，这就决定了在InnoDB发生死锁是可能的
    - 行级锁只是在存储引擎层实现，而MySQL服务层没有实现。行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理系统
### InnoDB锁模式
InnoDB实现了以下两种锁
- 共享锁（S）：允许一个事务去读行，阻止其他事务获得相同数据集的排他锁
- 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁

为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，这两种锁都是表锁
- 意向共享锁（IS）：事务打算个数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁

锁与锁之间如果相容，MySQL会给予锁，不相容则会阻塞。
### InnoDB加锁方式
- 意向锁是InnoDB自动加的，不需用户干预
- 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加共享锁或排他锁
- 对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显式给记录集加共享锁或排他锁：
    - 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。其他session仍然可以查询记录，并也可以对该记录加SHARE MODE的共享锁。但如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。
    - 排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE。其他session可以查询该记录。但是不能对该记录加共享锁或排他锁，而是等待获得锁。
- 隐式锁定

    InnoDB在事务执行过程中，使用两阶段锁协议：

    随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自行加锁；

    锁只有在执行commit或rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。
- 显示锁定

    select ... lock in share mode   //共享锁

    in share mode子句在作用就是将查找到的数据加上一个share锁，这个就是表示其他的事务只能进行简单的select操作，并不能够进行DML操作。

    select ... lock in share mode使用场景：为了确保自己查到的数据没有被其他事务正在修改，也就是确保查到的数据是最新的数据，并且不允许其他事务来修改数据。但是自己不一定能修改数据，因为有可能其他事务也对这些数据使用了in share mode的方式上了S锁

    select ... for update           //排他锁

    在执行这个select查询语句的时候，会将相应的索引访问条目进行上排他锁（X锁），也就是说这个语句对应的锁就相当于update带来的效果

    select ... for update 的使用场景：为了让自己查到的数据确保是最新的数据，并且查到后的数据只允许自己来修改的时候，需要用到for update子句
- 性能影响

    select ... for update语句，相当于一个UPDATE语句。在业务繁忙的情况下，如果事务没有及时的commit或rollback可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。

    select ... lock in share mode语句是给一个查找语句上一个共享锁（S）的功能，它允许其他事务也对该事务上S锁，但是不能够允许对数据进行修改。如果不及时的commit或rollback也可能造成大量的事务等待。
- InnoDB行锁实现方式
    - InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL和Oracle完全不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只用通过索引条件检索数据，InnoDB才使用行锁，否则InnoDB将使用表锁。
    - 不论是主键索引，唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁
    - 只有在执行计划中真正使用了索引，才能使用行锁：即使在条件中使用了索引字段，但是否使用索引来检索数据是有MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，MySQL就不会使用索引，这种情况下InnoDB将使用表锁，而不是使用行锁。因此在分析锁冲突的时候可以检查SQL的执行计划（可以通过explain检查SQL的执行计划），已确认是否真正使用了索引。
### 乐观锁和悲观锁
悲观锁是指在数据处理过程中是数据处于锁定状态。在MySQL中使用悲观锁，必须关闭MySQL自动提交，set autocommit = 0，MySQL默认使用自动提交模式，即使你执行一个更新操作，MySQL会自动将结果提交。

select ... for update 是MySQL提供实现悲观锁的方式。执行后该数据将被锁定，直到获得该锁的事务提交或回滚后，锁才能释放。其他要执行该数据的事务才能执行。

乐观锁相对于悲观锁来说，一般来说是不会造成冲突，所以只有在数据提交更新的时候，才会正式对数据的冲突与否进行检测。如果发现冲突了，则让返回错误信息，让用户决定如何去做。

利用数据版本号（version）机制是乐观锁最常用的一种实现方式，一般通过为数据库添加一个version字段，当读取数据的时候，将version字段的数据一同读出，数据每更新一次，对此version值+1。当提交更新的时候，判断数据库对应的当前的版本信息是否与第一次去出来的版本信息相等，相等则予以更新，不相等认为是过期的数据，返回更新失败。
