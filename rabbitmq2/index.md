# RabbitMQ2

## 任务队列/工作队列
在第一个教程中，我们编写程序从命名的队列发送和接收消息。在这一节中，我们将创建一个工作队列，该队列将用于多个工人之间分配耗时的任务。

工作队列(又称任务队列)的主要思想是避免立即执行某些资源密集型任务并且不得不等待这些任务完成。相反，我们安排任务异步地同时或当前任务之后完成。我们将任务封装成消息并将其发送到队列，在后台运行的工作进程将取出消息并最终执行任务。当你运行多个工作进程时，任务将在它们之间共享。

这个概念在Web应用中特别有用，因为在Web应用中不可能在较短的HTTP请求窗口内处理复杂的任务，(译注：例如注册时发送邮件或短信验证码等场景)。
### 准备工作
在本教程的上一部分，我们发送了一条包含“Hello World！”的消息。现在，我们将发送代表复杂任务的字符串。我们没有实际的任务，例如调整图像大小或渲染pdf文件，所以我们通过借助time.Sleep函数模拟一些比较耗时的任务。我们会将一些包含.的字符串封装为消息发送到队列中，其中每有一个.就表示需要耗费1秒钟的工作，例如，hello...表示一个将花费三秒钟的假任务。

我们将稍微修改上一个示例中的send.go代码，以允许从命令行发送任意消息。该程序会将任务安排到我们的工作队列中，因此我们将其命名为new_task.go

### 循环调度
使用任务队列的优点之一是能够轻松并行化工作。如果我们的工作正在积压，我们可以增加更多的工人，这样就可以轻松扩展。

首先，让我们尝试同时运行两个worker.go脚本。它们都将从队列中获取消息。这时候需要打开三个控制台。其中两个运行worker.go脚本。这些控制台将成为我们的两个消费者--C1和C2。

在第三个控制台中，我们将发布新任务。启动消费者之后，可以发布一些消息

之后我们就可以在C1和C2两个窗口看到如下的输出结果：

默认情况下，RabbitMQ将按顺序将每个消息发送给下一个消费者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式成为轮询。可以使用三个或者多个worker试一下。

### 消息确认
work完成任务可能需要耗费几秒钟，如果一个worker在任务执行过程中宕机了该怎么办？在当前代码中RabbitMQ一旦向消费者传递了一条消息，便立即将其标记为删除。在这种情况下，如果你终止一个worker那么你就可能会丢失这个任务，我们还将丢失所有已经交付给这个worker的尚未处理的消息。

我们不想丢失任何任务，如果一个worker意外宕机了，那么我们希望将任务交付给其他worker来处理

为了确保消息永不丢失，RabbitMQ支持消息确认。消费者返回一个确认(acknowledgement)，以告知RabbitMQ已经接收，处理了特定的消息，并且RabbitMQ可以自由删除它。

如果使用者在不发送确认的情况下死亡(其通道已关闭，连接已关闭或TCP连接丢失)，RabbitMQ将了解消息未完全处理，并将对其重新排队。如果同时有其他消费者在线，它将很快将其重新分发给另一个消费者。这样，您可以确保即使工人偶尔死亡也不会丢失任何消息。

没有任何消息超时，RabbitMQ将在消费者死亡时重新传递消息。即使处理一条消息要很长时间也没关系。

在本教程中，我们将使用手动消息确认，方法是为“auto-ack”参数传递一个false，然后在完成任务后，使用d.Ack(false)从worker发送一个正确的确认(这将确认一次传递)

使用消息确认模式，可以确保即使你在处理消息时使用CTRL+C杀死一个worker，也不会丢失任何内容。在worker死后不久，所有未确认的消息都将被重新发送。

消息确认必须在接收消息的同一通道(Channel)上发送。尝试使用不同的通道(Channel)进行消息确认将导致通道级协议异常。

### 忘记确认
忘记确认是一个常见的错误。这是一个简单的错误，但是后果很严重。当你的客户机退出时，消息将被重新传递(这看起来想随机重新传递)，但是RabbitMQ将消耗越来越多的内存，因为它无法释放任何未确认的消息。

为了调试这种错误，可以使用rabbitmqctl打印message_unacknowledged字段
```bash
rabbitmqctl.bat list_queues name message_ready message_unacknowed
```

### 消息持久化
我们已经学会如何确保即使消费者死亡，任务也不会消失。但如果RabbitMQ服务器停止运行，我们任务仍然会丢失。当RabbitMQ退出或崩溃时，它将忘记队列和消息，除非你告诉它不要这样做。要确保数据不丢失，需要做两件事，需要将消息和队列都标记为持久的。
```go
q, err := ch.QueueDeclare(
    // name
    "hello",
    // 声明为持久化
    true,
    // delete when unused
    false,
    // exclusive
    false,
    // no-wait
    false,
    // arguments
    nil,
)
```
虽然这个命令本身是正确的，但它在我们当前的设置中不起作用。这是因为我们已经定义了一个名为hello的队列，它不是持久的。RabbitMQ不允许使用不同的参数重新定义现有队列，并将向任何尝试重新定义的程序返回错误。但有一个快速解决方法--声明一个具有不同名称的队列。

这种持久的选项更改需要同时应用于生产者代码和消费者代码。

在这一点上我们确信即使RabbitMQ重新启动，任务队列也不会消失。

### 有关消息持久性的说明
将消息标记为持久性并不能完全保证消息不会丢失。尽管它告诉RabbitMQ将消息保存到磁盘上，但是RabbitMQ接受了一条消息并且还没有保存它时，仍然有一个很短的时间窗口。而且，RabbitMQ并不是对每个消息都执行fsync(2)--它可能只是保存到缓存中，而不是真正写入磁盘中。持久性保证不是很强，但是对于我们的简单任务队列来说已经足够了。如果需要更强有力的担保，那么可以使用publisher confirms。

### 公平分发
你可能已经注意到调度仍然不能完全按照我们的要求工作。例如，在一个有两个worker的情况下，当所有的奇数消息都是重消息而偶数消息都是轻消息时，一个worker将持续忙碌，而另一个worker几乎不用做任何工作。RabbitMQ对此一无所知，仍然会均匀的发送消息。

这是因为RabbitMQ只是在消息进入队列时发送消息。它不考虑消费者在未确认消息的数量。只是盲目的向消费者发送消息。

为了避免这种情况，我们可以将预计数设置为1。这告诉RabbitMQ不要一次向一个worker发出多个消息。或者换句话说，在处理并确认前一条消息前，不要向worker发送任何消息。相反，它将把它发送给下一个不忙的worker。
```go
err = ch.Qos(
    // prefetch count
    1,
    // prefetch size
    0,
    // global
    false,
)
```

### 关于队列的大小说明
如果所有的worker都很忙，你的queue随时可能会满。你会想继续关注这一点，也许需要增加更多的worker，或者有一些其他的策略。
