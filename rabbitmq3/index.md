# RabbitMQ3

## 发布订阅
在上一个教程中，我们创建了一个工作队列。工作队列背后的假设是每个任务只传递给一个工人。在这一部分中，我们将做一些完全不同的事情--我们将向多个消费者传递一个消息。这就是所谓的"订阅/发布模式"。

 为了说明这种模式，我们将构建一个简单的日志系统。它由两个程序组成--第一个程序将发出日志消息，第二个程序将接收并打印他们。

在我们的日志系统中，每一个运行的接收器程序副本都会受到消息。这样我们就可以运行一个接收器并将日志定向到磁盘；同时，我们还可以运行另一个接收器并在屏幕上查看日志。

本质上，已发布的日志消息将被广播到所有接收者。

### Exchanges(交换器)
在本教程的前面部分中，我们向队列发送消息和从队列接收消息。现在是时候在Rabbit中引入完整的消息传递模型了。

快速回顾先前教程的内容：
- "生产者"是发送消息的用户应用程序
- "队列"是存储消息的缓冲区
- "消费者"是接收消息的用户应用程序

RabbitMQ的消息传递模型中的核心思想是生产者从不将任何消息发送到队列。实际上，生产者甚至根本不知道是否将消息传递到任何队列。

相反，生产者只能将消息发送到交换器。交换器是非常简单的东西。一方面，它接收来自生产者的消息，另一方面，将它们推入队列。交换器必须确切知道如何处理接收到的消息。它应该被附加到特定的队列？还是应该将其附加到许多队列中？或者它应该被丢弃。这些规则由交换器的类型定义。

有几种交换器类型可用：direct， topic， headers和fanout。我们将集中讨论最后一个--fanout。

fanout(扇出)交换器非常简单。正如名称一样，它只是将接收到的所有消息广播到它知道的所有队列中。而这正是我们记录器所需要的。

### 临时队列
先前我们使用的是具有特定名称的队列，能够命名队列对我们来说至关重要--我们需要将工作人员指向同一个队列。当你想在生产者和消费者之间共享队列时，给队列一个名称是非常重要的。

但对于记录器来说，情况并非如此。我们希望收到所有的日志消息，而不仅仅是它们的一部分。我们也只对当前正在发送的消息感兴趣，而对旧消息不感兴趣。为了解决这个问题，我们需要两件事。

首先，当我们连接RabbitMQ时，我们需要一个新的空的队列。为此，我们可以创建一个随机名称的队列，或者更好的方法是让服务器为我们选择一个随机队列名称。

其次，一旦我们断开消费者的连接，队列就会自动删除。

在amqp客户端中，当我们传递一个空字符串作为队列名称时，我们将使用随机生成的名称创建一个非持久队列：
```go
q, err := ch.QueueDeclare(
    // 空字符串作为队列的名称
    "",
    // 非持久队列
    false,
    // delete when unused
    false,
    // 独占队列(当前声明队列的连接关闭后即被删除)
    true,
    // no-wait
    false,
    // arguments
    nil,
)
```
上述方法返回时，生成的队列实例包含RabbitMQ生成的随机队列名称。例如，它可能看起来像amq.gen-JzTY20RgKO-HjmUJj0wLg。

当声明它的连接关闭时，该队列将被删除，因为它被声明为独占。

## 绑定
我们已经创建了一个扇出交换器和一个队列。现在我们需要告诉服务器将消息发送到我们的队列。交换器和队列之间的关系成为*绑定*

```go
ch.QueueBind(
    // queue name
    q.Name,
    // routing key
    "",
    // exchange
    "logs",
    false,
    nil,
)
```

从现在开始，logs交换器将会把消息添加到我们的队列中。

### 列出绑定关系
```bash
rabbitmqctl list_binding
```

如果要将日志保存到文件，只需打开控制台并输入：
```bash
go run receive_logs.go > logs_from_rabbit.log
```

如果希望在屏幕上查看日志，请切换到一个新的终端并运行
```bash
go run receive_logs.go
```

当然要发日志，请输入：
```bash
go run emit_log.go
```
