# Redis Interview 01

<!--more-->
## 概述
### 什么是Redis
Redis是一个使用C语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。

Redis可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持5种数据类型：字符串，列表，集合，散列表，有序集合。

与传统数据库不同的是Redis的数据是存在内存中的，所以读写速度非常快，因此Redis被广泛引用与缓存方向，每秒可以处理11万写操作，8万读操作，是已知性能最快的Key-Value DB。另外，Redis也经常用来做分布式锁。除此之外，Redis支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案。
### Redis有哪些优缺点
优点
- 读写性能优异，Redis能写的速度是11w次/秒，写的速度是8w次/秒
- 支持数据持久化，支持RDB和AOF两种持久化方式
- 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性操作
- 数据结构丰富，除了支持String类型的Value外还支持hash、set、zset、list等数据结构
- 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离
缺点
- 数据库容量容易受到物理内存限制，不能作为海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
- Redis不具备自动容错和回复功能，主机从机宕机都会导致前端部分读写请求失败，需要等待机器重启或手动切换前端的IP才能回复
- 主机宕机，宕机前有部分数据未及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
- Redis较难支持在线扩容，在集群容量到达上限时在线扩容会变得很复杂，为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费
### 为什么要用Redis
高性能：

假如用户第一次访问数据库中的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将用户访问的数据缓存在缓存中，这样下次再访问这些数据会直接从缓存中获取。操作缓存就是直接操作内存，所以速度相当快，如果数据库中的对应数据改变的之后，同步改变缓存中的对应数据即可。

高并发：

直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。
### 为什么要用Redis而不用map/guava做缓存
缓存分为本地缓存和分布式缓存。以Java为例，使用自带的map或guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每一个实例需要各自保存一份缓存，缓存不具备一致性。

使用Redis或Memcache之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。确定需要保持redis或memcache服务的高可用，整个程序架构上较为复杂。
### Redis为什么这么快
1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。
2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。
4. 使用多路I/O复用模型，非阻塞IO。
5. 使用底层模型不同，他们之间底层的实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定时间去移动和请求。
## 数据类型
### Redis有哪些数据类型
Redis主要有5种数据类型，包括String，List，Set，Zset，Hash，满足大部分的使用要求
|数据类型|可以存储的值|操作|应用场景
|---|---|---|---|
|String|字符串、整数或浮点型|对整个字符串或者字符串的其中一部分执行操作。对整数和浮点数执行自增或自减操作|做简单的键值对缓存
|List|列表|从两端压入或弹出元素，对单个或多个元素进行修剪，只保留一个范围内的元素|存储一些列表型的数据结构，类似粉丝列表，文章的评论列表之类的数据|
|Set|无序集合|添加、获取、移除单个元素，检查一个元素是否在集合中。计算交集、并集、差集从集合里面随机获取元素|交集、并集、差集的操作，比如交集，可以把两个人的粉丝表整成一个交集|
|Hash|包含键值对的无序散列表|添加、获取、删除单个键值对，获取所有键值对，检查某个键是否存在|结构化的数据，比如一个对象|
|Zset|有序集合|添加、获取、删除元素。根据分值范围或者成员来获取元素。计算一个键的排名|去重但可以排序，如获取排名前几名的用户|
## Redis的应用场景
### 计数器
可以对string进行自增或自减运算，从而实现计数器功能。Redis这种内存型数据库的读写性能特别高，最适合存储频繁读写的计数量
### 缓存
将热点数据放在内存中，设置内存的最大使用以及淘汰策略来保证缓存的命中率
### 会话缓存
可以使用Redis来同一存储多态应用服务器的会话信息。当服务器不在存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性
### 全页缓存（FPC）
除基本的会话token之外，Redis还提供很简单的FPC平台。以Megento为例，Megento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件wp-redis，这个插件可以帮助以最快速度加载已经浏览过的页面。
### 查找表
例如DNS记录就很适合用Redis进行存储。查找表和缓存类似，也是利用了Redis快速查找的特性。但是查找表的内容不能失效，而缓存内容可以失效，因为缓存不作为可靠的数据来源
### 消息队列（发布/订阅功能）
List是一个双向链表，可以通过lpush和rpop写入和读取消息。不过最好使用kafka，RabbitMQ等消息中间件。
### 分布式锁实现
在分布式场景下，无法使用单机环境下的锁对多个节点上的进程进行同步。可以使用Redis自带的SETNX命令实现分布式锁，除此之外还可以使用官方提供的RedLock分布式锁实现
### 其他
Set可以实现交集、并集等操作，从而实现共同好友等功能。Zset可以实现有序性操作，从而实现排行榜的功能。
## 持久化
### 什么是Redis持久化
持久化就是把内存的数据写到磁盘，防止服务宕机，内存数据丢失
### Redis的持久化机制是什么？各自的优缺点？
Redis提供两种持久化机制RDB（默认）和AOF机制

RDB：是Redis DataBase缩写快照

RDB是Redis默认的持久化方式。按照一定时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期
!["RDB机制"](/images/RDB.png "RDB机制")

优点：
- 只有一个文件dump.rdb，方便持久化
- 容灾性好，一个文件可以保存在安全磁盘
- 性能最大化，fork子进程来完成写操作，让主程序继续执行命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了Redis的高性能
- 相对于数据集大时，比AOF的启动效率更高

缺点
- 数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间Redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

AOF（Append Only File）持久化：将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。
!["AOF机制"](/images/AOF.png "AOF机制")

当两种方式同时打开时，数据恢复Redis会优先

优点：
- 数据安全，aof持久化可以配置appendfsync属性，有always，每进行一个命令操作就记录到aof文件中一次
- 通过append模式写文件，即使中途遇到宕机，也可以通过redis-check-aof工具解决数据一致性的问题
- AOF机制的rewrite模式。AOF文件没被rewrite之前（文件过大会对命令进行合并或重写），可以删除其中的某些命令（比如误操作的flushall）

缺点
- AOF文件比RDB文件大，且恢复速度慢
- 数据量大的时候，比rdb启动效率低

两者的区别
- AOF文件比RDB更新频率高，优先使用AOF还原数据
- AOF比RDB更安全也更大
- RDB性能比AOF好
### 如何选择合适的持久化方式
- 一般来说，如果想达到足以媲美PostgreSQL的数据安全性，应该同时使用两种持久化功能。在这种情况下，Redis重启的时候会优先载入AOF文件来恢复原始数据，因为通常情况下AOF保存的数据要比RDB文件保存的数据更完整
- 如果非常关心数据，但仍然可以承受数分钟内的数据丢失，可以只使用AOF持久化
- 许多用户只使用AOF持久化，但是不推荐这种方式，因为定时生成RDB快照非常便利于进行数据库备份，并且RDB恢复数据的速度要比AOF的速度快得多，除此之外，使用RDB还可以避免AOF程序的bug
- 如果只希望数据在服务器运行时存在时，可以不使用任何持久化方式。
### Redis持久化数据和缓存怎么做扩容
- 如果Redis被当做缓存使用，使用一致性的hash实现动态扩容缩容
- 如果Redis被当做一个持久化存储使用，必须使用固定的key-to-nodes映射关系，节点数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。
