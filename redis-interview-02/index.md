# Redis Interview 02

<!--more-->
## 过期键的删除策略
### Redis的过期键的删除策略
Redis是一个key-value数据库，我们可以在Redis中设置键的过期时间。Redis的过期策略就是指当前Redis中的缓存key过期了，Redis如何处理。

通常过期策略有以下三种：
1. 定时过期：每个设置了过期时间的key都需要创建一个定时器，过到期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的相应时间和吞吐量。
2. 惰性过期：只有当访问一个key时，才会判断这个key是否过期，过期则立即清除。该策略可以最大化的节省CPU资源，却对内存非常不友好。极端情况下可能出现大量过期的key没有再次被访问，从而不会被删除，占用大量内存。
3. 定期过期：每隔一定时间，会扫描一定数量数据库的expires字典中一定数量的key，并清除其中已经过期的key。该策略是前两种的折中策略。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

（expires字典会保存所有设置了过期时间的key的过期时间和数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度Unix时间戳表示的过期时间，键空间是指该Redis集群中保存的所有键）

Redis中同时使用了惰性过期和定期过期两种过期方式。
### Redis key的过期时间和永久有效分别怎么设置
EXPIRE和PERSIST命令
### 通过EXPIRE来设置key的过期时间，那么对过期的数据怎么处理
除了缓存服务器自带的缓存失效策略之外（Redis中有6中策略可以选择），还可以根据具体业务自定义的缓存淘汰，常见的策略有两种：
1. 定时去清理过期缓存
2. 当有用户请求时，再判断这个所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。
## 内存相关
### MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据
redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略
### Redis的内存淘汰策略有哪些
Redis的内存淘汰策略是指在Redis的用于缓存的内存不足，怎么处理需要新写入且需要申请额外空间的数据
全局的键空间选择性移除：
- noeviction：当内存不足容纳写入新数据时，新写入操作会报错
- allkeys-lru：当内存不足容纳写入新数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
- allkeys-random：当内存不足容纳写入新数据时，在键空间随机移除某个key
设置过期时间的键空间选择性移除
- volatile-lru：当内存不足容纳写入新数据时，在设置了过期时间的键空间中，移除最近最少使用的key
- volatile-random：当内存不足容纳写入新数据时，在设置了过期时间的键空间中，随机移除某个key
- volatile-ttl：当内存不足容纳写入新数据时，在设置了过期时间的键空间中，有更早过期的key优先移除
### Redis如何做内存优化
可以利用Hash，Set，Zset，List等集合类型数据。因为通常情况下很多小的key-value可以用更紧凑的方式放在一起。尽量使用散列表（hash），散列表使用的内存非常小。
## 线程模型
### Redis线程模型
Redis基于Reactor模式开发了网络时间处理器，这个处理器被称为文件时间处理器。它的组成结构为4部分多个套接字，IO多路复用程序，文件事件分派器，事件处理器。因为文件事件分配器队列的消费是单线程的，所以Redis才叫单线程模型。
## 事务
### 什么是事务
事务是一个单独的隔离操作，事务中的所有命令都会序列化，按一定顺序执行。事务在执行的过程中，不会被其他客户端发来的命令请求打断。

事务是一个原子操作。事务中的命令要么全部执行要么都不执行。
### Redis事务概念
Redis事务的本质是通过MULTI，EXEC，WATCH等一组命令的集合。事务支持一次执行多条指令，一个事务中的所有命令都会被序列化。在事务执行过程中，会按照序列串行化执行队列中的命令，其他客户端的请求不会插入到事务执行命令序列中。

总结：Redis事务就是一次性、顺序性、排他性的执行一个队列里的一系列命令。
### Redis事务的三个命令
1. 事务开始 MULTI
2. 命令入队
3. 事务结束 EXEC
### Redis保证原子性吗？支持回滚吗？
Redis中单条命令是原子性的，但是事务不保证原子性不支持回滚。事务中的命令只要没有语法错误，事务中的命令都会依次执行。
## 集群方案
### 哨兵模式
哨兵主要功能：
- 集群监控：负责监控master和slave是否正常工作。
- 消息通知：如果某个实例有故障，哨兵负责发送消息作为报警通知给管理员
- 故障转移：如果master挂了，会投票选一个slave作为master
- 配置中心：如果故障转移了，通知client客户端新的master地址
哨兵模式用于实现Redis集群的高可用，本身也是分布式的，是以集群运行工作的。
- 故障转移时，判断一个主机是否宕机，需要大部分哨兵同意，这涉及分布式选举。
- 即使部分哨兵失效了，哨兵集群还是能正常工作的。
哨兵的核心知识：
- 哨兵至少要有三个实例来保证健壮性
- 哨兵+redis主从的部署结构，不会保证数据零丢失，只能保证Redis集群的高可用性
## 缓存异常
### 缓存雪崩
缓存雪崩是指缓存同一时间大面积失效，所以后面的请求都会落在数据库上，造成数据库短时间内承受大量请求而崩掉。
解决方案
- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
- 一般并发量不是特别多的时候，使用最多的是加锁排队
- 给每个缓存数据添加缓存标记，记录缓存是否失效，如果标记失效，更新缓存。
### 缓存穿透
缓存穿透是指缓存和数据库中都没有数据，导致所有的请求都落在数据库上，造成数据短时间承受大量请求而崩掉
解决方案：
- 接口层添加校验，如用户鉴权校验，id作为基础校验，id小于等于0直接拦截
- 从缓存中取不到数据，在数据库中也取不到数据，这时可以将key-value写成key-null，缓存有效时间可以写短一点，（设置太长可能导致正常情况也没法使用）。这样可以防止攻击用户反复使用一个id攻击。
- 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免对底层存储系统的查询压力。
### 缓存击穿
缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间过期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库取数据，引起数据库压力瞬间增大，造成过大压力。

和雪崩不同的是：缓存击穿指并发差同一条数据，缓存雪崩是指不同的数据都过期了，很多数据查不到从而查数据库

解决方案：
- 设置热点数据永不过期
- 加互斥锁
